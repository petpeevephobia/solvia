<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solvia Dashboard - SEO on AI Autopilot</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css?v=1.2">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="dashboard-body">
    <nav class="navbar">
        <div class="navbar-brand">Solvia</div>
        <div class="navbar-user">
            <div class="user-avatar" id="userAvatar" onclick="toggleMobileMenu()">S</div>
            <span id="userEmail" class="desktop-only">user@example.com</span>
            <button class="logout-btn desktop-only" onclick="logout()">Logout</button>
        </div>
    </nav>

    <!-- Mobile Side Menu -->
    <div id="mobileMenuOverlay" class="mobile-menu-overlay" onclick="closeMobileMenu()"></div>
    <div id="mobileMenu" class="mobile-menu">
        <div class="mobile-menu-header">
            <div class="mobile-menu-avatar" id="mobileMenuAvatar">S</div>
            <div class="mobile-menu-user-info">
                <div class="mobile-menu-email" id="mobileMenuEmail">user@example.com</div>
                <div class="mobile-menu-website" id="mobileMenuWebsite">No website selected</div>
            </div>
            <button class="mobile-menu-close" onclick="closeMobileMenu()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="mobile-menu-content">
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Navigation</div>
                <button class="mobile-menu-item active" onclick="closeMobileMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="14" y="14" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                    </svg>
                    <span>Dashboard</span>
                </button>
                <button class="mobile-menu-item" onclick="window.location.href='/fixes'; closeMobileMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                    </svg>
                    <span>SEO Fixes</span>
                </button>
            </div>
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Website</div>
                <button class="mobile-menu-item" onclick="changeWebsite(); closeMobileMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                    </svg>
                    <span>Change Website</span>
                </button>
            </div>
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Account</div>
                <button class="mobile-menu-item" onclick="logout()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                        <polyline points="16,17 21,12 16,7"></polyline>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                    <span>Logout</span>
                </button>
            </div>
        </div>
    </div>

    <div class="container dashboard-container">
        <!-- GSC Connection Banner -->
        <div id="gscBanner" class="gsc-banner hidden">
            <div class="banner-content">
                <div class="banner-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4.5 16.5c-1.5 1.5-1.5 4.5 0 6s4.5 1.5 6 0l10-10c1-1 1-2.5 0-3.5s-2.5-1-3.5 0l-10 10z"></path>
                        <path d="M13.5 6.5l4 4"></path>
                        <path d="M12 2l2 2-2 2-2-2 2-2z"></path>
                    </svg>
                </div>
                <div class="banner-text">
                    <h3>Connect Google Search Console</h3>
                    <p>Get real SEO data for your dashboard by connecting your Google Search Console account.</p>
                </div>
                <div class="banner-actions">
                    <button onclick="connectGSC()" class="btn-connect">Connect GSC</button>
                </div>
            </div>
        </div>

        <div class="dashboard-header">
            <div class="dashboard-title-row">
                <h1>Your Dashboard</h1>
                <button onclick="refreshMetrics()" class="btn-refresh" id="refreshBtn" title="Refresh Data">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rotate-cw"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                </button>
            </div>
            <div>
                <div id="dateRangeInfo" class="date-range-info hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                    <span id="dateRange"></span>
                </div>
                <div id="websiteInfo" class="website-info hidden">
                    <span>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-icon">
                            <line x1="18" y1="20" x2="18" y2="10"></line>
                            <line x1="12" y1="20" x2="12" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="14"></line>
                        </svg>
                        Tracking: 
                    </span>
                    <span id="trackedWebsite" class="tracked-website"></span>
                </div>
            </div>
        </div>

        <div class="stats-grid">
            <!-- Overall SEO Score Card -->
            <div class="stat-card overall-score">
                <div class="score-header">
                    <h3>Overall SEO Score</h3>
                    <div class="score-badge" id="seoScore">0</div>
            </div>
                <div class="score-change" id="seoScoreChange">+0%</div>
                <div class="score-description">Based on all metrics</div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="charts-section" id="mergedChartsSection">
            <div class="content-card">
                <div class="card-header">
                    <h2>Organic Traffic & Impressions</h2>
                </div>
                <div class="card-body">
                    <canvas id="mergedTrendsChart" height="300"></canvas>
                </div>
            </div>
        </div>

        <div class="analysis-grid">
            <!-- Visibility Performance Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="20" x2="18" y2="10"></line>
                            <line x1="12" y1="20" x2="12" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="14"></line>
                        </svg>
                    </div>
                    <h2>Visibility Performance</h2>
                    <div class="status-indicator" id="visibilityStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Impressions</span>
                            <span class="metric-value" id="impressionsValue">0</span>
                            <span class="metric-change" id="impressionsChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Clicks</span>
                            <span class="metric-value" id="clicksValue">0</span>
                            <span class="metric-change" id="clicksChange">+0</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">CTR</span>
                            <span class="metric-value" id="ctrValue">0%</span>
                            <span class="metric-change" id="ctrChange">+0%</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Avg Position</span>
                            <span class="metric-value" id="avgPositionValue">N/A</span>
                            <span class="metric-change" id="avgPositionChange">+0.0</span>
                        </div>
                    </div>
                    <div class="insights" id="visibilityInsights">
                        <p>Connect Google Search Console to see visibility insights</p>
                    </div>
            </div>
        </div>


            <!-- Engagement & UX Performance Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"></polygon>
                        </svg>
                    </div>
                    <h2>Engagement & UX</h2>
                    <div class="status-indicator" id="uxStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Performance Score</span>
                            <span class="metric-value" id="performanceScore">N/A</span>
                            <span class="metric-change" id="performanceScoreChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">LCP</span>
                            <span class="metric-value" id="lcpValue">N/A</span>
                            <span class="metric-change" id="lcpChange">+0.0s</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">FCP</span>
                            <span class="metric-value" id="fcpValue">N/A</span>
                            <span class="metric-change" id="fcpChange">+0.0s</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">CLS</span>
                            <span class="metric-value" id="clsValue">N/A</span>
                            <span class="metric-change" id="clsChange">+0.00</span>
                        </div>
                    </div>
                    <div class="insights" id="uxInsights">
                        <p>Performance data will appear when connected</p>
                    </div>
                </div>
            </div>

            <!-- Mobile Usability Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
                            <line x1="12" y1="18" x2="12.01" y2="18"></line>
                        </svg>
                    </div>
                    <h2>Mobile Usability</h2>
                    <div class="status-indicator" id="mobileStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Mobile Friendly</span>
                            <span class="metric-value" id="mobileFriendly">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Issues</span>
                            <span class="metric-value" id="mobileIssues">0</span>
                            <span class="metric-change" id="mobileIssuesChange">+0</span>
                        </div>
                    </div>
                    <div class="insights" id="mobileInsights">
                        <p>Mobile test results will appear here</p>
                    </div>
                </div>
            </div>

            <!-- Indexing & Crawlability Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="M21 21l-4.35-4.35"></path>
                        </svg>
                    </div>
                    <h2>Indexing & Crawlability</h2>
                    <div class="status-indicator" id="indexingStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Sitemap Status</span>
                            <span class="metric-value" id="sitemapStatus">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Sitemap Count</span>
                            <span class="metric-value" id="sitemapCount">N/A</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Indexed Pages</span>
                            <span class="metric-value" id="indexedPages">N/A</span>
                            <span class="metric-change" id="indexedPagesChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Index Status</span>
                            <span class="metric-value" id="indexStatus">N/A</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Crawl Errors</span>
                            <span class="metric-value" id="crawlErrors">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Crawl Success Rate</span>
                            <span class="metric-value" id="crawlSuccessRate">N/A</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Last Crawl</span>
                            <span class="metric-value" id="lastCrawl">N/A</span>
                        </div>
                    </div>
                    <div class="insights" id="indexingInsights">
                        <p>Indexing health will be analyzed</p>
                    </div>
                </div>
            </div>

            <!-- Business Context Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 21h18"></path>
                            <path d="M5 21V7l8-4v18"></path>
                            <path d="M19 21V11l-6-4"></path>
                            <path d="M9 9v.01"></path>
                            <path d="M9 12v.01"></path>
                            <path d="M9 15v.01"></path>
                            
                            <path d="M9 18v.01"></path>
                        </svg>
                    </div>
                    <h2>Business Context</h2>
                    <div class="status-indicator" id="businessStatus">Good</div>
                </div>
                <div class="card-body">
                    <!-- Primary Business Metrics (High Priority) -->
                    <div class="metrics-row">
                        <div class="metric primary-metric">
                            <span class="metric-label">Business Type</span>
                            <span class="metric-value" id="businessType">N/A</span>
                            <span class="metric-change" id="businessTypeChange">No Change</span>
                        </div>
                        <div class="metric primary-metric">
                            <span class="metric-label">Target Market</span>
                            <span class="metric-value" id="targetMarket">N/A</span>
                            <span class="metric-change" id="targetMarketChange">No Change</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric primary-metric">
                            <span class="metric-label">Industry Sector</span>
                            <span class="metric-value" id="industrySector">N/A</span>
                        </div>
                        <div class="metric primary-metric">
                            <span class="metric-label">Company Size</span>
                            <span class="metric-value" id="companySize">N/A</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric primary-metric" style="width: 50%;">
                            <span class="metric-label">Primary Age Group</span>
                            <span class="metric-value" id="primaryAgeGroup">N/A</span>
                        </div>
                    </div>
                    
                    <!-- Secondary Business Metrics (Lower Priority) -->
                    <div class="secondary-metrics" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #E5E7EB;">
                        <div class="metrics-row">
                            <div class="metric secondary-metric">
                                <span class="metric-label">Income Level</span>
                                <span class="metric-value" id="incomeLevel">N/A</span>
                            </div>
                            <div class="metric secondary-metric">
                                <span class="metric-label">Audience Sophistication</span>
                                <span class="metric-value" id="audienceSophistication">N/A</span>
                            </div>
                        </div>
                        <div class="metrics-row">
                            <div class="metric secondary-metric">
                                <span class="metric-label">Geographic Focus</span>
                                <span class="metric-value" id="geographicFocus">N/A</span>
                            </div>
                            <div class="metric secondary-metric">
                                <span class="metric-label">Business Maturity</span>
                                <span class="metric-value" id="businessMaturity">N/A</span>
                            </div>
                        </div>
                        <div class="metrics-row">
                            <div class="metric secondary-metric">
                                <span class="metric-label">Technology Platform</span>
                                <span class="metric-value" id="technologyPlatform">N/A</span>
                            </div>
                            <div class="metric secondary-metric">
                                <span class="metric-label">Content Strategy</span>
                                <span class="metric-value" id="contentStrategy">N/A</span>
                            </div>
                        </div>
                        <div class="metrics-row">
                            <div class="metric secondary-metric" style="width: 50%;">
                                <span class="metric-label">Competitive Position</span>
                                <span class="metric-value" id="competitivePosition">N/A</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="insights" id="businessInsights">
                        <p>Business analysis will provide context</p>
                    </div>
                </div>
            </div>

            <!-- Keyword Trends Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="22,7 13.5,15.5 8.5,10.5 2,17"></polyline>
                            <polyline points="16,7 22,7 22,13"></polyline>
                        </svg>
                    </div>
                    <h2>Keyword Trends</h2>
                    <div class="status-indicator" id="keywordStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Total Keywords</span>
                            <span class="metric-value" id="totalKeywords">0</span>
                            <span class="metric-change" id="totalKeywordsChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Avg Position</span>
                            <span class="metric-value" id="keywordAvgPosition">N/A</span>
                            <span class="metric-change" id="keywordAvgPositionChange">+0.0</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Opportunities</span>
                            <span class="metric-value" id="keywordOpportunities">0</span>
                            <span class="metric-change" id="keywordOpportunitiesChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Branded</span>
                            <span class="metric-value" id="brandedKeywords">0</span>
                            <span class="metric-change" id="brandedKeywordsChange">+0</span>
                        </div>
                    </div>
                    <div class="insights" id="keywordInsights">
                        <p>Loading keyword performance insights...</p>
                    </div>
                                    <div class="keywords-list" id="keywordsList">
                    <h4>Keywords Found:</h4>
                    <div id="keywordsContainer" class="keywords-container">
                        <p class="keywords-loading">Loading keywords...</p>
                </div>
            </div>
        </div>
                </div>
            </div>
            
    <div id="metricsPopupContainer">
        <div id="metricsSuccessPopup">
            All metrics loaded successfully! <span id="metricsSuccessTimer" class="timer"></span>
                </div>
        <div id="metricsLoadingPopup">
            <div id="metricsLoadingList"></div>
        </div>
    </div>

    <script>
        // Global chart instances
        let organicTrafficChart = null;
        let impressionsChart = null;
        let isRefreshingToken = false; // Flag to prevent multiple refresh attempts
        
        // Global variables for metric data
        window.metricsData = {
            summary: {},
            ux: {},
            mobile: {},
            indexing: {},
            keywords: {},
            business: {}
        };
        let refreshAttempts = 0; // Track refresh attempts to prevent infinite loops
        const MAX_REFRESH_ATTEMPTS = 3; // Maximum number of refresh attempts
        let lastRefreshTime = 0; // Track when we last attempted a refresh
        let isRedirecting = false; // Flag to prevent multiple redirects
        let consecutiveFailures = 0; // Track consecutive API failures
        
        const METRIC_GROUPS = [
          { key: 'organic', label: 'Organic Traffic Trends' },
          { key: 'impressions', label: 'Impressions Trends' },
          { key: 'visibility', label: 'Visibility Performance' },
          { key: 'ux', label: 'Engagement & UX' },
          { key: 'mobile', label: 'Mobile Usability' },
          { key: 'indexing', label: 'Indexing & Crawlability' },
          { key: 'business', label: 'Business Context' },
          { key: 'keywords', label: 'Keyword Trends' },
        ];
        let metricsLoadingState = {};
        
        // Check if we're in an infinite loop situation
        function checkForInfiniteLoop() {
            if (consecutiveFailures > 5) {
                console.log('[TOKEN DEBUG] Detected potential infinite loop, clearing token immediately');
                clearInvalidToken();
                return true;
            }
            return false;
        }
        
        function isValidTokenFormat(token) {
            if (!token || typeof token !== 'string') {
                console.log('[TOKEN DEBUG] Token is null, undefined, or not a string:', token);
                return false;
            }
            
            // Check if token has the correct JWT format (3 parts separated by dots)
            const parts = token.split('.');
            console.log('[TOKEN DEBUG] Token parts count:', parts.length);
            
            if (parts.length !== 3) {
                console.log('[TOKEN DEBUG] Invalid JWT structure - expected 3 parts, got:', parts.length);
                console.log('[TOKEN DEBUG] Token parts:', parts);
                return false;
            }
            
            // Try to decode the payload to check if it's valid JSON
            try {
                const payload = JSON.parse(atob(parts[1]));
                console.log('[TOKEN DEBUG] Successfully decoded payload:', payload);
                
                // Check for required fields
                if (!payload || typeof payload !== 'object') {
                    console.log('[TOKEN DEBUG] Payload is not a valid object:', payload);
                    return false;
                }
                
                // Check for required JWT fields
                if (!payload.sub) {
                    console.log('[TOKEN DEBUG] Missing "sub" field in payload');
                    return false;
                }
                
                if (!payload.exp) {
                    console.log('[TOKEN DEBUG] Missing "exp" field in payload');
                    return false;
                }
                
                // Check expiration
                const currentTime = Math.floor(Date.now() / 1000);
                const isExpired = payload.exp < currentTime;
                console.log('[TOKEN DEBUG] Token expiration check:', {
                    currentTime,
                    tokenExp: payload.exp,
                    isExpired,
                    timeUntilExpiry: payload.exp - currentTime
                });
                
                return true;
            } catch (error) {
                console.log('[TOKEN DEBUG] Failed to decode payload:', error);
                console.log('[TOKEN DEBUG] Raw payload part:', parts[1]);
                return false;
            }
        }
        
        function clearInvalidToken() {
            console.log('[TOKEN DEBUG] Clearing invalid token from localStorage');
            const oldToken = localStorage.getItem('auth_token');
            console.log('[TOKEN DEBUG] Old token (first 50 chars):', oldToken ? oldToken.substring(0, 50) + '...' : 'null');
            localStorage.removeItem('auth_token');
            if (!isRedirecting) {
                isRedirecting = true;
                window.location.href = '/ui';
            }
        }
        
        function checkAuth() {
            const token = localStorage.getItem('auth_token');
            console.log('[TOKEN DEBUG] checkAuth called');
            console.log('[TOKEN DEBUG] Token exists:', !!token);
            
            if (!token) {
                console.log('[TOKEN DEBUG] No token found, redirecting to login');
                if (!isRedirecting) {
                    isRedirecting = true;
                window.location.href = '/ui';
                }
                return false;
            }

            // First, validate token format
            console.log('[TOKEN DEBUG] Validating token format...');
            if (!isValidTokenFormat(token)) {
                console.log('[TOKEN DEBUG] Invalid token format detected, clearing token');
                clearInvalidToken();
                return false;
            }

            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                const userEmail = payload.sub || 'user@example.com';
                const userName = userEmail ? userEmail.split('@')[0] : 'User';
                
                // Check if token is expired
                const currentTime = Math.floor(Date.now() / 1000);
                const timeSinceLastRefresh = currentTime - lastRefreshTime;
                
                console.log('[TOKEN DEBUG] Token expiration check:', {
                    currentTime,
                    tokenExp: payload.exp,
                    isExpired: payload.exp && payload.exp < currentTime,
                    isRefreshing: isRefreshingToken,
                    refreshAttempts,
                    timeSinceLastRefresh,
                    userEmail
                });
                
                if (payload.exp && payload.exp < currentTime) {
                    console.log('[TOKEN DEBUG] Token expired, attempting to refresh...');
                    
                    // Prevent rapid refresh attempts - wait at least 5 seconds between attempts
                    if (timeSinceLastRefresh < 5) {
                        console.log('[TOKEN DEBUG] Too soon since last refresh attempt, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return false;
                    }
                    
                    if (!isRefreshingToken && refreshAttempts < MAX_REFRESH_ATTEMPTS) {
                        lastRefreshTime = currentTime;
                        refreshToken();
                    } else {
                        console.log('[TOKEN DEBUG] Refresh already in progress or max attempts reached, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                    }
                    return false;
                }
                
                console.log('[TOKEN DEBUG] Token is valid, updating UI');
                document.getElementById('userEmail').textContent = userEmail;
                document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                
                // Update mobile menu user info
                document.getElementById('mobileMenuEmail').textContent = userEmail;
                document.getElementById('mobileMenuAvatar').textContent = userName.charAt(0).toUpperCase();
                
                return true; // Authentication successful
            } catch (error) {
                console.error('[TOKEN DEBUG] Error decoding token:', error);
                clearInvalidToken();
                return false; // Authentication failed
            }
        }

        async function refreshToken() {
            if (isRefreshingToken) {
                console.log('Token refresh already in progress, skipping...');
                return;
            }
            
            if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
                console.log('Max refresh attempts reached, redirecting to login');
                if (!isRedirecting) {
                    isRedirecting = true;
                window.location.href = '/ui';
                }
                return;
            }
            
            isRefreshingToken = true;
            refreshAttempts++;
            
            try {
                const token = localStorage.getItem('auth_token');
                
                // Validate token format before attempting refresh
                if (!isValidTokenFormat(token)) {
                    console.log('Invalid token format in refreshToken, clearing token');
                    clearInvalidToken();
                    return;
                }
                
                const response = await fetch('/auth/refresh-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    localStorage.setItem('auth_token', data.access_token);
                    console.log('Token refreshed successfully');
                    refreshAttempts = 0; // Reset attempts on success
                    lastRefreshTime = 0; // Reset last refresh time
                    
                    // Verify the new token is not expired
                    try {
                        const newPayload = JSON.parse(atob(data.access_token.split('.')[1]));
                        const currentTime = Math.floor(Date.now() / 1000);
                        
                        if (newPayload.exp && newPayload.exp < currentTime) {
                            console.log('New token is also expired, redirecting to login');
                            if (!isRedirecting) {
                                isRedirecting = true;
                                window.location.href = '/ui';
                            }
                            return;
                        }
                        
                        // Update UI with the user info from the new token
                        const userEmail = newPayload.sub || 'user@example.com';
                        const userName = userEmail ? userEmail.split('@')[0] : 'User';
                        
                        document.getElementById('userEmail').textContent = userEmail;
                        document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                    } catch (error) {
                        console.error('Error updating UI after token refresh:', error);
                    }
                } else {
                    console.error('Failed to refresh token');
                    clearInvalidToken();
                }
            } catch (error) {
                console.error('Error refreshing token:', error);
                clearInvalidToken();
            } finally {
                isRefreshingToken = false;
            }
        }

        async function apiCall(url, options = {}) {
            const token = localStorage.getItem('auth_token');
            if (!token) {
                if (!isRedirecting) {
                    isRedirecting = true;
                    window.location.href = '/ui';
                }
                return;
            }

            // Validate token format before making API calls
            if (!isValidTokenFormat(token)) {
                console.log('[TOKEN DEBUG] Invalid token format in apiCall, clearing token');
                clearInvalidToken();
                return;
            }

            // Check for infinite loop before making the call
            if (checkForInfiniteLoop()) {
                return;
            }

            // Add authorization header
            options.headers = {
                'Authorization': `Bearer ${token}`,
                ...options.headers
            };

            try {
                const response = await fetch(url, options);
                
                // Reset consecutive failures on success
                if (response.ok) {
                    consecutiveFailures = 0;
                }
                
                // If token is expired, try to refresh and retry
                if (response.status === 401) {
                    consecutiveFailures++;
                    console.log('[TOKEN DEBUG] 401 error, consecutive failures:', consecutiveFailures);
                    
                    // Check for infinite loop
                    if (checkForInfiniteLoop()) {
                        return;
                    }
                    
                    console.log('Token expired, refreshing...');
                    
                    // Prevent multiple refresh attempts
                    if (isRefreshingToken) {
                        console.log('Token refresh already in progress, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    // Check if we've exceeded max attempts
                    if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
                        console.log('Max refresh attempts reached in apiCall, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    // Check if we've tried to refresh too recently
                    const currentTime = Math.floor(Date.now() / 1000);
                    if (currentTime - lastRefreshTime < 5) {
                        console.log('Too soon since last refresh attempt, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    isRefreshingToken = true;
                    refreshAttempts++;
                    lastRefreshTime = currentTime;
                    
                    try {
                        const refreshResponse = await fetch('/auth/refresh-token', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (refreshResponse.ok) {
                            const data = await refreshResponse.json();
                            localStorage.setItem('auth_token', data.access_token);
                            refreshAttempts = 0; // Reset on success
                            lastRefreshTime = 0; // Reset last refresh time
                            consecutiveFailures = 0; // Reset failures on successful refresh
                            
                            // Verify the new token is not expired
                            try {
                                const newPayload = JSON.parse(atob(data.access_token.split('.')[1]));
                                const currentTime = Math.floor(Date.now() / 1000);
                                
                                if (newPayload.exp && newPayload.exp < currentTime) {
                                    console.log('New token is also expired, redirecting to login');
                                    if (!isRedirecting) {
                                        isRedirecting = true;
                                        window.location.href = '/ui';
                                    }
                                    return;
                                }
                            } catch (error) {
                                console.error('Error verifying new token:', error);
                                if (!isRedirecting) {
                                    isRedirecting = true;
                                    window.location.href = '/ui';
                                }
                                return;
                            }
                            
                            // Retry the original request with new token
                            options.headers['Authorization'] = `Bearer ${data.access_token}`;
                            return await fetch(url, options);
                        } else {
                            // Refresh failed, clear token and redirect to login
                            console.log('Token refresh failed, clearing token and redirecting to login');
                            clearInvalidToken();
                            return;
                        }
                    } finally {
                        isRefreshingToken = false;
                    }
                }
                
                return response;
            } catch (error) {
                consecutiveFailures++;
                console.error('API call error:', error);
                console.log('[TOKEN DEBUG] API call failed, consecutive failures:', consecutiveFailures);
                
                // Check for infinite loop
                if (checkForInfiniteLoop()) {
                    return;
                }
                
                throw error;
            }
        }

        function logout() {
            localStorage.removeItem('auth_token');
            window.location.href = '/ui';
        }

        function generateLast30DaysData() {
            const dates = [];
            for (let i = 29; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                dates.push(`Day ${30 - i}`);
            }
            return dates;
        }

        function createMergedTrendsChart(metrics) {
            console.log('[DEBUG] === STARTING createMergedTrendsChart ===');
            console.log('[DEBUG] Metrics for chart:', JSON.stringify(metrics, null, 2));
            
            const rootStyles = getComputedStyle(document.documentElement);
            const primaryColor = rootStyles.getPropertyValue('--color-primary').trim();
            const secondaryColor = '#6366F1'; // Indigo for impressions
            const timeSeries = metrics.time_series || {};
            const dates = timeSeries.dates || [];
            const clicksData = timeSeries.clicks || [];
            const impressionsData = timeSeries.impressions || [];

            console.log('[DEBUG] Chart data extracted:');
            console.log('- dates:', dates);
            console.log('- clicksData:', clicksData);
            console.log('- impressionsData:', impressionsData);
            console.log('- primaryColor:', primaryColor);
            console.log('- secondaryColor:', secondaryColor);

            // Generate complete month dates including future dates with zero values
            let completeDates = [];
            let completeClicksData = [];
            let completeImpressionsData = [];

            if (dates.length > 0) {
                // Get the first date to determine the month and year
                const firstDate = new Date(dates[0]);
                const year = firstDate.getFullYear();
                const month = firstDate.getMonth();
                
                // Get the number of days in this month
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                
                // Create a map of existing data for quick lookup
                const dataMap = {};
                dates.forEach((dateStr, index) => {
                    dataMap[dateStr] = {
                        clicks: clicksData[index] || 0,
                        impressions: impressionsData[index] || 0
                    };
                });
                
                // Generate all dates for the month
                for (let day = 1; day <= daysInMonth; day++) {
                    const currentDate = new Date(year, month, day);
                    const dateStr = currentDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                    const today = new Date();
                    today.setHours(0, 0, 0, 0); // Reset time for accurate comparison
                    
                    completeDates.push(dateStr);
                    
                    if (dataMap[dateStr]) {
                        // Use real data if available
                        completeClicksData.push(dataMap[dateStr].clicks);
                        completeImpressionsData.push(dataMap[dateStr].impressions);
                    } else if (currentDate > today) {
                        // Future dates get zero values
                        completeClicksData.push(0);
                        completeImpressionsData.push(0);
                    } else {
                        // Past dates without data also get zero
                        completeClicksData.push(0);
                        completeImpressionsData.push(0);
                    }
                }
            }

            // Use complete data if available, otherwise fall back to original data
            const finalDates = completeDates.length > 0 ? completeDates : dates;
            const finalClicksData = completeClicksData.length > 0 ? completeClicksData : clicksData;
            const finalImpressionsData = completeImpressionsData.length > 0 ? completeImpressionsData : impressionsData;

            // Format dates to readable format like "1 Jun 2025"
            const formattedDates = finalDates.map(dateStr => {
                const date = new Date(dateStr);
                const day = date.getDate();
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[date.getMonth()];
                const year = date.getFullYear();
                return `${day} ${month} ${year}`;
            });

            if (window.mergedTrendsChart && typeof window.mergedTrendsChart.destroy === 'function') {
                window.mergedTrendsChart.destroy();
            }

            const ctx = document.getElementById('mergedTrendsChart').getContext('2d');
            window.mergedTrendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: formattedDates,
                    datasets: [
                        {
                            label: 'Clicks',
                            data: finalClicksData,
                            borderColor: primaryColor,
                            backgroundColor: 'rgba(249, 115, 22, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4
                        },
                        {
                            label: 'Impressions',
                            data: finalImpressionsData,
                            borderColor: secondaryColor,
                            backgroundColor: 'rgba(99, 102, 241, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4
                        }
                    ]
                },
                options: {
                responsive: true,
                maintainAspectRatio: false,
                    plugins: { legend: { display: true } },
                scales: {
                    y: { beginAtZero: true, grid: { color: 'rgba(0, 0, 0, 0.05)' } },
                    x: { grid: { display: false }, ticks: {
                        callback: function(value, index, values) {
                            const label = this.getLabelForValue(value);
                            // Show first, middle, and last dates for better readability
                            if (label === formattedDates[0] || label === formattedDates[Math.floor(formattedDates.length/2)] || label === formattedDates[formattedDates.length-1]) {
                                return label;
                            }
                            return null;
                        }
                    } }
                    }
                }
            });
        }

        function updateDashboardMetrics(hasGSC = false) {
            if (hasGSC) {
                // Update overall score
                document.getElementById('seoScore').textContent = '65';
                document.getElementById('seoScoreChange').textContent = '+5%';
                document.getElementById('seoScoreChange').className = 'score-change positive';

                // Update visibility performance
                document.getElementById('impressionsValue').textContent = '21,450';
                document.getElementById('clicksValue').textContent = '1,234';
                document.getElementById('ctrValue').textContent = '5.8%';
                document.getElementById('ctrChange').textContent = '+0.8%';
                document.getElementById('ctrChange').className = 'metric-change positive';
                document.getElementById('avgPositionValue').textContent = '2.2';
                document.getElementById('avgPositionChange').textContent = '+0.5';
                document.getElementById('avgPositionChange').className = 'metric-change positive';
                document.getElementById('visibilityInsights').innerHTML = '<p>Good visibility with room for CTR improvement. High-opportunity keywords need optimization.</p>';

                // Update engagement & UX
                document.getElementById('performanceScore').textContent = '78';
                document.getElementById('lcpValue').textContent = '2.1s';
                document.getElementById('fcpValue').textContent = '1.2s';
                document.getElementById('clsValue').textContent = '0.08';
                document.getElementById('uxInsights').innerHTML = '<p>Performance is good but LCP could be improved. Consider optimizing images and reducing server response time.</p>';

                // Update mobile usability
                document.getElementById('mobileFriendly').textContent = 'Pass';
                document.getElementById('mobileIssues').textContent = '0';
                document.getElementById('mobileInsights').innerHTML = '<p>Mobile-friendly with no issues detected. Good user experience across devices.</p>';

                // Update indexing & crawlability
                document.getElementById('sitemapStatus').textContent = 'Active';
                document.getElementById('sitemapCount').textContent = '2';
                document.getElementById('indexedPages').textContent = '127';
                document.getElementById('indexStatus').textContent = 'Good';
                document.getElementById('crawlErrors').textContent = '0';
                document.getElementById('crawlSuccessRate').textContent = '95%';
                document.getElementById('lastCrawl').textContent = '2024-01-15';
                document.getElementById('indexingInsights').innerHTML = '<p>Sitemap is properly configured and indexed. No crawl issues detected.</p>';

                // Update business context
                document.getElementById('businessType').textContent = 'SaaS';
                document.getElementById('targetMarket').textContent = 'B2B';
                document.getElementById('industrySector').textContent = 'Technology';
                document.getElementById('companySize').textContent = 'Startup';
                document.getElementById('primaryAgeGroup').textContent = '25-44';
                document.getElementById('incomeLevel').textContent = 'Premium';
                document.getElementById('audienceSophistication').textContent = 'Expert';
                document.getElementById('geographicFocus').textContent = 'Global';
                document.getElementById('businessMaturity').textContent = 'Growth';
                document.getElementById('technologyPlatform').textContent = 'Advanced';
                document.getElementById('contentStrategy').textContent = 'Comprehensive';
                document.getElementById('competitivePosition').textContent = 'Leader';
                document.getElementById('businessInsights').innerHTML = '<p>B2B SaaS business with technical audience. Focus on educational content and case studies.</p>';

                // Update keyword trends
                document.getElementById('totalKeywords').textContent = '1,247';
                document.getElementById('keywordAvgPosition').textContent = '3.2';
                document.getElementById('keywordOpportunities').textContent = '23';
                document.getElementById('brandedKeywords').textContent = '156';
                document.getElementById('keywordInsights').innerHTML = '<p>Strong keyword portfolio with 23 high-opportunity terms. Branded keywords performing well.</p>';

            } else {
                // Reset all metrics to empty state
                document.getElementById('seoScore').textContent = '0';
                document.getElementById('seoScoreChange').textContent = '+0%';
                
                // Reset visibility performance
                document.getElementById('impressionsValue').textContent = '0';
                document.getElementById('clicksValue').textContent = '0';
                document.getElementById('ctrValue').textContent = '0%';
                document.getElementById('ctrChange').textContent = '+0%';
                document.getElementById('avgPositionValue').textContent = 'N/A';
                document.getElementById('avgPositionChange').textContent = '+0.0';
                document.getElementById('visibilityInsights').innerHTML = '<p>Connect Google Search Console to see visibility insights</p>';

                // Reset engagement & UX
                document.getElementById('performanceScore').textContent = 'N/A';
                document.getElementById('lcpValue').textContent = 'N/A';
                document.getElementById('fcpValue').textContent = 'N/A';
                document.getElementById('clsValue').textContent = 'N/A';
                document.getElementById('uxInsights').innerHTML = '<p>Performance data will appear when connected</p>';

                // Reset mobile usability
                document.getElementById('mobileFriendly').textContent = 'N/A';
                document.getElementById('mobileIssues').textContent = '0';
                document.getElementById('mobileInsights').innerHTML = '<p>Mobile test results will appear here</p>';

                // Reset indexing & crawlability
                document.getElementById('sitemapStatus').textContent = 'N/A';
                document.getElementById('sitemapCount').textContent = 'N/A';
                document.getElementById('indexedPages').textContent = 'N/A';
                document.getElementById('indexStatus').textContent = 'N/A';
                document.getElementById('crawlErrors').textContent = 'N/A';
                document.getElementById('crawlSuccessRate').textContent = 'N/A';
                document.getElementById('lastCrawl').textContent = 'N/A';
                document.getElementById('indexingInsights').innerHTML = '<p>Indexing health will be analyzed</p>';

                // Reset business context
                document.getElementById('businessType').textContent = 'N/A';
                document.getElementById('targetMarket').textContent = 'N/A';
                document.getElementById('industrySector').textContent = 'N/A';
                document.getElementById('companySize').textContent = 'N/A';
                document.getElementById('primaryAgeGroup').textContent = 'N/A';
                document.getElementById('incomeLevel').textContent = 'N/A';
                document.getElementById('audienceSophistication').textContent = 'N/A';
                document.getElementById('geographicFocus').textContent = 'N/A';
                document.getElementById('businessMaturity').textContent = 'N/A';
                document.getElementById('technologyPlatform').textContent = 'N/A';
                document.getElementById('contentStrategy').textContent = 'N/A';
                document.getElementById('competitivePosition').textContent = 'N/A';
                document.getElementById('businessInsights').innerHTML = '<p>Business analysis will provide context</p>';

                // Reset keyword trends
                document.getElementById('totalKeywords').textContent = '0';
                document.getElementById('keywordAvgPosition').textContent = 'N/A';
                document.getElementById('keywordOpportunities').textContent = '0';
                document.getElementById('brandedKeywords').textContent = '0';
                document.getElementById('keywordInsights').innerHTML = '<p>Loading keyword performance insights...</p>';
            }
        }

        function showErrorMessage(message) {
            // Create or update error banner
            let errorBanner = document.getElementById('errorBanner');
            if (!errorBanner) {
                errorBanner = document.createElement('div');
                errorBanner.id = 'errorBanner';
                errorBanner.className = 'error-banner';
                errorBanner.innerHTML = `
                    <div class="banner-content">
                        <div class="banner-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="15" y1="9" x2="9" y2="15"></line>
                                <line x1="9" y1="9" x2="15" y2="15"></line>
                            </svg>
                        </div>
                        <div class="banner-text">
                            <h3>Data Loading Error</h3>
                            <p id="errorMessage">${message}</p>
                        </div>
                        <div class="banner-actions">
                            <button onclick="hideErrorMessage()" class="btn-dismiss">Dismiss</button>
                            <button onclick="location.reload()" class="btn-retry">Retry</button>
                        </div>
                    </div>
                `;
                
                // Insert after GSC banner
                const gscBanner = document.getElementById('gscBanner');
                if (gscBanner && gscBanner.nextSibling) {
                    gscBanner.parentNode.insertBefore(errorBanner, gscBanner.nextSibling);
                } else {
                    document.querySelector('.dashboard-container').insertBefore(errorBanner, document.querySelector('.dashboard-header'));
                }
            } else {
                document.getElementById('errorMessage').textContent = message;
            }
            
            errorBanner.classList.remove('hidden');
        }

        function hideErrorMessage() {
            const errorBanner = document.getElementById('errorBanner');
            if (errorBanner) {
                errorBanner.classList.add('hidden');
            }
        }

        function updateDashboardMetricsWithRealData(metrics) {
            console.log('[DEBUG] === STARTING updateDashboardMetricsWithRealData ===');
            console.log('[DEBUG] Full metrics object received:', JSON.stringify(metrics, null, 2));
            
            // Validate input data
            if (!metrics) {
                console.error('[ERROR] No metrics data provided to updateDashboardMetricsWithRealData');
                return;
            }
            
            const summary = metrics.summary || {};
            console.log('[DEBUG] Extracted summary data:', JSON.stringify(summary, null, 2));
            
            // Validate summary data structure
            if (Object.keys(summary).length === 0) {
                console.warn('[WARNING] Empty summary data received');
            }
            
            // Store summary data globally
            window.metricsData = window.metricsData || {};
            window.metricsData.summary = summary;
            console.log('[DEBUG] Stored in window.metricsData.summary:', window.metricsData.summary);
            
            // Extract individual values with detailed logging
            const impressionsValue = summary.total_impressions;
            const clicksValue = summary.total_clicks;
            const ctrValue = summary.avg_ctr;
            const positionValue = summary.avg_position;
            
            console.log('[DEBUG] Extracted values:');
            console.log('- impressionsValue:', impressionsValue, typeof impressionsValue);
            console.log('- clicksValue:', clicksValue, typeof clicksValue);
            console.log('- ctrValue:', ctrValue, typeof ctrValue);
            console.log('- positionValue:', positionValue, typeof positionValue);
            
            // Calculate SEO score based on real metrics with fallback
            let seoScore = 0;
            try {
                seoScore = calculateSEOScore(summary);
                console.log('[DEBUG] Calculated SEO Score:', seoScore);
                if (isNaN(seoScore) || seoScore < 0 || seoScore > 100) {
                    console.warn('[WARNING] Invalid SEO score calculated:', seoScore, 'using fallback');
                    seoScore = 0;
                }
            } catch (error) {
                console.error('[ERROR] Failed to calculate SEO score:', error);
                seoScore = 0;
            }
            
            // Calculate SEO score change using backend-provided 30-day comparison
            const seoScoreChange = summary.seo_score_change !== undefined ? summary.seo_score_change : 0;
            console.log(`[DEBUG] SEO Score: Current=${seoScore}, 30-day change=${seoScoreChange}`);
            
            // Update overall score with validation
            console.log('[DEBUG] Updating seoScore element...');
            const seoScoreElement = document.getElementById('seoScore');
            if (seoScoreElement) {
                console.log('[DEBUG] Found seoScore element, setting to:', seoScore);
                seoScoreElement.textContent = seoScore;
                console.log('[DEBUG] seoScore element updated, current text:', seoScoreElement.textContent);
            } else {
                console.error('[ERROR] seoScore element not found');
            }
            updateSEOScoreChange(seoScoreChange);

            // Safely update DOM elements with extensive logging
            console.log('[DEBUG] Preparing to update visibility metrics...');
            const elements = {
                'impressionsValue': (impressionsValue || 0).toLocaleString(),
                'clicksValue': (clicksValue || 0).toLocaleString(),
                'ctrValue': `${((ctrValue || 0) * 100).toFixed(2)}%`,
                'avgPositionValue': positionValue > 0 ? positionValue.toFixed(1) : 'N/A'
            };
            
            console.log('[DEBUG] Element values to set:', elements);
            
            Object.entries(elements).forEach(([id, value]) => {
                console.log(`[DEBUG] Updating element ${id} with value:`, value);
                const element = document.getElementById(id);
                if (element) {
                    console.log(`[DEBUG] Found element ${id}, current text:`, element.textContent);
                    element.textContent = value;
                    console.log(`[DEBUG] Updated element ${id}, new text:`, element.textContent);
                } else {
                    console.error(`[ERROR] Element not found: ${id}`);
                }
            });
            
            // Also check if the elements are visible
            console.log('[DEBUG] Checking element visibility...');
            Object.keys(elements).forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    const style = window.getComputedStyle(element);
                    console.log(`[DEBUG] Element ${id} visibility - display: ${style.display}, visibility: ${style.visibility}, opacity: ${style.opacity}`);
                }
            });
            
            // Update change indicators - all use backend-provided 30-day comparisons
            console.log(`[DEBUG] === UPDATING CHANGE INDICATORS ===`);
            const impressionsChange = summary.impressions_change !== undefined ? summary.impressions_change : 0;
            const clicksChange = summary.clicks_change !== undefined ? summary.clicks_change : 0;
            const ctrChange = summary.ctr_change !== undefined ? summary.ctr_change : 0;
            const positionChange = summary.position_change !== undefined ? summary.position_change : 0;
            
            console.log(`[DEBUG] Change values:`);
            console.log(`- Impressions: Current=${impressionsValue}, 30-day change=${impressionsChange}`);
            console.log(`- Clicks: Current=${clicksValue}, 30-day change=${clicksChange}`);
            console.log(`- CTR: Current=${ctrValue}, 30-day change=${ctrChange}`);
            console.log(`- Position: Current=${positionValue}, 30-day change=${positionChange}`);
            
            updateChangeIndicator('impressionsChange', impressionsChange, '', true);
            updateChangeIndicator('clicksChange', clicksChange, '', true);
            updateChangeIndicator('ctrChange', ctrChange, '%', true);
            updateChangeIndicator('avgPositionChange', positionChange, '', false);
            
            // Generate insights based on real data
            try {
                console.log('[DEBUG] Generating insights...');
            generateVisibilityInsights(summary);
            generateUXInsights(metrics);
            generateMobileInsights(metrics);
            generateIndexingInsights(metrics);
            generateBusinessInsights(metrics);
            generateKeywordInsights(metrics);
            } catch (error) {
                console.error('[ERROR] Failed to generate insights:', error);
            }
            
            console.log('[DEBUG] === COMPLETED updateDashboardMetricsWithRealData ===');
        }

        // 30-day comparison is now handled by the backend
        // All growth indicators compare today's data vs exactly 30 days ago
        console.log(`[GROWTH DEBUG] Using backend-provided 30-day comparisons`);

        function calculateChange(metricKey, currentValue) {
            // This function is now only used as a fallback when backend doesn't provide comparison data
            console.log(`[GROWTH DEBUG] ${metricKey}: Using fallback calculation (backend comparison not available)`);
            return 0; // Default to no change when backend comparison is unavailable
        }

        function updateChangeIndicator(elementId, value, unit = '', higherIsBetter = true) {
            const element = document.getElementById(elementId);
            if (value === undefined || value === null) {
                console.log(`[GROWTH DEBUG] ${elementId}: Updating indicator with N/A value`);
                element.textContent = 'N/A';
                element.className = 'metric-change neutral';
                element.style.color = '#6B7280'; // Grey for N/A
                return;
            }

            // Handle loading state
            if (value === 'loading' || value === '...') {
                console.log(`[GROWTH DEBUG] ${elementId}: Updating indicator with loading state`);
                element.textContent = '...';
                element.className = 'metric-change neutral';
                element.style.color = '#6B7280'; // Grey for loading
                return;
            }

            // Handle categorical changes (business type, target market)
            if (elementId.includes('businessType') || elementId.includes('targetMarket')) {
                let class_name = 'metric-change';
                let displayText = '';
                if (value === 0) {
                    class_name += ' neutral';
                    displayText = 'No Change';
                    element.style.color = '#6B7280'; // Grey for no change
                } else {
                    class_name += ' positive'; // Show changes as positive (informational)
                    displayText = 'Updated';
                    element.style.color = ''; // Reset to CSS default
                }
                console.log(`[GROWTH DEBUG] ${elementId}: Categorical indicator - Value: ${value}, Display: "${displayText}", Class: "${class_name}"`);
                element.className = class_name;
                element.textContent = displayText;
                return;
            }

            const isPositive = higherIsBetter ? value > 0 : value < 0;
            const isNegative = higherIsBetter ? value < 0 : value > 0;
            const isZero = value === 0 || Math.abs(value) < 0.001; // Consider very small values as zero
            
            let class_name = 'metric-change';
            if (isZero) {
                class_name += ' neutral';
                element.style.color = '#6B7280'; // Grey for zero/no change
            } else if (isPositive) {
                class_name += ' positive';
                element.style.color = ''; // Reset to CSS default
            } else if (isNegative) {
                class_name += ' negative';
                element.style.color = ''; // Reset to CSS default
            }

            element.className = class_name;
            
            // Format the display value
            let displayText;
            if (isZero) {
                displayText = unit === '%' ? '0%' : '0';
            } else {
                const prefix = value > 0 ? '+' : '';
            const formattedValue = unit === '%' ? (value * 100).toFixed(2) : value.toFixed(1);
                displayText = `${prefix}${formattedValue}${unit}`;
            }
            
            console.log(`[GROWTH DEBUG] ${elementId}: Numeric indicator - Value: ${value}, Unit: "${unit}", Higher is Better: ${higherIsBetter}, Display: "${displayText}", Class: "${class_name}"`);
            element.textContent = displayText;
        }

        function updateSEOScoreChange(change) {
            const element = document.getElementById('seoScoreChange');
            if (change === undefined || change === null) {
                element.textContent = 'N/A';
                element.className = 'score-change';
                return;
            }

            const isPositive = change > 0;
            const isNegative = change < 0;
            const isZero = change === 0 || Math.abs(change) < 0.001; // Consider very small values as zero
            
            let class_name = 'score-change';
            if (isZero) {
                class_name += ' neutral';
                element.style.color = '#6B7280'; // Grey for no change
            } else if (isPositive) {
                class_name += ' positive';
                element.style.color = ''; // Reset to CSS default (green)
            } else if (isNegative) {
                class_name += ' negative';
                element.style.color = ''; // Reset to CSS default (red)
            }

            element.className = class_name;
            
            // Format the display value
            let displayText;
            if (isZero) {
                displayText = '0';
            } else {
                const prefix = change > 0 ? '+' : '';
                displayText = `${prefix}${change}`;
            }
            element.textContent = displayText;
        }

        function generateVisibilityInsights(summary) {
            let insight = '';
            if (summary.total_impressions > 0) {
                if (summary.avg_ctr < 2) {
                    insight = 'CTR is below average. Consider optimizing meta titles and descriptions for better click-through rates.';
                } else if (summary.avg_position > 10) {
                    insight = 'Average position needs improvement. Focus on content optimization and backlink building.';
                } else {
                    insight = 'Good visibility performance. Continue optimizing for high-opportunity keywords.';
                }
            } else {
                insight = 'No search visibility data yet. This is normal for new websites.';
            }
            document.getElementById('visibilityInsights').innerHTML = `<p>${insight}</p>`;
        }

        function generateUXInsights(metrics) {
            // UX insights are now generated when fetchPageSpeedData() is called from loadRealMetrics()
            document.getElementById('uxInsights').innerHTML = '<p>Loading performance insights...</p>';
        }

        async function fetchPageSpeedData() {
            setMetricLoadingState('ux', 'loading');
            try {
                console.log('[DEBUG] Fetching PageSpeed data...');
                const response = await apiCall('/auth/pagespeed/metrics');
                console.log('[DEBUG] PageSpeed response status:', response.status);
                
                if (response.ok) {
                    const psiData = await response.json();
                    console.log('[DEBUG] PageSpeed data received:', psiData);
                    updateUXMetrics(psiData);
                    setMetricLoadingState('ux', 'done');
                } else {
                    setMetricLoadingState('ux', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load PageSpeed data:', errorText);
                    // Provide fallback data for UX metrics
                    const fallbackData = {
                        performance_score: 0,
                        lcp: { value: 0 },
                        fcp: { value: 0 },
                        cls: { value: 0 },
                        insights: ['PageSpeed data will be available once configured.']
                    };
                    updateUXMetrics(fallbackData);
                }
            } catch (error) {
                setMetricLoadingState('ux', 'done');
                console.error('Error loading PageSpeed data:', error);
                // Provide fallback data for UX metrics
                const fallbackData = {
                    performance_score: 0,
                    lcp: { value: 0 },
                    fcp: { value: 0 },
                    cls: { value: 0 },
                    insights: ['PageSpeed data is currently unavailable. Please check your connection and try refreshing.']
                };
                updateUXMetrics(fallbackData);
            }
        }

        function updateUXMetrics(psiData) {
            console.log('[DEBUG] Updating UX metrics with data:', psiData);
            
            // Store UX data globally
            window.metricsData.ux = {
                performance_score: psiData.performance_score,
                lcp: psiData.lcp?.value,
                fcp: psiData.fcp?.value,
                cls: psiData.cls?.value,
                insights: psiData.insights || [],
                recommendations: psiData.recommendations || []
            };
            
            console.log(`[GROWTH DEBUG] === ENGAGEMENT & UX METRICS ===`);
            // Update performance score with 30-day comparison
            const performanceScore = psiData.performance_score;
            console.log('[DEBUG] Performance score:', performanceScore);
            document.getElementById('performanceScore').textContent = (performanceScore !== undefined && performanceScore !== null) ? performanceScore : 'N/A';
            const performanceScoreChange = psiData.performance_score_change !== undefined ? psiData.performance_score_change : calculateChange('performance_score', performanceScore);
            console.log(`[GROWTH DEBUG] Performance Score: Current=${performanceScore}, 30-day change=${performanceScoreChange}`);
            updateChangeIndicator('performanceScoreChange', performanceScoreChange, '', true);
            
            // Update LCP with 30-day comparison
            const lcpValue = psiData.lcp?.value;
            console.log('[DEBUG] LCP value:', lcpValue);
            document.getElementById('lcpValue').textContent = (lcpValue !== undefined && lcpValue !== null) ? `${lcpValue.toFixed(1)}s` : 'N/A';
            const lcpChange = psiData.lcp_change !== undefined ? psiData.lcp_change : calculateChange('lcp_value', lcpValue);
            console.log(`[GROWTH DEBUG] LCP: Current=${lcpValue}s, 30-day change=${lcpChange}s`);
            updateChangeIndicator('lcpChange', lcpChange, 's', false);
            
            // Update FCP with 30-day comparison
            const fcpValue = psiData.fcp?.value;
            console.log('[DEBUG] FCP value:', fcpValue);
            document.getElementById('fcpValue').textContent = (fcpValue !== undefined && fcpValue !== null) ? `${fcpValue.toFixed(1)}s` : 'N/A';
            const fcpChange = psiData.fcp_change !== undefined ? psiData.fcp_change : calculateChange('fcp_value', fcpValue);
            console.log(`[GROWTH DEBUG] FCP: Current=${fcpValue}s, 30-day change=${fcpChange}s`);
            updateChangeIndicator('fcpChange', fcpChange, 's', false);
            
            // Update CLS with 30-day comparison
            const clsValue = psiData.cls?.value;
            console.log('[DEBUG] CLS value:', clsValue);
            document.getElementById('clsValue').textContent = (clsValue !== undefined && clsValue !== null) ? clsValue.toFixed(3) : 'N/A';
            const clsChange = psiData.cls_change !== undefined ? psiData.cls_change : calculateChange('cls_value', clsValue);
            console.log(`[GROWTH DEBUG] CLS: Current=${clsValue}, 30-day change=${clsChange}`);
            updateChangeIndicator('clsChange', clsChange, '', false);
            
            // Update status indicator
            const statusIndicator = document.getElementById('uxStatus');
            if (performanceScore >= 90) {
                statusIndicator.textContent = 'Excellent';
                statusIndicator.className = 'status-indicator good';
            } else if (performanceScore >= 70) {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (performanceScore >= 50) {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else {
                statusIndicator.textContent = 'Poor';
                statusIndicator.className = 'status-indicator error';
            }
            
            // Recalculate overall SEO score
            recalculateOverallSEOScore();
        }

        function generateUXInsightsFromData(psiData) {
            let insight = '';
            const performanceScore = psiData.performance_score;
            const lcp = psiData.lcp?.value;
            const fcp = psiData.fcp?.value;
            const cls = psiData.cls?.value;
            
            if (performanceScore >= 90) {
                insight = 'Excellent performance! Your site loads quickly and provides a great user experience.';
            } else if (performanceScore >= 70) {
                insight = 'Good performance with room for improvement. Consider optimizing images and reducing server response time.';
            } else if (performanceScore >= 50) {
                insight = 'Performance needs improvement. Focus on Core Web Vitals optimization for better user experience.';
            } else {
                insight = 'Performance requires immediate attention. Prioritize speed optimizations to improve user experience and SEO.';
            }
            
            // Add specific recommendations based on Core Web Vitals
            if (lcp && lcp > 2.5) {
                insight += ' LCP is slow - optimize images and reduce server response time.';
            }
            if (fcp && fcp > 1.8) {
                insight += ' FCP needs improvement - optimize critical rendering path.';
            }
            if (cls && cls > 0.1) {
                insight += ' CLS issues detected - prevent layout shifts during page load.';
            }
            
            document.getElementById('uxInsights').innerHTML = `<p>${insight}</p>`;
        }

        function generateMobileInsights(metrics) {
            // Mobile insights are now generated when fetchMobileData() is called from loadRealMetrics()
            document.getElementById('mobileInsights').innerHTML = '<p>Loading mobile usability insights...</p>';
        }

        async function fetchMobileData() {
            setMetricLoadingState('mobile', 'loading');
            try {
                console.log('[DEBUG] Fetching mobile data...');
                const response = await apiCall('/auth/mobile/metrics');
                console.log('[DEBUG] Mobile response status:', response.status);
                
                if (response.ok) {
                    const mobileData = await response.json();
                    console.log('[DEBUG] Mobile data received:', mobileData);
                    updateMobileMetrics(mobileData);
                    generateMobileInsightsFromData(mobileData);
                    setMetricLoadingState('mobile', 'done');
                } else {
                    setMetricLoadingState('mobile', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load mobile data:', errorText);
                    // Provide fallback data for mobile metrics
                    const fallbackData = {
                        mobile_friendly: 'Unknown',
                        issues_count: 0,
                        performance_score: 0,
                        insights: 'Mobile data will be available once GSC is connected and configured.'
                    };
                    updateMobileMetrics(fallbackData);
                    generateMobileInsightsFromData(fallbackData);
                }
            } catch (error) {
                setMetricLoadingState('mobile', 'done');
                console.error('Error loading mobile data:', error);
                // Provide fallback data for mobile metrics
                const fallbackData = {
                    mobile_friendly: 'Not Available',
                    issues_count: 0,
                    performance_score: 0,
                    insights: 'Mobile data is currently unavailable. Please check your connection and try refreshing.'
                };
                updateMobileMetrics(fallbackData);
                generateMobileInsightsFromData(fallbackData);
            }
        }

        function updateMobileMetrics(mobileData) {
            console.log('[DEBUG] Updating mobile metrics with data:', mobileData);
            
            // Store mobile data globally
            window.metricsData.mobile = {
                mobile_friendly: mobileData.mobile_friendly,
                issues_count: mobileData.issues_count || 0,
                performance_score: mobileData.performance_score,
                critical_issues: mobileData.critical_issues || 0,
                warning_issues: mobileData.warning_issues || 0
            };
            
            // Update mobile friendly status
            const mobileFriendly = mobileData.mobile_friendly;
            document.getElementById('mobileFriendly').textContent = mobileFriendly || 'N/A';
            
            // Update status indicator color
            const statusIndicator = document.getElementById('mobileStatus');
            if (mobileFriendly === 'Pass' || mobileFriendly === 'Yes') {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (mobileFriendly === 'Fail' || mobileFriendly === 'No') {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else {
                statusIndicator.textContent = 'Unknown';
                statusIndicator.className = 'status-indicator';
            }
            
            // Update issues count
            const issuesCount = mobileData.issues_count || 0;
            document.getElementById('mobileIssues').textContent = issuesCount;
            console.log(`[GROWTH DEBUG] === MOBILE USABILITY METRICS ===`);
            console.log(`[GROWTH DEBUG] Mobile Issues: Current=${issuesCount}, Critical=${mobileData.critical_issues}, Warning=${mobileData.warning_issues}`);
            const mobileIssuesChange = calculateChange('mobile_issues_count', issuesCount);
            updateChangeIndicator('mobileIssuesChange', mobileIssuesChange, '', false);
            
            // Recalculate overall SEO score
            recalculateOverallSEOScore();
        }

        function generateMobileInsightsFromData(mobileData) {
            const issues = mobileData.issues || [];
            let html = '';

            if (issues.length > 0) {
                // Display each issue in its own div container
                issues.forEach(issue => {
                    // Handle both old string format and new detailed object format
                    if (typeof issue === 'string') {
                        html += `<div class="mobile-issue-box"><p>${issue}</p></div>`;
                    } else if (typeof issue === 'object' && issue.title) {
                        // New detailed format - merge description and impact, hide solution
                        html += `
                            <div class="mobile-issue-box">
                                <h4>${issue.title}</h4>
                                <p>${issue.description} ${issue.impact}</p>
                            </div>
                        `;
                    }
                });
            } else {
                // Show the positive insight if no issues
                html += `<p>${mobileData.insights || 'No mobile usability issues detected.'}</p>`;
            }

            document.getElementById('mobileInsights').innerHTML = html;
        }

        function generateIndexingInsights(metrics) {
            // Indexing insights are now generated when fetchIndexingData() is called from loadRealMetrics()
            document.getElementById('indexingInsights').innerHTML = '<p>Loading indexing insights...</p>';
        }

        async function fetchIndexingData() {
            console.log('[DEBUG] ========== FETCHING INDEXING DATA ==========');
            setMetricLoadingState('indexing', 'loading');
            try {
                console.log('[DEBUG] Making API call to /auth/indexing/metrics...');
                const response = await apiCall('/auth/indexing/metrics');
                console.log('[DEBUG] Indexing response status:', response.status);
                console.log('[DEBUG] Indexing response object:', response);
                
                if (response.ok) {
                    const indexingData = await response.json();
                    console.log('[DEBUG] ========== INDEXING DATA RECEIVED ==========');
                    console.log('[DEBUG] Raw indexing data:', JSON.stringify(indexingData, null, 2));
                    console.log('[DEBUG] Calling updateIndexingMetrics...');
                    updateIndexingMetrics(indexingData);
                    console.log('[DEBUG] Calling generateIndexingInsightsFromData...');
                    generateIndexingInsightsFromData(indexingData);
                    setMetricLoadingState('indexing', 'done');
                    console.log('[DEBUG] ========== INDEXING DATA PROCESSING COMPLETED ==========');
                } else {
                    setMetricLoadingState('indexing', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load indexing data:', errorText);
                    // Provide fallback data for indexing metrics
                    const fallbackData = {
                        sitemap_status: 'Unknown',
                        sitemap_count: 0,
                        indexed_pages: 0,
                        index_status: 'Not Available',
                        crawl_errors: 0,
                        crawl_success_rate: 0,
                        last_crawl: null,
                        insights: 'Indexing data will be available when GSC is connected.'
                    };
                    updateIndexingMetrics(fallbackData);
                    generateIndexingInsightsFromData(fallbackData);
                }
            } catch (error) {
                setMetricLoadingState('indexing', 'done');
                console.error('[ERROR] Exception in fetchIndexingData:', error);
                // Provide fallback data for indexing metrics
                const fallbackData = {
                    sitemap_status: 'Not Available',
                    sitemap_count: 0,
                    indexed_pages: 0,
                    index_status: 'Not Available',
                    crawl_errors: 0,
                    crawl_success_rate: 0,
                    last_crawl: null,
                    insights: 'Indexing data is currently unavailable. Please check your connection and try refreshing.'
                };
                updateIndexingMetrics(fallbackData);
                generateIndexingInsightsFromData(fallbackData);
            }
        }

        function updateIndexingMetrics(indexingData) {
            console.log('[DEBUG] ========== UPDATING INDEXING METRICS ==========');
            console.log('[DEBUG] Received indexing data:', JSON.stringify(indexingData, null, 2));
            
            // Store indexing data globally
            window.metricsData.indexing = {
                sitemap_status: indexingData.sitemap_status,
                sitemap_count: indexingData.sitemap_count || 0,
                indexed_pages: indexingData.indexed_pages || 0,
                index_status: indexingData.index_status,
                crawl_errors: indexingData.crawl_errors || 0,
                crawl_success_rate: indexingData.crawl_success_rate || 0,
                last_crawl: indexingData.last_crawl
            };
            
            console.log(`[GROWTH DEBUG] === INDEXING & CRAWLABILITY METRICS ===`);
            
            // Update sitemap status and count
            const sitemapStatus = indexingData.sitemap_status;
            const sitemapCount = indexingData.sitemap_count || 0;
            console.log('[DEBUG] Setting sitemapStatus to:', sitemapStatus);
            console.log('[DEBUG] Setting sitemapCount to:', sitemapCount);
            document.getElementById('sitemapStatus').textContent = sitemapStatus || 'N/A';
            document.getElementById('sitemapCount').textContent = sitemapCount.toString();
            
            // Update indexed pages with change indicator
            const indexedPages = indexingData.indexed_pages || 0;
            document.getElementById('indexedPages').textContent = indexedPages.toLocaleString();
            const indexedPagesChange = indexingData.indexed_pages_change !== undefined ? indexingData.indexed_pages_change : calculateChange('indexed_pages', indexedPages);
            console.log(`[GROWTH DEBUG] Indexed Pages: Current=${indexedPages}, 30-day change=${indexedPagesChange}`);
            updateChangeIndicator('indexedPagesChange', indexedPagesChange, '', true);
            
            // Update index status
            const indexStatus = indexingData.index_status;
            document.getElementById('indexStatus').textContent = indexStatus || 'N/A';
            
            // Update crawl metrics
            const crawlErrors = indexingData.crawl_errors || 0;
            const crawlSuccessRate = indexingData.crawl_success_rate || 0;
            const lastCrawl = indexingData.last_crawl;
            
            console.log('[DEBUG] Setting crawlErrors to:', crawlErrors);
            console.log('[DEBUG] Setting crawlSuccessRate to:', crawlSuccessRate);
            console.log('[DEBUG] Setting lastCrawl to:', lastCrawl);
            
            // Format the last crawl date
            let formattedLastCrawl = 'N/A';
            if (lastCrawl) {
                try {
                    const date = new Date(lastCrawl);
                    const day = date.getDate();
                    const month = date.toLocaleString('en', { month: 'short' });
                    const year = date.getFullYear();
                    formattedLastCrawl = `${day} ${month} ${year}`;
                } catch (error) {
                    console.warn('[DEBUG] Failed to format last crawl date:', lastCrawl, error);
                    formattedLastCrawl = lastCrawl; // Fallback to original format
                }
            }
            
            document.getElementById('crawlErrors').textContent = crawlErrors.toString();
            document.getElementById('crawlSuccessRate').textContent = crawlSuccessRate ? `${crawlSuccessRate}%` : 'N/A';
            document.getElementById('lastCrawl').textContent = formattedLastCrawl;
            
            // Update status indicator color
            const statusIndicator = document.getElementById('indexingStatus');
            if (sitemapStatus === 'Active' && crawlErrors === 0 && crawlSuccessRate >= 80) {
                statusIndicator.textContent = 'Excellent';
                statusIndicator.className = 'status-indicator good';
            } else if (sitemapStatus === 'Active' && crawlErrors <= 5 && crawlSuccessRate >= 60) {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (sitemapStatus === 'Pending' || crawlErrors > 5 || crawlSuccessRate < 60) {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else if (sitemapStatus === 'Error' || crawlErrors > 20 || crawlSuccessRate < 30) {
                statusIndicator.textContent = 'Poor';
                statusIndicator.className = 'status-indicator error';
            } else {
                statusIndicator.textContent = 'Unknown';
                statusIndicator.className = 'status-indicator';
            }
            
            // Recalculate overall SEO score
            recalculateOverallSEOScore();
        }

        function generateIndexingInsightsFromData(indexingData) {
            const insights = indexingData.insights || [];
            if (insights.length > 0) {
                const insightsHtml = insights.map(insight => `<p>${insight}</p>`).join('');
                document.getElementById('indexingInsights').innerHTML = insightsHtml;
            } else {
                document.getElementById('indexingInsights').innerHTML = '<p>Indexing health analysis completed. No major issues detected.</p>';
            }
        }

        function generateBusinessInsights(metrics) {
            // Business insights are now generated when fetchBusinessData() is called from loadRealMetrics()
            document.getElementById('businessInsights').innerHTML = '<p>Loading business context insights...</p>';
        }

        async function fetchBusinessData() {
            setMetricLoadingState('business', 'loading');
            try {
                console.log('[BUSINESS DEBUG] ========== FETCHING BUSINESS DATA ==========');
                console.log('[BUSINESS DEBUG] Starting business data fetch...');
                const response = await apiCall('/auth/business/metrics');
                console.log('[BUSINESS DEBUG] Business context response status:', response.status);
                console.log('[BUSINESS DEBUG] Business context response headers:', response.headers);
                
                if (response.ok) {
                    const businessData = await response.json();
                    console.log('[BUSINESS DEBUG] ✅ Business context data received successfully!');
                    console.log('[BUSINESS DEBUG] Raw business data:', JSON.stringify(businessData, null, 2));
                    console.log('[BUSINESS DEBUG] Business data keys:', Object.keys(businessData));
                    console.log('[BUSINESS DEBUG] Business type:', businessData.business_type);
                    console.log('[BUSINESS DEBUG] Target market:', businessData.target_market);
                    console.log('[BUSINESS DEBUG] Industry sector:', businessData.industry_sector);
                    
                    console.log('[BUSINESS DEBUG] Calling updateBusinessMetrics...');
                    updateBusinessMetrics(businessData);
                    console.log('[BUSINESS DEBUG] Calling generateBusinessInsightsFromData...');
                    generateBusinessInsightsFromData(businessData);
                    setMetricLoadingState('business', 'done');
                    console.log('[BUSINESS DEBUG] ✅ Business data processing completed successfully!');
                } else {
                    setMetricLoadingState('business', 'done');
                    const errorText = await response.text();
                    console.error('[BUSINESS DEBUG] ❌ Failed to load business context data:', response.status, errorText);
                    document.getElementById('businessInsights').innerHTML = '<p>Business context analysis will be available when connected to Google Search Console.</p>';
                }
            } catch (error) {
                setMetricLoadingState('business', 'done');
                console.error('[BUSINESS DEBUG] ❌ Exception in fetchBusinessData:', error);
                console.error('[BUSINESS DEBUG] Error stack:', error.stack);
                document.getElementById('businessInsights').innerHTML = '<p>Business context analysis will be available when connected to Google Search Console.</p>';
            }
        }

        function updateBusinessMetrics(businessData) {
            console.log('[BUSINESS DEBUG] ========== UPDATING BUSINESS METRICS ==========');
            console.log('[BUSINESS DEBUG] Input business data:', JSON.stringify(businessData, null, 2));
            
            // Store comprehensive business data globally
            window.metricsData.business = {
                business_type: businessData.business_type,
                target_market: businessData.target_market,
                industry_sector: businessData.industry_sector,
                company_size: businessData.company_size,
                primary_age_group: businessData.primary_age_group,
                income_level: businessData.income_level,
                audience_sophistication: businessData.audience_sophistication,
                geographic_focus: businessData.geographic_focus,
                business_maturity: businessData.business_maturity,
                technology_platform: businessData.technology_platform,
                content_strategy: businessData.content_strategy,
                competitive_position: businessData.competitive_position
            };
            
            console.log('[BUSINESS DEBUG] Stored global business data:', window.metricsData.business);
            
            // Update all business context fields
            const businessFields = {
                'businessType': businessData.business_type,
                'targetMarket': businessData.target_market,
                'industrySector': businessData.industry_sector,
                'companySize': businessData.company_size,
                'primaryAgeGroup': businessData.primary_age_group,
                'incomeLevel': businessData.income_level,
                'audienceSophistication': businessData.audience_sophistication,
                'geographicFocus': businessData.geographic_focus,
                'businessMaturity': businessData.business_maturity,
                'technologyPlatform': businessData.technology_platform,
                'contentStrategy': businessData.content_strategy,
                'competitivePosition': businessData.competitive_position
            };
            
            console.log('[BUSINESS DEBUG] Field mapping:', businessFields);
            
            // Update DOM elements for all business fields
            let successCount = 0;
            let failureCount = 0;
            
            Object.entries(businessFields).forEach(([elementId, value]) => {
                const element = document.getElementById(elementId);
                if (element) {
                    const displayValue = value || 'N/A';
                    const oldValue = element.textContent;
                    element.textContent = displayValue;
                    console.log(`[BUSINESS DEBUG] ✅ Updated ${elementId}: "${oldValue}" → "${displayValue}"`);
                    successCount++;
                } else {
                    console.error(`[BUSINESS DEBUG] ❌ Element not found: ${elementId}`);
                    failureCount++;
                }
            });
            
            console.log(`[BUSINESS DEBUG] DOM Updates: ${successCount} successful, ${failureCount} failed`);
            
            // List all business-related elements in the DOM
            const businessElements = [
                'businessType', 'targetMarket', 'industrySector', 'companySize', 
                'primaryAgeGroup', 'incomeLevel', 'audienceSophistication', 
                'geographicFocus', 'businessMaturity', 'technologyPlatform', 
                'contentStrategy', 'competitivePosition', 'businessStatus', 'businessInsights'
            ];
            
            console.log('[BUSINESS DEBUG] DOM Element Check:');
            businessElements.forEach(id => {
                const element = document.getElementById(id);
                console.log(`[BUSINESS DEBUG] ${id}: ${element ? '✅ exists' : '❌ missing'} ${element ? `(content: "${element.textContent}")` : ''}`);
            });
            
            // Update change indicators for key fields
            console.log(`[BUSINESS DEBUG] === UPDATING CHANGE INDICATORS ===`);
            const businessTypeChange = calculateChange('business_type', businessData.business_type);
            const targetMarketChange = calculateChange('target_market', businessData.target_market);
            updateChangeIndicator('businessTypeChange', businessTypeChange, '', true);
            updateChangeIndicator('targetMarketChange', targetMarketChange, '', true);
            
            // Update status indicator based on business sophistication
            const statusIndicator = document.getElementById('businessStatus');
            const sophistication = businessData.audience_sophistication?.toLowerCase();
            const maturity = businessData.business_maturity?.toLowerCase();
            
            console.log('[BUSINESS DEBUG] Status calculation - sophistication:', sophistication, 'maturity:', maturity);
            
            if (statusIndicator) {
                let statusText = 'Basic';
                let statusClass = 'status-indicator warning';
                
                if (sophistication === 'expert' && maturity !== 'startup') {
                    statusText = 'Advanced';
                    statusClass = 'status-indicator good';
                } else if (sophistication === 'intermediate' || maturity === 'growth') {
                    statusText = 'Good';
                    statusClass = 'status-indicator good';
                } else if (sophistication === 'beginner' || maturity === 'startup') {
                    statusText = 'Developing';
                    statusClass = 'status-indicator warning';
                }
                
                statusIndicator.textContent = statusText;
                statusIndicator.className = statusClass;
                console.log(`[BUSINESS DEBUG] ✅ Status updated to: ${statusText} (${statusClass})`);
            } else {
                console.error('[BUSINESS DEBUG] ❌ Status indicator element not found');
            }
            
            console.log('[BUSINESS DEBUG] ========== BUSINESS METRICS UPDATE COMPLETED ==========');
        }

        function generateBusinessInsightsFromData(businessData) {
            // Handle both string and array formats for insights and recommendations
            let insights = businessData.insights || [];
            let recommendations = businessData.seo_recommendations || [];
            
            // Convert strings to arrays if needed
            if (typeof insights === 'string') {
                insights = insights ? [insights] : [];
            }
            if (typeof recommendations === 'string') {
                recommendations = recommendations ? [recommendations] : [];
            }
            
            // Ensure they are arrays
            if (!Array.isArray(insights)) insights = [];
            if (!Array.isArray(recommendations)) recommendations = [];
            
            let insightsHtml = '';
            
            // Add business insights without heading
            if (insights.length > 0) {
                insights.forEach(insight => {
                    insightsHtml += `<p>${insight}</p>`;
                });
            }
            
            // Hide SEO recommendations - save for later use
            // if (recommendations.length > 0) {
            //     recommendations.forEach(rec => {
            //         insightsHtml += `<p>• ${rec}</p>`;
            //     });
            // }
            
            if (insightsHtml) {
                document.getElementById('businessInsights').innerHTML = insightsHtml;
            } else {
                document.getElementById('businessInsights').innerHTML = '<p>Business context analysis completed. No specific insights available.</p>';
            }
        }

        function generateKeywordInsights(metrics) {
            // This function is now handled by updateKeywordMetrics when real data is loaded
            // The insights are generated on the backend and displayed via loadKeywordData()
            document.getElementById('keywordInsights').innerHTML = '<p>Loading keyword performance insights...</p>';
        }

        // Mobile Menu Functions
        function toggleMobileMenu() {
            const menu = document.getElementById('mobileMenu');
            const overlay = document.getElementById('mobileMenuOverlay');
            
            if (menu.classList.contains('active')) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        }

        function openMobileMenu() {
            const menu = document.getElementById('mobileMenu');
            const overlay = document.getElementById('mobileMenuOverlay');
            
            menu.classList.add('active');
            overlay.classList.add('active');
            
            // Prevent body scroll when menu is open
            document.body.style.overflow = 'hidden';
        }

        function closeMobileMenu() {
            const menu = document.getElementById('mobileMenu');
            const overlay = document.getElementById('mobileMenuOverlay');
            
            menu.classList.remove('active');
            overlay.classList.remove('active');
            
            // Restore body scroll
            document.body.style.overflow = '';
        }

        // Close menu on escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeMobileMenu();
            }
        });

        async function initDashboard() {
            checkAuth();
            
            // Handle OAuth callback parameters
            handleOAuthCallback();
            
            const hasGSC = await checkGSCConnection();
            console.log('[DEBUG] Dashboard init - hasGSC:', hasGSC);
            
            if (hasGSC) {
                // Fetch real metrics from GSC
                await loadRealMetrics();
            } else {
                // Show empty state
                updateDashboardMetrics(false);
                createMergedTrendsChart({});
            }
        }

        function handleOAuthCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const oauthSuccess = urlParams.get('oauth_success');
            const oauthError = urlParams.get('oauth_error');
            
            if (oauthSuccess === 'true') {
                console.log('[DEBUG] OAuth success detected, will show property selector after GSC check');
                // Clean up URL parameters
                const cleanUrl = window.location.pathname;
                window.history.replaceState({}, document.title, cleanUrl);
            } else if (oauthError === 'true') {
                console.log('[DEBUG] OAuth error detected');
                // Clean up URL parameters
                const cleanUrl = window.location.pathname;
                window.history.replaceState({}, document.title, cleanUrl);
                
                // Show error message
                alert('Failed to connect to Google Search Console. Please try again.');
            }
        }



        async function checkGSCConnection() {
            try {
                console.log('[DEBUG] Checking GSC connection...');
                const response = await apiCall('/auth/gsc/properties');

                console.log('[DEBUG] GSC response status:', response.status);

                if (response.status === 401 || response.status === 404) {
                    console.log('[DEBUG] Auth error (401/404), showing banner');
                    showGSCBanner();
                    return false;
                }
                if (!response.ok) {
                    const errorText = await response.text();
                    console.log('[DEBUG] GSC connection error:', errorText);
                    
                    // Check if it's a credentials issue
                    if (response.status === 500 && errorText.includes('credentials')) {
                        console.log('[DEBUG] Credentials issue, showing reauth banner');
                        showGSCBannerWithReauth();
                    } else {
                        console.log('[DEBUG] Other error, showing regular banner');
                        showGSCBanner();
                    }
                    return false;
                }

                const properties = await response.json();
                console.log('[DEBUG] GSC properties received:', properties);
                
                if (!properties || properties.length === 0) {
                    console.log('[DEBUG] No properties found, showing banner');
                    showGSCBanner();
                    return false;
                }

                const isDemoMode = properties.some(p => p.siteUrl.includes('example.com') || p.siteUrl.includes('demo-site.com'));
                console.log('[DEBUG] Is demo mode:', isDemoMode);
                
                if (isDemoMode) {
                    console.log('[DEBUG] Demo mode detected, showing banner');
                    showGSCBanner();
                    return false;
                }

                // Check if a property is already selected
                const selectedResponse = await apiCall('/auth/gsc/selected');
                if (selectedResponse && selectedResponse.ok) {
                    const selectedProperty = await selectedResponse.json();
                    console.log('[DEBUG] Property already selected:', selectedProperty);
                hideGSCBanner();
                return true;
                } else {
                    console.log('[DEBUG] No property selected yet, response status:', selectedResponse?.status);
                }

                // Properties available but none selected - show banner to prompt selection
                console.log('[DEBUG] Properties available but none selected, showing banner');
                showGSCBanner();
                return false;
            } catch (error) {
                console.log('[DEBUG] Exception in checkGSCConnection:', error);
                showGSCBanner();
                return false;
            }
        }

        function showGSCBanner() {
            document.getElementById('gscBanner').classList.remove('hidden');
        }

        function hideGSCBanner() {
            document.getElementById('gscBanner').classList.add('hidden');
        }

        function showGSCBannerWithReauth() {
            const banner = document.getElementById('gscBanner');
            banner.classList.remove('hidden');
            
            // Update banner content to show re-authentication option
            const bannerText = banner.querySelector('.banner-text p');
            if (bannerText) {
                bannerText.innerHTML = 'Your Google Search Console connection has an issue. <button onclick="clearCredentials()" class="btn-link">Click here to re-authenticate</button> or connect a new account.';
            }
        }

        async function clearCredentials() {
            try {
                const response = await apiCall('/auth/gsc/clear-credentials', {
                    method: 'POST'
                });

                if (response.ok) {
                    // Redirect to Google OAuth directly, bypassing setup wizard
                    window.location.href = '/auth/google/authorize';
                } else {
                    alert('Failed to clear credentials. Please try again.');
                }
            } catch (error) {
                console.error('Error clearing credentials:', error);
                alert('Failed to clear credentials. Please try again.');
            }
        }

        async function connectGSC() {
            try {
                console.log('[DEBUG] Connecting to GSC...');
                
                // Make authenticated API call to get the authorization URL
                const response = await apiCall('/auth/google/authorize');
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[DEBUG] Got authorization URL:', data.auth_url);
                    
                    // Redirect to Google OAuth authorization page
                    window.location.href = data.auth_url;
                } else {
                    const errorText = await response.text();
                    console.error('[ERROR] Failed to get authorization URL:', errorText);
                    throw new Error('Failed to initialize Google OAuth');
                }
            } catch (error) {
                console.error('[ERROR] Error connecting to GSC:', error);
                
                // Show error message to user
                const banner = document.getElementById('gscBanner');
                const bannerText = banner.querySelector('.banner-text p');
                
                if (bannerText) {
                    bannerText.textContent = 'Unable to connect to Google Search Console. Please check your internet connection and try again.';
                }
                banner.classList.remove('hidden');
            }
        }

        // Property selector modal removed - now handled by property_selection.html

        // Property selector functions removed - now handled by property_selection.html

        async function refreshMetrics() {
            const refreshBtn = document.getElementById('refreshBtn');
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.classList.add('loading');
            
            try {
                const response = await apiCall('/auth/gsc/refresh', {
                    method: 'POST'
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Metrics refreshed successfully:', data);
                    
                    // Reload the dashboard with fresh data
                    await loadRealMetrics();
                } else {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to refresh data');
                }
            } catch (error) {
                console.error('Error refreshing metrics:', error);
                // showErrorMessage('Could not refresh data. Your connection to Google may have been lost.');
                
                // Force the banner to show with a helpful message
                const banner = document.getElementById('gscBanner');
                const bannerText = banner.querySelector('.banner-text p');
                
                if (bannerText) {
                    bannerText.textContent = 'We couldn\'t refresh your data because the connection to Google Search Console was lost. Please reconnect to continue.';
                }
                banner.classList.remove('hidden');

            } finally {
                // Reset button state after a short delay to allow animation to be seen
                setTimeout(() => {
                    refreshBtn.disabled = false;
                    refreshBtn.classList.remove('loading');
                }, 500);
            }
        }

        function recalculateOverallSEOScore() {
            const seoScore = calculateSEOScore(
                window.metricsData.summary,
                window.metricsData.ux,
                window.metricsData.mobile,
                window.metricsData.indexing,
                window.metricsData.keywords,
                window.metricsData.business
            );
            
            // Calculate and update SEO score change (use backend data if available, otherwise fallback to session-based)
            const seoScoreChange = window.metricsData.summary?.seo_score_change !== undefined ? 
                window.metricsData.summary.seo_score_change : 
                calculateChange('seo_score', seoScore);
            
            document.getElementById('seoScore').textContent = seoScore;
            updateSEOScoreChange(seoScoreChange);
            console.log('[DEBUG] Recalculated SEO score:', seoScore, 'change:', seoScoreChange, 'using data:', window.metricsData);
        }

        function calculateSEOScore(summary, ux = {}, mobile = {}, indexing = {}, keywords = {}, business = {}) {
            // Define all metrics, their weights, and normalization functions
            const metrics = [
                // Visibility
                { key: 'avg_ctr', value: summary.avg_ctr, weight: 10, norm: v => Math.min(v / 0.10, 1) },
                { key: 'avg_position', value: summary.avg_position, weight: 10, norm: v => Math.max((10 - v) / 10, 0) },
                { key: 'total_impressions', value: summary.total_impressions, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 6, 1) },
                { key: 'total_clicks', value: summary.total_clicks, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 5, 1) },
                // UX
                { key: 'performance_score', value: ux.performance_score, weight: 10, norm: v => (v / 100) },
                { key: 'lcp', value: ux.lcp, weight: 5, norm: v => 1 - Math.min(v, 4) / 4 },
                { key: 'fcp', value: ux.fcp, weight: 5, norm: v => 1 - Math.min(v, 3) / 3 },
                { key: 'cls', value: ux.cls, weight: 5, norm: v => 1 - Math.min(v, 0.25) / 0.25 },
                // Mobile
                { key: 'mobile_friendly', value: mobile.mobile_friendly, weight: 10, norm: v => (v === 'Yes' || v === 'Pass') ? 1 : 0 },
                { key: 'issues_count', value: mobile.issues_count, weight: 5, norm: v => 1 - Math.min(v, 5) / 5 },
                // Indexing
                { key: 'sitemap_status', value: indexing.sitemap_status, weight: 5, norm: v => v === 'Active' ? 1 : 0 },
                { key: 'index_status', value: indexing.index_status, weight: 5, norm: v => ['PASS', 'NEUTRAL'].includes(v) ? 1 : 0 },
                // Keywords
                { key: 'total_keywords', value: keywords.total_keywords, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 4, 1) },
                { key: 'opportunities', value: keywords.opportunities, weight: 5, norm: v => Math.min(v / 10, 1) },
                { key: 'branded_keywords', value: (keywords.branded_keywords !== undefined && keywords.total_keywords) ? 1 - Math.min(keywords.branded_keywords / (keywords.total_keywords || 1), 1) : undefined, weight: 5, norm: v => v },
                // Business Context
                { key: 'business_complexity_score', value: business.business_complexity_score, weight: 3, norm: v => Math.min(v / 10, 1) },
                { key: 'service_count', value: business.service_count, weight: 2, norm: v => Math.min(Math.log10(v + 1) / 2, 1) },
            ];

            // Filter out missing metrics
            const present = metrics.filter(m => m.value !== undefined && m.value !== null && !Number.isNaN(m.value));
            const totalWeight = present.reduce((sum, m) => sum + m.weight, 0);
            if (totalWeight === 0) return 0;

            // Dynamically scale weights so total is 100
            let score = 0;
            present.forEach(m => {
                const scaledWeight = m.weight * (100 / totalWeight);
                let normValue = m.key === 'branded_keywords' ? m.value : m.norm(m.value);
                normValue = Math.max(0, Math.min(normValue, 1));
                score += normValue * scaledWeight;
            });
            return Math.round(score);
        }

        function formatDateString(dateStr) {
            // dateStr is in "YYYY-MM-DD" format
            if (!dateStr || dateStr.split('-').length !== 3) {
                return '';
            }
            const [year, month, day] = dateStr.split('-');
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const monthName = monthNames[parseInt(month, 10) - 1];
            return `${monthName} ${parseInt(day, 10)}`;
        }

        function showDateRange(metrics) {
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            const dateRangeSpan = document.getElementById('dateRange');

            if (metrics && metrics.start_date && metrics.end_date) {
                const startStr = formatDateString(metrics.start_date);
                const endStr = formatDateString(metrics.end_date);
                
                dateRangeSpan.textContent = `${startStr} - ${endStr}`;
                dateRangeInfo.classList.remove('hidden');
            } else {
                hideDateRange();
            }
        }

        function hideDateRange() {
            document.getElementById('dateRangeInfo').classList.add('hidden');
        }

        function showWebsiteInfo(metrics) {
            const websiteInfo = document.getElementById('websiteInfo');
            const trackedWebsite = document.getElementById('trackedWebsite');
            const mobileMenuWebsite = document.getElementById('mobileMenuWebsite');

            if (metrics && metrics.website_url) {
                let displayUrl = metrics.website_url;
                if (displayUrl.startsWith('sc-domain:')) {
                    // Convert sc-domain:example.com to https://example.com
                    const domain = displayUrl.replace('sc-domain:', '');
                    displayUrl = `https://${domain}`;
                }
                trackedWebsite.textContent = displayUrl;
                mobileMenuWebsite.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-icon"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg>${displayUrl}`;
                websiteInfo.classList.remove('hidden');
            } else {
                hideWebsiteInfo();
            }
        }

        function hideWebsiteInfo() {
            document.getElementById('websiteInfo').classList.add('hidden');
            document.getElementById('mobileMenuWebsite').textContent = 'No website selected';
        }

        function changeWebsite() {
            // Redirect to setup wizard to select a different website
            window.location.href = '/setup';
        }
        
        function showMetricsLoadingPopup() {
            const popup = document.getElementById('metricsLoadingPopup');
            popup.style.display = 'flex';
            // Force reflow for transition
            void popup.offsetWidth;
            popup.classList.remove('metrics-loading-hide');
            popup.classList.add('metrics-loading-visible');
            updateMetricsLoadingList();
        }
        function hideMetricsLoadingPopup() {
            const popup = document.getElementById('metricsLoadingPopup');
            popup.classList.remove('metrics-loading-visible');
            popup.classList.add('metrics-loading-hide');
            function onTransitionEnd(e) {
                if (e.propertyName === 'transform') {
                    popup.style.display = 'none';
                    popup.removeEventListener('transitionend', onTransitionEnd);
                }
            }
            popup.addEventListener('transitionend', onTransitionEnd);
        }
        function showMetricsSuccessPopup() {
            const popup = document.getElementById('metricsSuccessPopup');
            popup.style.display = 'flex';
            // Force reflow for transition
            void popup.offsetWidth;
            popup.classList.remove('metrics-success-hide');
            popup.classList.add('metrics-success-visible');
        }
        function hideMetricsSuccessPopup() {
            const popup = document.getElementById('metricsSuccessPopup');
            popup.classList.remove('metrics-success-visible');
            popup.classList.add('metrics-success-hide');
            function onTransitionEnd(e) {
                if (e.propertyName === 'transform') {
                    popup.style.display = 'none';
                    popup.removeEventListener('transitionend', onTransitionEnd);
                }
            }
            popup.addEventListener('transitionend', onTransitionEnd);
        }
        function updateMetricsLoadingList() {
            const list = document.getElementById('metricsLoadingList');
            list.innerHTML = METRIC_GROUPS.map(m => {
                const state = metricsLoadingState[m.key];
                if (state === 'done') {
                    return `<div style="display:flex;align-items:center;gap:0.5rem;color:#16a34a;font-weight:400;"><span class="metric-success-icon"><svg width='18' height='18'><polyline points='3,10 8,15 15,4' style='fill:none;stroke:#16a34a;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;'/></svg></span>${m.label}</div>`;
                } else {
                    return `<div style="display:flex;align-items:center;gap:0.5rem;color:#D97706;"><span class="metric-loading-spinner"><svg width='18' height='18' viewBox='0 0 50 50'><circle cx='25' cy='25' r='20' fill='none' stroke='#D97706' stroke-width='5' stroke-linecap='round' stroke-dasharray='31.4 31.4' stroke-dashoffset='0'><animateTransform attributeName='transform' type='rotate' from='0 25 25' to='360 25 25' dur='0.8s' repeatCount='indefinite'/></circle></svg></span>${m.label}</div>`;
                }
            }).join('');
        }
        function setMetricLoadingState(key, state) {
            metricsLoadingState[key] = state;
            updateMetricsLoadingList();
            
            // Set loading state for growth indicators
            if (state === 'loading') {
                setGrowthIndicatorsLoading(key);
            }
            
            // If all done, show success popup and hide both after 5s with countdown
            if (METRIC_GROUPS.every(m => metricsLoadingState[m.key] === 'done')) {
                const loadingPopup = document.getElementById('metricsLoadingPopup');
                const successPopup = document.getElementById('metricsSuccessPopup');
                loadingPopup.style.display = 'flex';
                successPopup.style.display = 'flex';
                showMetricsSuccessPopup();
                let secondsLeft = 5;
                const timerSpan = document.getElementById('metricsSuccessTimer');
                timerSpan.textContent = `(${secondsLeft}s)`;
                timerSpan.style.color = '';
                const interval = setInterval(() => {
                    secondsLeft--;
                    timerSpan.textContent = `(${secondsLeft}s)`;
                    if (secondsLeft <= 0) {
                        clearInterval(interval);
                        hideMetricsSuccessPopup();
                        hideMetricsLoadingPopup();
                    }
                }, 1000);
            }
        }

        function setGrowthIndicatorsLoading(section) {
            console.log(`[DEBUG] Setting growth indicators loading for section: ${section}`);
            const indicatorMap = {
                'visibility': [
                    'impressionsChange', 'clicksChange', 'ctrChange', 'avgPositionChange'
                ],
                'organic': [
                    'impressionsChange', 'clicksChange'
                ],
                'impressions': [
                    'impressionsChange'
                ],
                'keywords': [
                    'totalKeywordsChange', 'keywordAvgPositionChange', 'keywordOpportunitiesChange', 'brandedKeywordsChange'
                ],
                'ux': [
                    'performanceScoreChange', 'lcpChange', 'fcpChange', 'clsChange'
                ],
                'mobile': [
                    'mobileIssuesChange'
                ],
                'indexing': [
                    'indexedPagesChange'
                ],
                'business': [
                    'businessTypeChange', 'targetMarketChange', 'businessComplexityChange', 'serviceCountChange'
                ]
            };

            const indicators = indicatorMap[section] || [];
            indicators.forEach(indicatorId => {
                const element = document.getElementById(indicatorId);
                if (element) {
                    updateChangeIndicator(indicatorId, 'loading');
                } else {
                    console.warn(`[DEBUG] Growth indicator element not found: ${indicatorId}`);
                }
            });
        }
        function resetMetricsLoadingState() {
            METRIC_GROUPS.forEach(m => metricsLoadingState[m.key] = 'loading');
            updateMetricsLoadingList();
        }
        
        async function loadRealMetrics() {
            console.log('[DEBUG] Starting loadRealMetrics...');
            showMetricsLoadingPopup();
            resetMetricsLoadingState();
            
            try {
                console.log('[DEBUG] Fetching GSC metrics...');
                setMetricLoadingState('visibility', 'loading');
                const response = await apiCall('/auth/gsc/metrics');
                console.log('[DEBUG] GSC metrics response status:', response.status);
                
                if (response.ok) {
                    const metrics = await response.json();
                    console.log('[DEBUG] GSC metrics received:', metrics);
                    
                    // Validate metrics data structure
                    if (!metrics || !metrics.summary) {
                        console.error('[ERROR] Invalid metrics data structure:', metrics);
                        throw new Error('Invalid metrics data structure received from API');
                    }
                    
                    console.log('[DEBUG] Updating dashboard with metrics...');
                    updateDashboardMetricsWithRealData(metrics);
                    
                    console.log('[DEBUG] Creating charts...');
                    createMergedTrendsChart(metrics);
                    
                    console.log('[DEBUG] Showing website info...');
                    showWebsiteInfo(metrics);
                    showDateRange(metrics);
                    
                    // Mark core metrics as loaded
                    setMetricLoadingState('visibility', 'done');
                    setMetricLoadingState('organic', 'done');
                    setMetricLoadingState('impressions', 'done');
                    
                    console.log('[DEBUG] Fetching additional metrics in parallel...');
                    // Fetch all other data types in parallel
                    const additionalMetricsPromises = [
                        loadKeywordData().catch(e => console.error('[ERROR] Keyword data failed:', e)),
                        fetchPageSpeedData().catch(e => console.error('[ERROR] PageSpeed data failed:', e)),
                        fetchMobileData().catch(e => console.error('[ERROR] Mobile data failed:', e)),
                        fetchIndexingData().catch(e => console.error('[ERROR] Indexing data failed:', e)),
                        fetchBusinessData().catch(e => console.error('[ERROR] Business data failed:', e))
                    ];
                    
                    await Promise.allSettled(additionalMetricsPromises);
                    console.log('[DEBUG] All metrics loading completed');
                    
                } else {
                    const errorText = await response.text();
                    console.error('[ERROR] Failed to load GSC metrics:', response.status, errorText);
                    
                    // Set all states to done since we can't fetch data
                    setMetricLoadingState('visibility', 'done');
                    setMetricLoadingState('organic', 'done');
                    setMetricLoadingState('impressions', 'done');
                    setMetricLoadingState('keywords', 'done');
                    setMetricLoadingState('ux', 'done');
                    setMetricLoadingState('mobile', 'done');
                    setMetricLoadingState('indexing', 'done');
                    setMetricLoadingState('business', 'done');
                    
                    // Show empty state
                    updateDashboardMetrics(false);
                    createMergedTrendsChart({});
                    hideWebsiteInfo();
                    hideDateRange();
                }
            } catch (error) {
                console.error('[ERROR] Exception in loadRealMetrics:', error);
                
                // Set all states to done
                setMetricLoadingState('visibility', 'done');
                setMetricLoadingState('organic', 'done');
                setMetricLoadingState('impressions', 'done');
                setMetricLoadingState('keywords', 'done');
                setMetricLoadingState('ux', 'done');
                setMetricLoadingState('mobile', 'done');
                setMetricLoadingState('indexing', 'done');
                setMetricLoadingState('business', 'done');
                
                // Show empty state
                updateDashboardMetrics(false);
                createMergedTrendsChart({});
                hideWebsiteInfo();
                hideDateRange();
            } finally {
                // Note: Loading popup will be hidden by setMetricLoadingState when all metrics are done
                // The 5-second countdown timer handles hiding both loading and success popups
            }
        }
        
        document.addEventListener('DOMContentLoaded', initDashboard);

        // Hide error banner on page load
        document.addEventListener('DOMContentLoaded', function() {
            hideErrorMessage();
        });

        // Expose test functions to global scope for console access
        window.testBusinessData = testBusinessData;
        window.testDataLoading = testDataLoading;
        window.runFullDiagnostic = runFullDiagnostic;

        async function loadKeywordData() {
            setMetricLoadingState('keywords', 'loading');
            try {
                const response = await apiCall('/auth/keyword/metrics');
                if (response.ok) {
                    const keywordData = await response.json();
                    updateKeywordMetrics(keywordData);
                    setMetricLoadingState('keywords', 'done');
                } else {
                    setMetricLoadingState('keywords', 'done');
                }
            } catch (error) {
                setMetricLoadingState('keywords', 'done');
            }
        }

        function updateKeywordMetrics(keywordData) {
            console.log('[DEBUG] ========== UPDATING KEYWORD METRICS ==========');
            console.log('[DEBUG] Received keyword data:', JSON.stringify(keywordData, null, 2));
            
            // Store keyword data globally
            window.metricsData = window.metricsData || {};
            window.metricsData.keywords = {
                total_keywords: keywordData.total_keywords || 0,
                avg_position: keywordData.avg_position,
                opportunities: keywordData.opportunities || 0,
                branded_keywords: keywordData.branded_keywords || 0,
                keywords_list: keywordData.keywords_list || [],
                top_keywords: keywordData.top_keywords
            };
            
            // Update keyword metrics in the dashboard
            const totalKeywords = keywordData.total_keywords || 0;
            const avgPosition = keywordData.avg_position;
            const opportunities = keywordData.opportunities || 0;
            const brandedKeywords = keywordData.branded_keywords || 0;
            
            // Safely update DOM elements
            const elements = {
                'totalKeywords': totalKeywords.toLocaleString(),
                'keywordAvgPosition': avgPosition?.toFixed(1) || 'N/A',
                'keywordOpportunities': opportunities.toLocaleString(),
                'brandedKeywords': brandedKeywords.toLocaleString()
            };
            
            console.log('[DEBUG] Updating keyword summary elements:', elements);
            Object.entries(elements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                    console.log(`[DEBUG] Set ${id} to: ${value}`);
                } else {
                    console.warn(`[DEBUG] Element not found: ${id}`);
                }
            });
            
            // Update keyword insights
            if (keywordData.keyword_insights) {
                const insightsElement = document.getElementById('keywordInsights');
                if (insightsElement) {
                    insightsElement.innerHTML = `<p>${keywordData.keyword_insights}</p>`;
                    console.log('[DEBUG] Updated keyword insights');
                }
            }
            
            // Update keywords list
            const keywordsList = keywordData.keywords_list || [];
            console.log('[DEBUG] Processing keywords list:', keywordsList);
            
            const keywordsListElement = document.getElementById('keywordsList');
            if (keywordsListElement && keywordsList.length > 0) {
                console.log('[DEBUG] Updating keywords list with', keywordsList.length, 'keywords');
                
                let keywordsHtml = '<h4>Keywords Found:</h4><div class="keywords-list-container">';
                
                keywordsList.forEach((keyword, index) => {
                    const position = keyword.position ? Math.round(keyword.position) : 'N/A';
                    const impressions = keyword.impressions || 0;
                    const clicks = keyword.clicks || 0;
                    const ctr = keyword.ctr ? (keyword.ctr * 100).toFixed(1) : '0.0';
                    
                    keywordsHtml += `
                        <div class="keyword-item">
                            <div class="keyword-name">
                                <span>${keyword.keyword || 'Unknown'}</span>
                            </div>
                            <div class="keyword-metrics">
                                <div class="keyword-position">Pos: ${position}</div>
                                <div class="keyword-impressions">Imp: ${impressions.toLocaleString()}</div>
                                <div class="keyword-clicks">Clicks: ${clicks.toLocaleString()}</div>
                                <div class="keyword-ctr">CTR: ${ctr}%</div>
                            </div>
                        </div>
                    `;
                });
                
                keywordsHtml += '</div>';
                keywordsListElement.innerHTML = keywordsHtml;
                console.log('[DEBUG] Keywords list updated with HTML');
            } else if (keywordsListElement) {
                console.log('[DEBUG] No keywords to display, showing empty state');
                keywordsListElement.innerHTML = '<div class="keywords-empty">No keywords data available</div>';
            }
            
            // Update top keywords if available
            if (keywordData.top_keywords) {
                console.log('[DEBUG] Top keywords:', keywordData.top_keywords);
                // You can add logic here to display top keywords in a separate section if needed
            }
            
            console.log('[DEBUG] ========== KEYWORD METRICS UPDATE COMPLETED ==========');
        }

        async function fetchPageSpeedData() {
            setMetricLoadingState('ux', 'loading');
            try {
                const response = await apiCall('/auth/pagespeed/metrics');
                if (response.ok) {
                    const psiData = await response.json();
                    updateUXMetrics(psiData);
                    setMetricLoadingState('ux', 'done');
                } else {
                    setMetricLoadingState('ux', 'done');
                }
            } catch (error) {
                setMetricLoadingState('ux', 'done');
            }
        }

        function updateUXMetrics(psiData) {
            console.log('[DEBUG] ========== UPDATING UX METRICS ==========');
            console.log('[DEBUG] Received UX data:', JSON.stringify(psiData, null, 2));
            
            // Store UX data globally
            window.metricsData = window.metricsData || {};
            window.metricsData.ux = {
                performance_score: psiData.performance_score,
                lcp: psiData.lcp?.value,
                fcp: psiData.fcp?.value,
                cls: psiData.cls?.value,
                insights: psiData.insights || [],
                recommendations: psiData.recommendations || []
            };
            
            // Update UX metrics in the dashboard
            const performanceScore = psiData.performance_score;
            const lcpValue = psiData.lcp?.value;
            const fcpValue = psiData.fcp?.value;
            const clsValue = psiData.cls?.value;
            
            // Safely update DOM elements
            const elements = {
                'performanceScore': performanceScore !== undefined ? performanceScore : 'N/A',
                'lcpValue': lcpValue !== undefined ? `${lcpValue.toFixed(1)}s` : 'N/A',
                'fcpValue': fcpValue !== undefined ? `${fcpValue.toFixed(1)}s` : 'N/A',
                'clsValue': clsValue !== undefined ? clsValue.toFixed(3) : 'N/A'
            };
            
            console.log('[DEBUG] Updating UX metric elements:', elements);
            Object.entries(elements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                    console.log(`[DEBUG] Set ${id} to: ${value}`);
                } else {
                    console.warn(`[DEBUG] Element not found: ${id}`);
                }
            });
            
            // Generate and update performance insights
            console.log('[DEBUG] Generating performance insights...');
            generatePerformanceInsights(psiData);
            
            console.log('[DEBUG] ========== UX METRICS UPDATE COMPLETED ==========');
        }

        function generatePerformanceInsights(psiData) {
            const insights = [];
            const performanceScore = psiData.performance_score;
            const lcpValue = psiData.lcp?.value;
            const fcpValue = psiData.fcp?.value;
            const clsValue = psiData.cls?.value;
            
            // Generate insights based on performance metrics
            if (performanceScore !== undefined) {
                if (performanceScore >= 90) {
                    insights.push("Excellent performance score! Your website loads quickly and provides a great user experience.");
                } else if (performanceScore >= 70) {
                    insights.push("Good performance score. Consider optimizing further to reach excellent performance.");
                } else if (performanceScore >= 50) {
                    insights.push("Moderate performance score. There are opportunities to improve loading speed and user experience.");
                } else {
                    insights.push("Poor performance score. Immediate optimization is needed to improve user experience and SEO rankings.");
                }
            }
            
            // LCP insights
            if (lcpValue !== undefined) {
                if (lcpValue <= 2.5) {
                    insights.push("Largest Contentful Paint is excellent - users see your main content quickly.");
                } else if (lcpValue <= 4.0) {
                    insights.push("Largest Contentful Paint needs improvement - consider optimizing images and server response times.");
                } else {
                    insights.push("Largest Contentful Paint is poor - users wait too long to see your main content. Optimize images, reduce server response time, and eliminate render-blocking resources.");
                }
            }
            
            // FCP insights
            if (fcpValue !== undefined) {
                if (fcpValue <= 1.8) {
                    insights.push("First Contentful Paint is excellent - users see content appear quickly.");
                } else if (fcpValue <= 3.0) {
                    insights.push("First Contentful Paint needs improvement - optimize critical rendering path and reduce server response time.");
                } else {
                    insights.push("First Contentful Paint is poor - users experience significant delays. Optimize server response time and eliminate render-blocking resources.");
                }
            }
            
            // CLS insights
            if (clsValue !== undefined) {
                if (clsValue <= 0.1) {
                    insights.push("Cumulative Layout Shift is excellent - your page layout is stable and doesn't shift unexpectedly.");
                } else if (clsValue <= 0.25) {
                    insights.push("Cumulative Layout Shift needs improvement - some elements may shift during loading, affecting user experience.");
                } else {
                    insights.push("Cumulative Layout Shift is poor - page elements shift significantly during loading. Add dimensions to images and reserve space for ads.");
                }
            }
            
            // Use API insights if available, otherwise use generated insights
            let finalInsights = [];
            if (psiData.insights && Array.isArray(psiData.insights) && psiData.insights.length > 0) {
                finalInsights = psiData.insights;
            } else if (psiData.insights && typeof psiData.insights === 'string') {
                finalInsights = [psiData.insights];
            } else {
                finalInsights = insights;
            }
            
            // Add recommendations if available
            if (psiData.recommendations) {
                if (Array.isArray(psiData.recommendations)) {
                    finalInsights.push(...psiData.recommendations);
                } else if (typeof psiData.recommendations === 'string') {
                    finalInsights.push(psiData.recommendations);
                }
            }
            
            // Update the insights container
            const uxInsightsElement = document.getElementById('uxInsights');
            if (uxInsightsElement) {
                if (finalInsights.length > 0) {
                    const insightsHtml = finalInsights.map(insight => `<p>${insight}</p>`).join('');
                    uxInsightsElement.innerHTML = insightsHtml;
                    console.log('[DEBUG] Updated UX insights with', finalInsights.length, 'insights');
                } else {
                    uxInsightsElement.innerHTML = '<p>Performance analysis completed. No specific insights available.</p>';
                    console.log('[DEBUG] No UX insights available, showing default message');
                }
            } else {
                console.warn('[DEBUG] UX insights element not found');
            }
        }

        // Duplicate fetchMobileData function removed - using the comprehensive version above
        // Duplicate fetchBusinessData function removed - using the enhanced version above with debugging
        // Duplicate loadRealMetrics function removed - using the enhanced version above

        // TEST FUNCTION - Call this from console to debug
        async function testDataLoading() {
            console.log('=== MANUAL DATA LOADING TEST ===');
            
            // Step 1: Check authentication
            console.log('1. Checking authentication...');
            if (!checkAuthStatus()) {
                console.log('❌ Authentication failed, stopping test');
                return;
            }
            
            // Step 2: Test API call
            console.log('2. Testing API call...');
            try {
                const response = await apiCall('/auth/gsc/metrics');
                console.log('- Response status:', response.status);
                
                if (response && response.ok) {
                    const data = await response.json();
                    console.log('- Response data:', JSON.stringify(data, null, 2));
                    
                    // Step 3: Test data processing
                    console.log('3. Testing updateDashboardMetricsWithRealData...');
                    updateDashboardMetricsWithRealData(data);
                    console.log('✅ Data loading test completed successfully');
                } else {
                    console.log('❌ API call failed');
                    const errorText = await response.text();
                    console.log('Error details:', errorText);
                }
            } catch (error) {
                console.error('❌ Exception during API call:', error);
            }
        }

        // TEST FUNCTION - Call this from console to debug business data specifically
        async function testBusinessData() {
            console.log('=== BUSINESS DATA TEST ===');
            
            // Step 1: Check current business data in memory
            console.log('1. Current business data in window.metricsData:', window.metricsData?.business);
            
            // Step 2: Check all business DOM elements
            console.log('2. Business DOM elements status:');
            const businessElements = [
                'businessType', 'targetMarket', 'industrySector', 'companySize', 
                'primaryAgeGroup', 'incomeLevel', 'audienceSophistication', 
                'geographicFocus', 'businessMaturity', 'technologyPlatform', 
                'contentStrategy', 'competitivePosition', 'businessStatus', 'businessInsights'
            ];
            
            businessElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                console.log(`   ${elementId}:`, element ? 
                    `✅ EXISTS - content: "${element.textContent}", visible: ${element.offsetParent !== null}` : 
                    '❌ NOT FOUND'
                );
            });
            
            // Step 3: Test business API call directly
            console.log('3. Testing business API call...');
            if (!checkAuthStatus()) {
                console.log('❌ Authentication failed, stopping business test');
                return;
            }
            
            try {
                const response = await apiCall('/auth/business/metrics');
                console.log('   Business API response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('   ✅ Business API data received:', JSON.stringify(data, null, 2));
                    console.log('   Key fields:');
                    console.log('   - Business type:', data.business_type);
                    console.log('   - Target market:', data.target_market);
                    console.log('   - Industry sector:', data.industry_sector);
                    console.log('   - Company size:', data.company_size);
                    console.log('   - Insights:', data.insights);
                    
                    // Step 4: Try manual update
                    console.log('4. Testing manual DOM update...');
                    const businessTypeElement = document.getElementById('businessType');
                    if (businessTypeElement) {
                        const oldValue = businessTypeElement.textContent;
                        businessTypeElement.textContent = data.business_type || 'TEST_UPDATE';
                        console.log('   Manual update test:', oldValue, '→', businessTypeElement.textContent);
                        console.log('   ✅ Manual DOM update successful');
                    } else {
                        console.log('   ❌ businessType element not found for manual update');
                    }
                    
                    // Step 5: Test full business data processing
                    console.log('5. Testing updateBusinessMetrics function...');
                    updateBusinessMetrics(data);
                } else {
                    const errorText = await response.text();
                    console.log('   ❌ Business API call failed:', response.status, errorText);
                }
            } catch (error) {
                console.error('   ❌ Exception during business API call:', error);
            }
        }

        // COMPREHENSIVE TEST FUNCTION
        async function runFullDiagnostic() {
            console.log('🔍 === FULL DIAGNOSTIC TEST ===');
            
            // 1. Authentication check
            console.log('\n1️⃣ AUTHENTICATION CHECK:');
            const authOk = checkAuthStatus();
            
            if (!authOk) {
                console.log('🛑 Stopping diagnostic - authentication failed');
                return;
            }
            
            // 2. GSC Properties check
            console.log('\n2️⃣ GSC PROPERTIES CHECK:');
            await checkGSCProperties();
            
            // 3. Metrics fetch test
            console.log('\n3️⃣ METRICS FETCH TEST:');
            await testDataLoading();
            
            // 4. Business data test
            console.log('\n4️⃣ BUSINESS DATA TEST:');
            await testBusinessData();
            
            console.log('\n✅ Full diagnostic completed');
        }

        // TEST FUNCTION - Call this from console to debug date ranges
        async function testDifferentDateRanges() {
            console.log('=== TESTING DIFFERENT DATE RANGES ===');
            
            const token = localStorage.getItem('auth_token');
            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };

            // Test with different date ranges by calling GSC API directly
            const testRanges = [
                { days: 7, name: '7 days' },
                { days: 30, name: '30 days' },
                { days: 90, name: '90 days' }
            ];
            
            for (const range of testRanges) {
                console.log(`\n--- Testing ${range.name} ---`);
                
                try {
                    // We'll use the existing endpoint but test if different periods return data
                    const response = await fetch('/auth/gsc/metrics', { headers });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`Status: ${response.status}`);
                        console.log(`Date range: ${data.start_date} to ${data.end_date}`);
                        
                        const summary = data.summary || {};
                        console.log('Summary data:');
                        console.log(`- total_impressions: ${summary.total_impressions}`);
                        console.log(`- total_clicks: ${summary.total_clicks}`);
                        console.log(`- avg_ctr: ${summary.avg_ctr}`);
                        console.log(`- avg_position: ${summary.avg_position}`);
                        console.log(`- Has time_series: ${Object.keys(data.time_series || {}).length > 0}`);
                        
                        if (data.time_series && data.time_series.dates) {
                            console.log(`- Time series dates: ${data.time_series.dates.length} entries`);
                            console.log(`- Sample dates: ${data.time_series.dates.slice(0, 3).join(', ')}`);
                        }
                    } else {
                        console.log(`Failed: ${response.status}`);
                        const error = await response.text();
                        console.log(`Error: ${error}`);
                    }
                    
                } catch (error) {
                    console.error(`Exception for ${range.name}:`, error);
                }
            }
        }

        // TEST FUNCTION - Direct GSC property check
        async function checkGSCProperties() {
            console.log('=== CHECKING GSC PROPERTIES ===');
            
            const token = localStorage.getItem('auth_token');
            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };

            try {
                const response = await fetch('/auth/gsc/properties', { headers });
                
                if (response.ok) {
                    const properties = await response.json();
                    console.log('Available properties:', properties);
                    console.log('Number of properties:', properties.length);
                    
                    // Check which one is selected
                    const selectedResponse = await fetch('/auth/gsc/selected', { headers });
                    if (selectedResponse.ok) {
                        const selected = await selectedResponse.json();
                        console.log('Selected property:', selected);
                    }
                } else {
                    console.log('Failed to fetch properties:', response.status);
                }
            } catch (error) {
                console.error('Error checking properties:', error);
            }
        }

        // TEST FUNCTION - Check authentication status
        function checkAuthStatus() {
            console.log('=== AUTHENTICATION STATUS CHECK ===');
            
            const token = localStorage.getItem('auth_token');
            console.log('1. Token exists:', !!token);
            
            if (!token) {
                console.log('❌ No authentication token found');
                console.log('💡 Solution: You need to log in first');
                console.log('   - Go to /ui and log in');
                console.log('   - Or click "Connect to Google" if available');
                return false;
            }
            
            try {
                console.log('2. Token format:', token.substring(0, 50) + '...');
                
                const payload = JSON.parse(atob(token.split('.')[1]));
                const currentTime = Math.floor(Date.now() / 1000);
                const isExpired = payload.exp && payload.exp < currentTime;
                
                console.log('3. Token details:', {
                    userEmail: payload.sub,
                    issuedAt: new Date(payload.iat * 1000).toLocaleString(),
                    expiresAt: new Date(payload.exp * 1000).toLocaleString(),
                    isExpired: isExpired,
                    timeUntilExpiry: isExpired ? 'EXPIRED' : `${Math.round((payload.exp - currentTime) / 60)} minutes`
                });
                
                if (isExpired) {
                    console.log('❌ Token has expired');
                    console.log('💡 Solution: Refresh the page to get a new token');
                    return false;
                }
                
                console.log('✅ Authentication token is valid');
                
                // Test API call
                console.log('4. Testing API call...');
                fetch('/auth/me', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                }).then(response => {
                    console.log('API test result:', response.status);
                    if (response.ok) {
                        console.log('✅ API authentication working');
                    } else {
                        console.log('❌ API authentication failed');
                        console.log('💡 Solution: Clear localStorage and log in again');
                    }
                }).catch(error => {
                    console.error('API test error:', error);
                });
                
                return true;
                
            } catch (error) {
                console.error('❌ Error parsing token:', error);
                console.log('💡 Solution: Clear localStorage and log in again');
                console.log('   - Run: localStorage.clear()');
                console.log('   - Then go to /ui and log in');
                return false;
            }
        }
    </script>
</body>
</html> 