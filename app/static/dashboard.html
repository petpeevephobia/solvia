<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solvia Dashboard - SEO on AI Autopilot</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css?v=1.2">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
    .ai-analysis-header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
    }
    .ai-header-actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    .status-indicator {
        display: inline-block;
        padding: 0.15em 0.8em;
        font-size: 0.85rem;
        font-weight: 600;
        border-radius: 999px;
        background: #10b981;
        color: #fff;
        margin-right: 0.5rem;
        min-width: 0;
        width: auto;
        text-align: center;
        white-space: nowrap;
    }
    .btn-refresh {
        border-radius: 999px !important;
        padding: 0.5em 1.5em !important;
        font-size: 1rem;
        border: none;
        background: #fff;
        color: #10b981;
        font-weight: 600;
        box-shadow: 0 0 0 1px #10b981 inset;
        transition: background 0.2s, color 0.2s;
        cursor: pointer;
        margin: 0;
    }
    .btn-refresh:hover, .btn-refresh:focus {
        background: #10b981;
        color: #fff;
    }
    @media (max-width: 600px) {
        .ai-analysis-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
        }
        .ai-header-actions {
            flex-direction: column;
            align-items: stretch;
            width: 100%;
            gap: 0.5rem;
        }
        .ai-header-actions .btn-refresh {
            width: 100%;
            font-size: 1rem;
            padding: 0.5rem 0;
        }
        .ai-header-actions .status-indicator {
            margin-bottom: 0.25rem;
            margin-right: 0;
        }
    }
    .header-left {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .header-icon {
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .header-right {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .icon-btn {
        background: #fff;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 0 0 1px #10b981 inset;
        transition: background 0.2s;
        padding: 0;
    }
    .icon-btn:hover, .icon-btn:focus {
        background: #10b981;
    }
    .icon-btn svg {
        stroke: #10b981;
        transition: stroke 0.2s;
    }
    .icon-btn:hover svg, .icon-btn:focus svg {
        stroke: #fff;
    }
    .refresh-metrics-btn {
        background: #f3f4f6;
        box-shadow: 0 0 0 1px #d1d5db inset;
    }
    .refresh-metrics-btn svg {
        stroke: #6B7280;
        transition: stroke 0.2s;
    }
    .refresh-metrics-btn:hover, .refresh-metrics-btn:focus {
        background: #f59e42;
    }
    .refresh-metrics-btn:hover svg, .refresh-metrics-btn:focus svg {
        stroke: #fff;
    }
    .four-col-header {
        display: grid;
        grid-template-columns: auto 1fr auto auto;
        align-items: center;
        gap: 0.5rem;
        padding: 0 1rem;
    }
    .header-icon {
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .header-title {
        font-size: 1.15rem;
        font-weight: 600;
        margin: 0;
        white-space: nowrap;
    }
    .card-header {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 0.5rem;
        padding: 0 1rem;
        min-width: 0;
    }
    .header-icon {
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .header-title {
        font-size: 1.15rem;
        font-weight: 600;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .status-indicator {
        white-space: nowrap;
        margin-left: auto;
    }
    </style>
</head>
<body class="dashboard-body">
    <nav class="navbar">
        <div class="navbar-brand">Solvia</div>
        <div class="navbar-user">
            <div class="user-avatar" id="userAvatar" onclick="toggleMobileMenu()">S</div>
            <span id="userEmail" class="desktop-only">user@example.com</span>
            <button class="logout-btn desktop-only" onclick="logout()">Logout</button>
        </div>
    </nav>

    <!-- Mobile Side Menu -->
    <div id="mobileMenuOverlay" class="mobile-menu-overlay" onclick="closeMobileMenu()"></div>
    <div id="mobileMenu" class="mobile-menu">
        <div class="mobile-menu-header">
            <div class="mobile-menu-avatar" id="mobileMenuAvatar">S</div>
            <div class="mobile-menu-user-info">
                <div class="mobile-menu-email" id="mobileMenuEmail">user@example.com</div>
                <div class="mobile-menu-website" id="mobileMenuWebsite">No website selected</div>
            </div>
            <button class="mobile-menu-close" onclick="closeMobileMenu()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="mobile-menu-content">
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Navigation</div>
                <button class="mobile-menu-item active" onclick="closeMobileMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="14" y="14" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                    </svg>
                    <span>Dashboard</span>
                </button>
                <button class="mobile-menu-item" onclick="window.location.href='/fixes'; closeMobileMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                    </svg>
                    <span>SEO Fixes</span>
                </button>
            </div>
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Website</div>
                <button class="mobile-menu-item" onclick="changeWebsite(); closeMobileMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                    </svg>
                    <span>Change Website</span>
                </button>
            </div>
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Account</div>
                <button class="mobile-menu-item" onclick="logout()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                        <polyline points="16,17 21,12 16,7"></polyline>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                    <span>Logout</span>
                </button>
            </div>
        </div>
    </div>

    <div class="container dashboard-container">
        <!-- GSC Connection Banner -->
        <div id="gscBanner" class="gsc-banner hidden">
            <div class="banner-content">
                <div class="banner-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4.5 16.5c-1.5 1.5-1.5 4.5 0 6s4.5 1.5 6 0l10-10c1-1 1-2.5 0-3.5s-2.5-1-3.5 0l-10 10z"></path>
                        <path d="M13.5 6.5l4 4"></path>
                        <path d="M12 2l2 2-2 2-2-2 2-2z"></path>
                    </svg>
                </div>
                <div class="banner-text">
                    <h3>Connect Google Search Console</h3>
                    <p>Get real SEO data for your dashboard by connecting your Google Search Console account.</p>
                </div>
                <div class="banner-actions">
                    <button onclick="connectGSC()" class="btn-connect">Connect GSC</button>
                </div>
            </div>
        </div>

        <div class="dashboard-header">
            <div class="dashboard-title-row">
                <h1>Your Dashboard</h1>
                <button onclick="refreshMetrics()" class="icon-btn refresh-metrics-btn" id="refreshBtn" title="Refresh Data" aria-label="Refresh Data">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#6B7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                </button>
            </div>
            <div>
                <div id="dateRangeInfo" class="date-range-info hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                    <span id="dateRange"></span>
                </div>
                <div id="websiteInfo" class="website-info hidden">
                    <span>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-icon">
                            <line x1="18" y1="20" x2="18" y2="10"></line>
                            <line x1="12" y1="20" x2="12" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="14"></line>
                        </svg>
                        Tracking: 
                    </span>
                    <span id="trackedWebsite" class="tracked-website"></span>
                </div>
            </div>
        </div>

        <div class="stats-grid">
            <!-- Score Card -->
            <div class="stat-card overall-score">
                <div class="score-header">
                    <h3>Score</h3>
                    <div class="score-badge" id="seoScore">0</div>
            </div>
                <div class="score-change" id="seoScoreChange">+0%</div>
                <div class="score-description">Based on all metrics</div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="charts-section" id="mergedChartsSection">
            <div class="content-card">
                <div class="card-header">
                    <h2>Organic Traffic & Impressions</h2>
                </div>
                <div class="card-body">
                    <canvas id="mergedTrendsChart" height="300"></canvas>
                </div>
            </div>
        </div>

        <div class="analysis-grid">
            <!-- Visibility Performance Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="20" x2="18" y2="10"></line>
                            <line x1="12" y1="20" x2="12" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="14"></line>
                        </svg>
                    </div>
                    <h2>Visibility Performance</h2>
                    <div class="status-indicator" id="visibilityStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Impressions</span>
                            <span class="metric-value" id="impressionsValue">0</span>
                            <span class="metric-change" id="impressionsChange">+0</span>
                            <div class="metric-ai-analysis" id="impressionsAnalysis" style="display: none; margin-top: 8px; font-size: 0.875rem; color: #6B7280; line-height: 1.4;"></div>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Clicks</span>
                            <span class="metric-value" id="clicksValue">0</span>
                            <span class="metric-change" id="clicksChange">+0</span>
                            <div class="metric-ai-analysis" id="clicksAnalysis" style="display: none; margin-top: 8px; font-size: 0.875rem; color: #6B7280; line-height: 1.4;"></div>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">CTR</span>
                            <span class="metric-value" id="ctrValue">0%</span>
                            <span class="metric-change" id="ctrChange">+0%</span>
                            <div class="metric-ai-analysis" id="ctrAnalysis" style="display: none; margin-top: 8px; font-size: 0.875rem; color: #6B7280; line-height: 1.4;"></div>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Avg Position</span>
                            <span class="metric-value" id="avgPositionValue">N/A</span>
                            <span class="metric-change" id="avgPositionChange">+0.0</span>
                            <div class="metric-ai-analysis" id="avgPositionAnalysis" style="display: none; margin-top: 8px; font-size: 0.875rem; color: #6B7280; line-height: 1.4;"></div>
                        </div>
                    </div>
                    <!-- Individual metric AI analyses are now displayed below each metric -->
            </div>
        </div>










                    </div>
                </div>
            </div>
            
        <!-- AI Overall Analysis Section -->
        <div class="analysis-card" id="aiOverallAnalysisCard">
            <div class="card-header">
                <span class="header-icon">
                    <!-- Simple robot/AI SVG icon -->
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#111827" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="4"/><rect x="7" y="7" width="10" height="4" rx="2"/><circle cx="8.5" cy="16" r="1.5"/><circle cx="15.5" cy="16" r="1.5"/><line x1="12" y1="2" x2="12" y2="7"/></svg>
                </span>
                <h2 class="header-title">AI Overall Analysis</h2>
                <div class="status-indicator" id="aiOverallStatus">ANALYZING</div>
                <button id="regenerateAIButton" class="icon-btn" title="Regenerate AI Analysis" aria-label="Regenerate AI Analysis">
                    <span class="regen-btn-content">
                        <svg class="regen-btn-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#6B7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                        <span class="regen-btn-spinner loading-spinner" style="display:none"></span>
                    </span>
                </button>
            </div>
            <div class="card-body">
                <div class="ai-overall-summary" id="aiOverallSummary"></div>
            </div>
        </div>

        <div id="metricsPopupContainer">
            <div id="metricsSuccessPopup">
                All metrics loaded successfully! <span id="metricsSuccessTimer" class="timer"></span>
                    </div>
            <div id="metricsLoadingPopup">
                <div id="metricsLoadingList"></div>
            </div>
        <div id="cacheLoadingPopup" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(255,255,255,0.85);z-index:9999;align-items:center;justify-content:center;font-size:1.5rem;color:#F97316;font-weight:500;">
            <div style="display:flex;flex-direction:column;align-items:center;gap:1rem;">
                <span class="metric-loading-spinner"><svg width='36' height='36' viewBox='0 0 50 50'><circle cx='25' cy='25' r='20' fill='none' stroke='#F97316' stroke-width='5' stroke-linecap='round' stroke-dasharray='31.4 31.4' stroke-dashoffset='0'><animateTransform attributeName='transform' type='rotate' from='0 25 25' to='360 25 25' dur='0.8s' repeatCount='indefinite'/></circle></svg></span>
                Loading dashboard cache...
            </div>
        </div>
        </div>

        <div id="aiAnalysisPopupContainer" style="display:none;position:fixed;right:24px;bottom:24px;z-index:9999;display:flex;flex-direction:column;align-items:flex-end;gap:12px;">
            <div id="aiAnalysisLoadingPopup" style="transition:transform 0.5s cubic-bezier(0.4,0,0.2,1),opacity 0.5s cubic-bezier(0.4,0,0.2,1);transform:translateX(120%);opacity:0;min-width:260px;max-width:320px;background:#FFF7ED;border-radius:12px;box-shadow:0 4px 16px rgba(0,0,0,0.12);padding:1.25rem 1.5rem;display:none;flex-direction:column;gap:0.75rem;margin:0;position:static;border:1px solid #FED7AA;">
                <div id="aiAnalysisLoadingList">
                    <div style="color:#F97316;font-weight:500;font-size:1.2rem;margin-bottom:0.5em;">Generating AI Analysis...</div>
                    <ul style="margin:0;padding:0;list-style:none;text-align:left;font-size:1rem;max-width:400px;color:#F97316;">
                        <li>1. Using existing dashboard data</li>
                        <li>2. Analyzing performance metrics</li>
                        <li>3. Generating AI insights</li>
                        <li>4. Creating analysis summary</li>
                        <li>5. Updating dashboard</li>
                    </ul>
                </div>
            </div>
        </div>

        <script>
            // Global chart instances
            let organicTrafficChart = null;
            let impressionsChart = null;
            let isRefreshingToken = false; // Flag to prevent multiple refresh attempts
            
            // Global variables for metric data
            window.metricsData = {
                summary: {}
            };
            let refreshAttempts = 0; // Track refresh attempts to prevent infinite loops
            const MAX_REFRESH_ATTEMPTS = 3; // Maximum number of refresh attempts
            let lastRefreshTime = 0; // Track when we last attempted a refresh
            let isRedirecting = false; // Flag to prevent multiple redirects
            let consecutiveFailures = 0; // Track consecutive API failures
            
            const METRIC_GROUPS = [
              { key: 'organic_impressions', label: 'Organic Traffic & Impressions' },
              { key: 'visibility', label: 'Visibility Performance' },
              { key: 'ai', label: 'AI Analysis' }
            ];
            let metricsLoadingState = {};
            
            // Check if we're in an infinite loop situation
            function checkForInfiniteLoop() {
                if (consecutiveFailures > 5) {
                    clearInvalidToken();
                    return true;
                }
                return false;
            }
            
            function isValidTokenFormat(token) {
                if (!token || typeof token !== 'string') {
                    return false;
                }
                
                // Check if token has the correct JWT format (3 parts separated by dots)
                const parts = token.split('.');
                
                if (parts.length !== 3) {
                    return false;
                }
                
                // Try to decode the payload to check if it's valid JSON
                try {
                    const payload = JSON.parse(atob(parts[1]));
                    
                    // Check for required fields
                    if (!payload || typeof payload !== 'object') {
                        return false;
                    }
                    
                    // Check for required JWT fields
                    if (!payload.sub) {
                        return false;
                    }
                    
                    if (!payload.exp) {
                        return false;
                    }
                    
                    // Check expiration
                    const currentTime = Math.floor(Date.now() / 1000);
                    const isExpired = payload.exp < currentTime;
                    
                    return true;
                } catch (error) {
                    return false;
                }
            }
            
            function clearInvalidToken() {
                const oldToken = localStorage.getItem('auth_token');
                localStorage.removeItem('auth_token');
                if (!isRedirecting) {
                    isRedirecting = true;
                    window.location.href = '/ui';
                }
            }
            
            function checkAuth() {
                const token = localStorage.getItem('auth_token');
                
                if (!token) {
                    if (!isRedirecting) {
                        isRedirecting = true;
                    window.location.href = '/ui';
                    }
                    return false;
                }

                // First, validate token format
                if (!isValidTokenFormat(token)) {
                    clearInvalidToken();
                    return false;
                }

                try {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    const userEmail = payload.email || payload.sub || 'user@example.com';
                    const userName = userEmail.includes('@') ? userEmail.split('@')[0] : userEmail;
                    
                    // Check if token is expired
                    const currentTime = Math.floor(Date.now() / 1000);
                    const timeSinceLastRefresh = currentTime - lastRefreshTime;
                    
                    if (payload.exp && payload.exp < currentTime) {
                        
                        // Prevent rapid refresh attempts - wait at least 5 seconds between attempts
                        if (timeSinceLastRefresh < 5) {
                            if (!isRedirecting) {
                                isRedirecting = true;
                                window.location.href = '/ui';
                            }
                            return false;
                        }
                        
                        if (!isRefreshingToken && refreshAttempts < MAX_REFRESH_ATTEMPTS) {
                            lastRefreshTime = currentTime;
                            refreshToken();
                        } else {
                            if (!isRedirecting) {
                                isRedirecting = true;
                                window.location.href = '/ui';
                            }
                        }
                        return false;
                    }
                    
                    document.getElementById('userEmail').textContent = userEmail;
                    document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                    
                    // Update mobile menu user info
                    document.getElementById('mobileMenuEmail').textContent = userEmail;
                    document.getElementById('mobileMenuAvatar').textContent = userName.charAt(0).toUpperCase();
                    
                    return true; // Authentication successful
                } catch (error) {
                    console.error('[TOKEN DEBUG] Error decoding token:', error);
                    clearInvalidToken();
                    return false; // Authentication failed
                }
            }

            async function refreshToken() {
                if (isRefreshingToken) {
                    console.log('Token refresh already in progress, skipping...');
                    return;
                }
                
                if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
                    console.log('Max refresh attempts reached, redirecting to login');
                    if (!isRedirecting) {
                        isRedirecting = true;
                    window.location.href = '/ui';
                    }
                    return;
                }
                
                isRefreshingToken = true;
                refreshAttempts++;
                
                try {
                    const token = localStorage.getItem('auth_token');
                    
                    // Validate token format before attempting refresh
                    if (!isValidTokenFormat(token)) {
                        console.log('Invalid token format in refreshToken, clearing token');
                        clearInvalidToken();
                        return;
                    }
                    
                    const response = await fetch('/auth/refresh-token', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        localStorage.setItem('auth_token', data.access_token);
                        refreshAttempts = 0; // Reset attempts on success
                        lastRefreshTime = 0; // Reset last refresh time
                        
                        // Verify the new token is not expired
                        try {
                            const newPayload = JSON.parse(atob(data.access_token.split('.')[1]));
                            const currentTime = Math.floor(Date.now() / 1000);
                            
                            if (newPayload.exp && newPayload.exp < currentTime) {
                                console.log('New token is also expired, redirecting to login');
                                if (!isRedirecting) {
                                    isRedirecting = true;
                                    window.location.href = '/ui';
                                }
                                return;
                            }
                            
                            // Update UI with the user info from the new token
                            const userEmail = newPayload.email || newPayload.sub || 'user@example.com';
                            const userName = userEmail.includes('@') ? userEmail.split('@')[0] : userEmail;
                            
                            document.getElementById('userEmail').textContent = userEmail;
                            document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                            document.getElementById('mobileMenuEmail').textContent = userEmail;
                            document.getElementById('mobileMenuAvatar').textContent = userName.charAt(0).toUpperCase();
                        } catch (error) {
                            console.error('Error updating UI after token refresh:', error);
                        }
                    } else {
                        console.error('Failed to refresh token');
                        clearInvalidToken();
                    }
                } catch (error) {
                    console.error('Error refreshing token:', error);
                    clearInvalidToken();
                } finally {
                    isRefreshingToken = false;
                }
            }

            async function apiCall(url, options = {}) {
                const token = localStorage.getItem('auth_token');
                if (!token) {
                    if (!isRedirecting) {
                        isRedirecting = true;
                        window.location.href = '/ui';
                    }
                    return;
                }

                // Validate token format before making API calls
                if (!isValidTokenFormat(token)) {
                    console.log('[TOKEN DEBUG] Invalid token format in apiCall, clearing token');
                    clearInvalidToken();
                    return;
                }

                // Check for infinite loop before making the call
                if (checkForInfiniteLoop()) {
                    return;
                }

                // Add authorization header
                options.headers = {
                    'Authorization': `Bearer ${token}`,
                    ...options.headers
                };

                try {
                    const response = await fetch(url, options);
                    
                    // Reset consecutive failures on success
                    if (response.ok) {
                        consecutiveFailures = 0;
                    }
                    
                    // If token is expired, try to refresh and retry
                    if (response.status === 401) {
                        consecutiveFailures++;
                        console.log('[TOKEN DEBUG] 401 error, consecutive failures:', consecutiveFailures);
                        
                        // Check for infinite loop
                        if (checkForInfiniteLoop()) {
                            return;
                        }
                        
                        console.log('Token expired, refreshing...');
                        
                        // Prevent multiple refresh attempts
                        if (isRefreshingToken) {
                            console.log('Token refresh already in progress, redirecting to login');
                            if (!isRedirecting) {
                                isRedirecting = true;
                                window.location.href = '/ui';
                            }
                            return;
                        }
                        
                        // Check if we've exceeded max attempts
                        if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
                            console.log('Max refresh attempts reached in apiCall, redirecting to login');
                            if (!isRedirecting) {
                                isRedirecting = true;
                                window.location.href = '/ui';
                            }
                            return;
                        }
                        
                        // Check if we've tried to refresh too recently
                        const currentTime = Math.floor(Date.now() / 1000);
                        if (currentTime - lastRefreshTime < 5) {
                            console.log('Too soon since last refresh attempt, redirecting to login');
                            if (!isRedirecting) {
                                isRedirecting = true;
                                window.location.href = '/ui';
                            }
                            return;
                        }
                        
                        isRefreshingToken = true;
                        refreshAttempts++;
                        lastRefreshTime = currentTime;
                        
                        try {
                            const refreshResponse = await fetch('/auth/refresh-token', {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${token}`
                                }
                            });

                            if (refreshResponse.ok) {
                                const data = await refreshResponse.json();
                                localStorage.setItem('auth_token', data.access_token);
                                refreshAttempts = 0; // Reset on success
                                lastRefreshTime = 0; // Reset last refresh time
                                consecutiveFailures = 0; // Reset failures on successful refresh
                                
                                // Verify the new token is not expired
                                try {
                                    const newPayload = JSON.parse(atob(data.access_token.split('.')[1]));
                                    const currentTime = Math.floor(Date.now() / 1000);
                                    
                                    if (newPayload.exp && newPayload.exp < currentTime) {
                                        console.log('New token is also expired, redirecting to login');
                                        if (!isRedirecting) {
                                            isRedirecting = true;
                                            window.location.href = '/ui';
                                        }
                                        return;
                                    }
                                } catch (error) {
                                    console.error('Error verifying new token:', error);
                                    if (!isRedirecting) {
                                        isRedirecting = true;
                                        window.location.href = '/ui';
                                    }
                                    return;
                                }
                                
                                // Retry the original request with new token
                                options.headers['Authorization'] = `Bearer ${data.access_token}`;
                                return await fetch(url, options);
                            } else {
                                // Refresh failed, clear token and redirect to login
                                console.log('Token refresh failed, clearing token and redirecting to login');
                                clearInvalidToken();
                                return;
                            }
                        } finally {
                            isRefreshingToken = false;
                        }
                    }
                    
                    return response;
                } catch (error) {
                    consecutiveFailures++;
                    console.error('API call error:', error);
                    console.log('[TOKEN DEBUG] API call failed, consecutive failures:', consecutiveFailures);
                    
                    // Check for infinite loop
                    if (checkForInfiniteLoop()) {
                        return;
                    }
                    
                    throw error;
                }
            }

            function logout() {
                localStorage.removeItem('auth_token');
                window.location.href = '/ui';
            }

            function generateLast30DaysData() {
                const dates = [];
                for (let i = 29; i >= 0; i--) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    dates.push(`Day ${30 - i}`);
                }
                return dates;
            }

            function createMergedTrendsChart(metrics) {
                
                const rootStyles = getComputedStyle(document.documentElement);
                const primaryColor = rootStyles.getPropertyValue('--color-primary').trim();
                const secondaryColor = '#6366F1'; // Indigo for impressions
                const timeSeries = metrics.time_series || {};
                const dates = timeSeries.dates || [];
                const clicksData = timeSeries.clicks || [];
                const impressionsData = timeSeries.impressions || [];

                // Generate complete 30-day date range including missing dates with zero values
                let completeDates = [];
                let completeClicksData = [];
                let completeImpressionsData = [];

                if (dates.length > 0) {
                    // Get the first and last dates from the data
                    const firstDate = new Date(dates[0]);
                    const lastDate = new Date(dates[dates.length - 1]);
                    
                    // Create a map of existing data for quick lookup
                    const dataMap = {};
                    dates.forEach((dateStr, index) => {
                        dataMap[dateStr] = {
                            clicks: clicksData[index] || 0,
                            impressions: impressionsData[index] || 0
                        };
                    });
                    
                    // Generate all dates in the 30-day range
                    const currentDate = new Date(firstDate);
                    while (currentDate <= lastDate) {
                        const dateStr = currentDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                        completeDates.push(dateStr);
                        
                        if (dataMap[dateStr]) {
                            // Use real data if available
                            completeClicksData.push(dataMap[dateStr].clicks);
                            completeImpressionsData.push(dataMap[dateStr].impressions);
                        } else {
                            // Missing dates get zero values
                            completeClicksData.push(0);
                            completeImpressionsData.push(0);
                        }
                        
                        // Move to next day
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                }

                // Use complete data if available, otherwise fall back to original data
                const finalDates = completeDates.length > 0 ? completeDates : dates;
                const finalClicksData = completeClicksData.length > 0 ? completeClicksData : clicksData;
                const finalImpressionsData = completeImpressionsData.length > 0 ? completeImpressionsData : impressionsData;

                // Format dates to readable format like "1 Jun 2025"
                const formattedDates = finalDates.map(dateStr => {
                    const date = new Date(dateStr);
                    const day = date.getDate();
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const month = monthNames[date.getMonth()];
                    const year = date.getFullYear();
                    return `${day} ${month} ${year}`;
                });

                if (window.mergedTrendsChart && typeof window.mergedTrendsChart.destroy === 'function') {
                    window.mergedTrendsChart.destroy();
                }

                const ctx = document.getElementById('mergedTrendsChart').getContext('2d');
                window.mergedTrendsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: formattedDates,
                        datasets: [
                            {
                                label: 'Clicks',
                                data: finalClicksData,
                                borderColor: primaryColor,
                                backgroundColor: 'rgba(249, 115, 22, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.4
                            },
                            {
                                label: 'Impressions',
                                data: finalImpressionsData,
                                borderColor: secondaryColor,
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.4
                            }
                        ]
                    },
                    options: {
                    responsive: true,
                    maintainAspectRatio: false,
                        plugins: { legend: { display: true } },
                    scales: {
                        y: { beginAtZero: true, grid: { color: 'rgba(0, 0, 0, 0.05)' } },
                        x: { grid: { display: false }, ticks: {
                            callback: function(value, index, values) {
                                const label = this.getLabelForValue(value);
                                // Show first, middle, and last dates for better readability
                                if (label === formattedDates[0] || label === formattedDates[Math.floor(formattedDates.length/2)] || label === formattedDates[formattedDates.length-1]) {
                                    return label;
                                }
                                return null;
                            }
                        } }
                        }
                    }
                });
            }

            function updateDashboardMetrics(hasGSC = false) {
                if (hasGSC) {
                    // Update overall score
                    document.getElementById('seoScore').textContent = '65';
                    document.getElementById('seoScoreChange').textContent = '+5%';
                    document.getElementById('seoScoreChange').className = 'score-change positive';

                    // Update visibility performance
                    document.getElementById('impressionsValue').textContent = '0';
                    document.getElementById('clicksValue').textContent = '0';
                    document.getElementById('ctrValue').textContent = '0.0%';
                    document.getElementById('ctrChange').textContent = '+0.0%';
                    document.getElementById('ctrChange').className = 'metric-change positive';
                    document.getElementById('avgPositionValue').textContent = '0.0';
                    document.getElementById('avgPositionChange').textContent = '+0.0';
                    document.getElementById('avgPositionChange').className = 'metric-change positive';
                    document.getElementById('visibilityInsights').innerHTML = '<p>Visiblity metrics will appear when connected</p>';



                } else {
                    // Reset all metrics to empty state
                    document.getElementById('seoScore').textContent = '0';
                    document.getElementById('seoScoreChange').textContent = '+0%';
                    
                    // Reset visibility performance
                    document.getElementById('impressionsValue').textContent = '0';
                    document.getElementById('clicksValue').textContent = '0';
                    document.getElementById('ctrValue').textContent = '0%';
                    document.getElementById('ctrChange').textContent = '+0%';
                    document.getElementById('avgPositionValue').textContent = 'N/A';
                    document.getElementById('avgPositionChange').textContent = '+0.0';
                    document.getElementById('visibilityInsights').innerHTML = '<p>Connect Google Search Console to see visibility insights</p>';



                }
            }

            function showErrorMessage(message) {
                // Create or update error banner
                let errorBanner = document.getElementById('errorBanner');
                if (!errorBanner) {
                    errorBanner = document.createElement('div');
                    errorBanner.id = 'errorBanner';
                    errorBanner.className = 'error-banner';
                    errorBanner.innerHTML = `
                        <div class="banner-content">
                            <div class="banner-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="15" y1="9" x2="9" y2="15"></line>
                                    <line x1="9" y1="9" x2="15" y2="15"></line>
                                </svg>
                            </div>
                            <div class="banner-text">
                                <h3>Data Loading Error</h3>
                                <p id="errorMessage">${message}</p>
                            </div>
                            <div class="banner-actions">
                                <button onclick="hideErrorMessage()" class="btn-dismiss">Dismiss</button>
                                <button onclick="location.reload()" class="btn-retry">Retry</button>
                            </div>
                        </div>
                    `;
                    
                    // Insert after GSC banner
                    const gscBanner = document.getElementById('gscBanner');
                    if (gscBanner && gscBanner.nextSibling) {
                        gscBanner.parentNode.insertBefore(errorBanner, gscBanner.nextSibling);
                    } else {
                        document.querySelector('.dashboard-container').insertBefore(errorBanner, document.querySelector('.dashboard-header'));
                    }
                } else {
                    document.getElementById('errorMessage').textContent = message;
                }
                
                errorBanner.classList.remove('hidden');
            }

            function hideErrorMessage() {
                const errorBanner = document.getElementById('errorBanner');
                if (errorBanner) {
                    errorBanner.classList.add('hidden');
                }
            }

            async function updateDashboardMetricsWithRealData(metrics) {
                
                // Validate input data
                if (!metrics) {
                    console.error('[ERROR] No metrics data provided to updateDashboardMetricsWithRealData');
                    return;
                }
                
                const summary = metrics.summary || {};
                
                // Validate summary data structure
                if (Object.keys(summary).length === 0) {
                    console.warn('[WARNING] Empty summary data received');
                }
                
                // Store summary data globally
                window.metricsData = window.metricsData || {};
                window.metricsData.summary = summary;
                
                // Extract individual values with detailed logging
                const impressionsValue = summary.total_impressions;
                const clicksValue = summary.total_clicks;
                const ctrValue = summary.avg_ctr;
                const positionValue = summary.avg_position;
                
                // Calculate SEO score based on real metrics with fallback
                let seoScore = 0;
                try {
                    seoScore = calculateSEOScore(summary);
                    if (isNaN(seoScore) || seoScore < 0 || seoScore > 100) {
                        console.warn('[WARNING] Invalid SEO score calculated:', seoScore, 'using fallback');
                        seoScore = 0;
                    }
                } catch (error) {
                    console.error('[ERROR] Failed to calculate SEO score:', error);
                    seoScore = 0;
                }
                
                // Calculate SEO score change using backend-provided 30-day comparison
                const seoScoreChange = summary.seo_score_change !== undefined ? summary.seo_score_change : 0;
                
                // Update overall score with validation
                const seoScoreElement = document.getElementById('seoScore');
                if (seoScoreElement) {
                    seoScoreElement.textContent = seoScore;
                } else {
                    console.error('[ERROR] seoScore element not found');
                }
                updateSEOScoreChange(seoScoreChange);

                // Safely update DOM elements with extensive logging
                const elements = {
                    'impressionsValue': (impressionsValue || 0).toLocaleString(),
                    'clicksValue': (clicksValue || 0).toLocaleString(),
                    'ctrValue': `${((ctrValue || 0) * 100).toFixed(2)}%`,
                    'avgPositionValue': positionValue > 0 ? positionValue.toFixed(1) : 'N/A'
                };
                
                
                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = value;
                    } else {
                        console.error(`[ERROR] Element not found: ${id}`);
                    }
                });
                
                // Also check if the elements are visible
                Object.keys(elements).forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        const style = window.getComputedStyle(element);
                    }
                });
                
                // Update change indicators - all use backend-provided 30-day comparisons
                const impressionsChange = summary.impressions_change !== undefined ? summary.impressions_change : 0;
                const clicksChange = summary.clicks_change !== undefined ? summary.clicks_change : 0;
                const ctrChange = summary.ctr_change !== undefined ? summary.ctr_change : 0;
                const positionChange = summary.position_change !== undefined ? summary.position_change : 0;
                
                updateChangeIndicator('impressionsChange', impressionsChange, '', true);
                updateChangeIndicator('clicksChange', clicksChange, '', true);
                updateChangeIndicator('ctrChange', ctrChange, '%', true);
                updateChangeIndicator('avgPositionChange', positionChange, '', false);
                
                // Generate insights based on real data
                try {
                    await generateVisibilityInsights(summary);
                    setMetricLoadingState('ai', 'done');
                } catch (error) {
                    console.error('[ERROR] Failed to generate insights:', error);
                }
            }

            // 30-day comparison is now handled by the backend
            // All growth indicators compare today's data vs exactly 30 days ago

            function calculateChange(metricKey, currentValue) {
                // This function is now only used as a fallback when backend doesn't provide comparison data
                return 0; // Default to no change when backend comparison is unavailable
            }

            function updateChangeIndicator(elementId, value, unit = '', higherIsBetter = true) {
                const element = document.getElementById(elementId);
                if (value === undefined || value === null) {
                    element.textContent = 'N/A';
                    element.className = 'metric-change neutral';
                    element.style.color = '#6B7280'; // Grey for N/A
                    return;
                }

                // Handle loading state
                if (value === 'loading' || value === '...') {
                    element.textContent = '...';
                    element.className = 'metric-change neutral';
                    element.style.color = '#6B7280'; // Grey for loading
                    return;
                }

                // Handle categorical changes (business type, target market)
                if (elementId.includes('businessType') || elementId.includes('targetMarket')) {
                    let class_name = 'metric-change';
                    let displayText = '';
                    if (value === 0) {
                        class_name += ' neutral';
                        displayText = 'No Change';
                        element.style.color = '#6B7280'; // Grey for no change
                    } else {
                        class_name += ' positive'; // Show changes as positive (informational)
                        displayText = 'Updated';
                        element.style.color = ''; // Reset to CSS default
                    }
                    element.className = class_name;
                    element.textContent = displayText;
                    return;
                }

                const isPositive = higherIsBetter ? value > 0 : value < 0;
                const isNegative = higherIsBetter ? value < 0 : value > 0;
                const isZero = value === 0 || Math.abs(value) < 0.001; // Consider very small values as zero
                
                let class_name = 'metric-change';
                if (isZero) {
                    class_name += ' neutral';
                    element.style.color = '#6B7280'; // Grey for zero/no change
                } else if (isPositive) {
                    class_name += ' positive';
                    element.style.color = ''; // Reset to CSS default
                } else if (isNegative) {
                    class_name += ' negative';
                    element.style.color = ''; // Reset to CSS default
                }

                element.className = class_name;
                
                // Format the display value
                let displayText;
                if (isZero) {
                    displayText = unit === '%' ? '0%' : '0';
                } else {
                    const prefix = value > 0 ? '+' : '';
                const formattedValue = unit === '%' ? (value * 100).toFixed(2) : value.toFixed(1);
                    displayText = `${prefix}${formattedValue}${unit}`;
                }
                
                element.textContent = displayText;
            }

            function updateSEOScoreChange(change) {
                const element = document.getElementById('seoScoreChange');
                if (change === undefined || change === null) {
                    element.textContent = 'N/A';
                    element.className = 'score-change';
                    return;
                }

                const isPositive = change > 0;
                const isNegative = change < 0;
                const isZero = change === 0 || Math.abs(change) < 0.001; // Consider very small values as zero
                
                let class_name = 'score-change';
                if (isZero) {
                    class_name += ' neutral';
                    element.style.color = '#6B7280'; // Grey for no change
                } else if (isPositive) {
                    class_name += ' positive';
                    element.style.color = ''; // Reset to CSS default (green)
                } else if (isNegative) {
                    class_name += ' negative';
                    element.style.color = ''; // Reset to CSS default (red)
                }

                element.className = class_name;
                
                // Format the display value
                let displayText;
                if (isZero) {
                    displayText = '0';
                } else {
                    const prefix = change > 0 ? '+' : '';
                    displayText = `${prefix}${change}`;
                }
                element.textContent = displayText;
            }

            // Global variable to store AI insights
            let cachedAIInsights = null;

            async function fetchAIInsights() {
                try {
                    // First try to get cached AI insights
                    const response = await apiCall('/auth/benchmark/insights');
                    if (response.ok) {
                        const insights = await response.json();
                        // Update both local and global cache
                        cachedAIInsights = insights;
                        window.cachedAIInsights = insights;
                        console.log('[DEBUG] Cached AI insights loaded successfully');
                        return insights;
                    } else {
                        console.log('[DEBUG] No cached AI insights found, generating fresh insights...');
                        // No cache found - automatically generate fresh AI insights
                        const freshResponse = await apiCall('/auth/benchmark/insights?explicit_ai=true');
                        if (freshResponse.ok) {
                            const insights = await freshResponse.json();
                            // Update both local and global cache
                            cachedAIInsights = insights;
                            window.cachedAIInsights = insights;
                            console.log('[DEBUG] Fresh AI insights generated and cached successfully');
                            return insights;
                        } else {
                            console.log('[DEBUG] Failed to generate fresh AI insights:', freshResponse.status);
                            return null;
                        }
                    }
                } catch (error) {
                    console.error('[DEBUG] Error fetching AI insights:', error);
                    return null;
                }
            }

            async function fetchExplicitAIInsights() {
                try {
                    // Explicitly generate fresh AI insights
                    const response = await apiCall('/auth/benchmark/insights?explicit_ai=true');
                    if (response.ok) {
                        const insights = await response.json();
                        // Update both local and global cache
                        cachedAIInsights = insights;
                        window.cachedAIInsights = insights;
                        console.log('[DEBUG] AI insights cached successfully');
                        return insights;
                    } else {
                        console.log('[DEBUG] AI insights API returned error:', response.status);
                        const errorText = await response.text();
                        console.log('[DEBUG] Error details:', errorText);
                        return null;
                    }
                } catch (error) {
                    console.error('[DEBUG] Error fetching AI insights:', error);
                    return null;
                }
            }

            async function generateVisibilityInsights(summary) {
                try {
                    // Use cached insights if available, otherwise fetch
                    const insights = cachedAIInsights || await fetchAIInsights();
                    window.lastInsights = insights;
                    
                    if (insights && insights.visibility_performance && insights.visibility_performance.metrics) {
                        // Update individual metric analyses
                        Object.entries(insights.visibility_performance.metrics).forEach(([metric, data]) => {
                            console.log(`[DEBUG] Metric ${metric}:`, data);
                            console.log(`[DEBUG] Metric ${metric} analysis:`, data.analysis);
                            
                            let analysis = '';
                            // Handle different possible data structures
                            if (typeof data === 'string') {
                                analysis = data;
                            } else if (data && typeof data === 'object') {
                                // Check if analysis is an object with text content
                                if (data.analysis && typeof data.analysis === 'object') {
                                    // Create a meaningful summary from the analysis object
                                    const analysisObj = data.analysis;
                                    const parts = [];
                                    
                                    if (analysisObj.current_performance) {
                                        parts.push(`${analysisObj.current_performance} performance`);
                                    }
                                    if (analysisObj.root_cause) {
                                        parts.push(analysisObj.root_cause);
                                    }
                                    if (analysisObj.industry_context) {
                                        parts.push(analysisObj.industry_context);
                                    }
                                    
                                    // Clean up any double periods and ensure proper formatting
                                    analysis = parts.join('. ').replace(/\.\.+/g, '.').replace(/\.\s*\./g, '. ').trim();
                                } else {
                                    // Try different possible field names
                                    analysis = data.analysis || data.summary || data.assessment || data.description || data.value || JSON.stringify(data);
                                }
                            }
                            
                            // Map metric names to element IDs
                            const metricElementMap = {
                                'impressions': 'impressionsAnalysis',
                                'clicks': 'clicksAnalysis',
                                'ctr': 'ctrAnalysis',
                                'average_position': 'avgPositionAnalysis'
                            };
                            
                            const elementId = metricElementMap[metric];
                            if (elementId && analysis) {
                                const element = document.getElementById(elementId);
                                if (element) {
                                    element.textContent = analysis;
                                    element.style.display = 'block';
                                }
                            }
                        });
                        
                        renderAIOverallAnalysis(insights);
                    } else {
                        console.log('[ERROR] No visibility insights available');
                    }
                } catch (error) {
                    console.error('Error generating visibility insights:', error);
                }
            }

















            // Mobile Menu Functions
            function toggleMobileMenu() {
                updateUserMenuInfo();
                const menu = document.getElementById('mobileMenu');
                const overlay = document.getElementById('mobileMenuOverlay');
                
                if (menu.classList.contains('active')) {
                    closeMobileMenu();
                } else {
                    openMobileMenu();
                }
            }

            function openMobileMenu() {
                const menu = document.getElementById('mobileMenu');
                const overlay = document.getElementById('mobileMenuOverlay');
                
                menu.classList.add('active');
                overlay.classList.add('active');
                
                // Prevent body scroll when menu is open
                document.body.style.overflow = 'hidden';
            }

            function closeMobileMenu() {
                const menu = document.getElementById('mobileMenu');
                const overlay = document.getElementById('mobileMenuOverlay');
                
                menu.classList.remove('active');
                overlay.classList.remove('active');
                
                // Restore body scroll
                document.body.style.overflow = '';
            }

            // Close menu on escape key
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    closeMobileMenu();
                }
            });

            async function initDashboard() {
                checkAuth();
                handleOAuthCallback();

                // Check GSC connection status
                await checkGSCConnection();

                // Try to load cached data for today
                const hasCachedData = await loadCachedDashboardData();

                if (!hasCachedData) {
                    // No cache for today - automatically refresh metrics and AI insights
                    console.log('[DEBUG] No cache found for today, automatically refreshing metrics and AI insights...');
                    showCacheStatus('No cached data for today - refreshing metrics and AI insights...', 'info');
                    
                    try {
                        // Load fresh metrics
                        await loadRealMetrics();
                        
                        // Generate fresh AI insights
                        console.log('[DEBUG] Generating fresh AI insights...');
                        const aiInsights = await fetchAIInsights();
                        
                        // Cache the fresh data including AI insights
                        await cacheDashboardData();
                        
                        showCacheStatus('Fresh data and AI insights loaded and cached!', 'success');
                    } catch (error) {
                        console.error('[ERROR] Failed to load fresh data:', error);
                        showCacheStatus('Failed to load fresh data', 'warning');
                        
                        // Show empty state as fallback
                        updateDashboardMetrics(false);
                        createMergedTrendsChart({});
                    }
                }
            }

            function handleOAuthCallback() {
                const urlParams = new URLSearchParams(window.location.search);
                const oauthSuccess = urlParams.get('oauth_success');
                const oauthError = urlParams.get('oauth_error');
                
                if (oauthSuccess === 'true') {
                    // Clean up URL parameters
                    const cleanUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                } else if (oauthError === 'true') {
                    console.log('[DEBUG] OAuth error detected');
                    // Clean up URL parameters
                    const cleanUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                    
                    // Show error message
                    alert('Failed to connect to Google Search Console. Please try again.');
                }
            }



            async function checkGSCConnection() {
                try {
                    const response = await apiCall('/auth/gsc/properties');

                    if (response.status === 401) {
                        console.log('[DEBUG] Auth error (401), showing banner');
                        showGSCBanner();
                        return false;
                    }
                    
                    if (response.status === 404) {
                        const errorText = await response.text();
                        console.log('[DEBUG] 404 error response:', errorText);
                        
                        // Check if this is the specific "No Google Search Console properties found" error
                        // which indicates corrupted credentials
                        if (errorText.includes('No Google Search Console properties found')) {
                            console.log('[DEBUG] Detected corrupted GSC credentials (404 with no properties message)');
                            await handleCorruptedCredentials();
                            return false;
                        } else {
                            console.log('[DEBUG] Regular 404 error, showing banner');
                            showGSCBanner();
                            return false;
                        }
                    }
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.log('[DEBUG] GSC connection error:', errorText);
                        
                        // Check if it's a credentials issue
                        if (response.status === 500 && errorText.includes('credentials')) {
                            console.log('[DEBUG] Credentials issue, showing reauth banner');
                            showGSCBannerWithReauth();
                        } else {
                            console.log('[DEBUG] Other error, showing regular banner');
                            showGSCBanner();
                        }
                        return false;
                    }

                    const properties = await response.json();
                    
                    if (!properties || properties.length === 0) {
                        console.log('[DEBUG] No properties found, showing banner');
                        showGSCBanner();
                        return false;
                    }

                    const isDemoMode = properties.some(p => p.siteUrl.includes('example.com') || p.siteUrl.includes('demo-site.com'));
                    console.log('[DEBUG] Is demo mode:', isDemoMode);
                    
                    if (isDemoMode) {
                        console.log('[DEBUG] Demo mode detected, showing banner');
                        showGSCBanner();
                        return false;
                    }

                    // Check if a property is already selected
                    const selectedResponse = await apiCall('/auth/gsc/selected');
                    if (selectedResponse && selectedResponse.ok) {
                        const selectedProperty = await selectedResponse.json();
                        hideGSCBanner();
                        return true;
                    } else {
                        console.log('[DEBUG] No property selected yet, response status:', selectedResponse?.status);
                    }

                    // Properties available but none selected - show banner to prompt selection
                    console.log('[DEBUG] Properties available but none selected, showing banner');
                    showGSCBanner();
                    return false;
                } catch (error) {
                    console.log('[DEBUG] Exception in checkGSCConnection:', error);
                    showGSCBanner();
                    return false;
                }
            }

            async function handleCorruptedCredentials() {
                
                try {
                    // Show loading state in banner
                    const banner = document.getElementById('gscBanner');
                    const bannerText = banner.querySelector('.banner-text p');
                    if (bannerText) {
                        bannerText.textContent = 'Detected corrupted Google Search Console connection. Cleaning up...';
                    }
                    banner.classList.remove('hidden');
                    
                    // Clear the corrupted credentials
                    const clearResponse = await apiCall('/auth/gsc/clear-credentials', {
                        method: 'POST'
                    });
                    
                    if (clearResponse.ok) {
                        console.log('[DEBUG] Credentials cleared successfully. Waiting for user to reconnect.');
                        // Update banner to instruct user to click Connect GSC
                        if (bannerText) {
                            bannerText.innerHTML = 'Invalid credentials detected and cleared. Please reconnect your account.';
                        }
                        // Do NOT auto-redirect to Google OAuth
                        return;
                    } else {
                        console.error('[ERROR] Failed to clear credentials:', clearResponse.status);
                        if (bannerText) {
                            bannerText.innerHTML = 'Failed to clear corrupted credentials. <button onclick="clearCredentials()" class="btn-link">Click here to try again</button>';
                        }
                    }
                } catch (error) {
                    console.error('[ERROR] Error in handleCorruptedCredentials:', error);
                    const banner = document.getElementById('gscBanner');
                    const bannerText = banner.querySelector('.banner-text p');
                    if (bannerText) {
                        bannerText.innerHTML = 'Error cleaning up corrupted connection. <button onclick="clearCredentials()" class="btn-link">Click here to try again</button>';
                    }
                }
            }

            function showGSCBanner() {
                document.getElementById('gscBanner').classList.remove('hidden');
            }

            function hideGSCBanner() {
                document.getElementById('gscBanner').classList.add('hidden');
            }

            function showGSCBannerWithReauth() {
                const banner = document.getElementById('gscBanner');
                banner.classList.remove('hidden');
                
                // Update banner content to show re-authentication option
                const bannerText = banner.querySelector('.banner-text p');
                if (bannerText) {
                    bannerText.innerHTML = 'Your Google Search Console connection has an issue. <button onclick="clearCredentials()" class="btn-link">Click here to re-authenticate</button> or connect a new account.';
                }
            }

            async function clearCredentials() {
                try {
                    const response = await apiCall('/auth/gsc/clear-credentials', {
                        method: 'POST'
                    });

                    if (response.ok) {
                        // Redirect to Google OAuth directly, bypassing setup wizard
                        window.location.href = '/auth/google/authorize';
                    } else {
                        alert('Failed to clear credentials. Please try again.');
                    }
                } catch (error) {
                    console.error('Error clearing credentials:', error);
                    alert('Failed to clear credentials. Please try again.');
                }
            }

            async function connectGSC() {
                try {
                    
                    // IMMEDIATE LOADING INDICATOR - Show loading state instantly
                    const banner = document.getElementById('gscBanner');
                    const bannerText = banner.querySelector('.banner-text p');
                    const connectBtn = banner.querySelector('.btn-connect');
                    
                    // Show banner immediately with loading state
                    banner.classList.remove('hidden');
                    
                    // Update button to show loading
                    if (connectBtn) {
                        connectBtn.disabled = true;
                        connectBtn.innerHTML = '<span class="loading-spinner"></span> Connecting...';
                    }
                    
                    // Update text immediately
                    if (bannerText) {
                        bannerText.textContent = 'Connecting to Google Search Console...';
                    }
                    
                    // Add loading animation to banner
                    banner.classList.add('loading');
                    
                    // Small delay to ensure UI updates are visible
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Authenticated API call to get the Google OAuth URL
                    const response = await apiCall('/auth/google/authorize');
                    if (response.ok) {
                        const data = await response.json();
                        if (data.auth_url) {
                            if (bannerText) {
                                bannerText.textContent = 'Redirecting to Google OAuth...';
                            }
                            if (connectBtn) {
                                connectBtn.innerHTML = '<span class="loading-spinner"></span> Redirecting...';
                            }
                            setTimeout(() => {
                                window.location.href = data.auth_url;
                            }, 500); // Reduced delay for faster redirect
                            return;
                        }
                    }
                    // If we get here, something went wrong
                    if (bannerText) {
                        bannerText.innerHTML = 'Session expired or authentication failed. <button onclick="logout()" class="btn-link">Click here to log in again</button>';
                    }
                    if (connectBtn) {
                        connectBtn.disabled = false;
                        connectBtn.innerHTML = 'Connect GSC';
                    }
                    banner.classList.remove('loading');
                    alert('Session expired or authentication failed. Please log in again.');
                    logout();
                } catch (error) {
                    console.error('[ERROR] Error connecting to GSC:', error);
                    const banner = document.getElementById('gscBanner');
                    const bannerText = banner.querySelector('.banner-text p');
                    const connectBtn = banner.querySelector('.btn-connect');
                    
                    if (bannerText) {
                        bannerText.innerHTML = 'Unable to connect to Google Search Console. <button onclick="connectGSC()" class="btn-link">Click here to try again</button>';
                    }
                    if (connectBtn) {
                        connectBtn.disabled = false;
                        connectBtn.innerHTML = 'Connect GSC';
                    }
                    banner.classList.remove('loading');
                    banner.classList.remove('hidden');
                }
            }

            // Property selector modal removed - now handled by property_selection.html

            // Property selector functions removed - now handled by property_selection.html

            async function refreshMetrics() {
                console.log('[DEBUG] refreshMetrics() called - this should only happen when user clicks Refresh Data button');
                
                // IMMEDIATE POPUP - Show metrics loading popup instantly
                showMetricsLoadingPopup();
                resetMetricsLoadingState();
                
                const refreshBtn = document.getElementById('refreshBtn');
                // Show loading state
                refreshBtn.disabled = true;
                refreshBtn.classList.add('loading');
                
                try {
                    const response = await apiCall('/auth/gsc/refresh', {
                        method: 'POST'
                    });
                    if (response.ok) {
                        const data = await response.json();
                        
                        // Set initial loading states
                        setMetricLoadingState('visibility', 'loading');
                        setMetricLoadingState('organic_impressions', 'loading');
                        
                        // Fetch new AI insights with explicit AI usage
                        const aiData = await fetchExplicitAIInsights();
                        if (aiData) {
                            window.cachedAIInsights = aiData;
                        } else {
                            console.warn('Failed to fetch new AI insights after refresh.');
                        }
                        
                        // Reload the dashboard with fresh data
                        await loadRealMetrics();
                        

                        
                        // Cache the dashboard data after successful refresh
                        await cacheDashboardData();
                        
                        // Mark all metrics as done after everything is complete
                        setMetricLoadingState('visibility', 'done');
                        setMetricLoadingState('organic_impressions', 'done');
                        setMetricLoadingState('ai', 'done');
                        
                    } else {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to refresh data');
                    }
                } catch (error) {
                    console.error('Error refreshing metrics:', error);
                    
                    // Mark all metrics as done even on error
                    setMetricLoadingState('visibility', 'done');
                    setMetricLoadingState('organic_impressions', 'done');
                    setMetricLoadingState('ai', 'done');
                    
                    // Force the banner to show with a helpful message
                    const banner = document.getElementById('gscBanner');
                    const bannerText = banner.querySelector('.banner-text p');
                    if (bannerText) {
                        bannerText.textContent = 'We couldn\'t refresh your data because the connection to Google Search Console was lost. Please reconnect to continue.';
                    }
                    banner.classList.remove('hidden');
                } finally {
                    // Reset button state after a short delay to allow animation to be seen
                    setTimeout(() => {
                        refreshBtn.disabled = false;
                        refreshBtn.classList.remove('loading');
                    }, 500);
                }
            }

            async function cacheDashboardData() {
                // Cache the current dashboard data for same-day retrieval
                try {
                    
                    // Collect all current dashboard data including original API response data
                    const dashboardData = {
                        metrics: window.metricsData || {},
                        // Store original API response data if available
                        originalApiData: window.originalApiResponse || null,
                        // Include AI insights in cache
                        ai_insights: window.cachedAIInsights || cachedAIInsights || null,
                        timestamp: new Date().toISOString(),
                        cached_from: 'dashboard_refresh'
                    };
                    
                    const response = await apiCall('/auth/dashboard/cache', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ dashboard_data: dashboardData })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('[DEBUG] Dashboard data cached successfully including AI insights');
                    } else {
                        console.warn('[CACHE] Failed to cache dashboard data:', response.status);
                    }
                } catch (error) {
                    console.error('[CACHE] Error caching dashboard data:', error);
                }
            }

            async function loadCachedDashboardData() {
                try {
                    showCacheLoadingPopup();
                    const response = await apiCall('/auth/dashboard/cache');
                    if (response.ok) {
                        const result = await response.json();
                        
                        if (result.has_cache && result.data) {
                            
                            // Load the cached data into the dashboard
                            if (result.data.metrics) {
                                window.metricsData = result.data.metrics;
                                
                                // Use original API data if available, otherwise reconstruct from cached metrics
                                let metricsObject;
                                if (result.data.originalApiData) {
                                    metricsObject = result.data.originalApiData;
                                    window.originalApiResponse = result.data.originalApiData;
                                } else {
                                    metricsObject = { 
                                        summary: result.data.metrics.summary || {},
                                        time_series: result.data.metrics.time_series || {},
                                        website_url: result.data.metrics.website_url,
                                        start_date: result.data.metrics.start_date,
                                        end_date: result.data.metrics.end_date
                                    };
                                }
                                
                                // Update main dashboard metrics
                                if (result.data.metrics.summary) {
                                    await updateDashboardMetricsWithRealData(metricsObject);
                                }
                                
                                // Create charts with cached data
                                createMergedTrendsChart(metricsObject);
                                
                                // Show website info if available
                                if (result.data.metrics.summary) {
                                    showWebsiteInfo(metricsObject);
                                    showDateRange(metricsObject);
                                }
                                
                                // Load cached AI insights if available
                                if (result.data.ai_insights) {
                                    cachedAIInsights = result.data.ai_insights;
                                    window.cachedAIInsights = result.data.ai_insights;
                                    console.log('[DEBUG] Cached AI insights loaded from dashboard cache');
                                    
                                    // Generate visibility insights with cached AI data
                                    if (result.data.metrics.summary) {
                                        generateVisibilityInsights(result.data.metrics.summary);
                                    }
                                }
                                
                                // Recalculate score
                                recalculateOverallSEOScore();
                                
                                showCacheStatus('Loaded cached data from today', 'success');
                                hideCacheLoadingPopup();
                                // Hide any previous warning message
                                const cacheStatus = document.getElementById('cacheStatus');
                                if (cacheStatus && cacheStatus.classList.contains('cache-warning')) {
                                    cacheStatus.style.display = 'none';
                                }
                                return true; // Successfully loaded cached data
                            }
                        } else {
                            // No cache found - this will trigger automatic refresh in initDashboard
                            console.log('[DEBUG] No cached data found for today');
                            hideCacheLoadingPopup();
                            return false;
                        }
                } else {
                        console.warn('[CACHE] Failed to check for cached data:', response.status);
                        hideCacheLoadingPopup();
                        return false;
                    }
                } catch (error) {
                    console.error('[CACHE] Error loading cached dashboard data:', error);
                    hideCacheLoadingPopup();
                    return false;
                }
            }

            function showCacheStatus(message, type = 'info') {
                // Show cache status message to user
                // Create or update cache status element
                let cacheStatus = document.getElementById('cacheStatus');
                if (!cacheStatus) {
                    cacheStatus = document.createElement('div');
                    cacheStatus.id = 'cacheStatus';
                    cacheStatus.className = 'cache-status';
                    // Insert after the dashboard header
                    const dashboardHeader = document.querySelector('.dashboard-header');
                    if (dashboardHeader) {
                        dashboardHeader.insertAdjacentElement('afterend', cacheStatus);
                    }
                }
                // Set message and type
                cacheStatus.textContent = message;
                cacheStatus.className = `cache-status cache-${type}`;
                cacheStatus.style.display = 'block';
                // Set warning (no cache) to grey
                if (type === 'warning') {
                    cacheStatus.style.background = '#f3f4f6'; // light grey
                    cacheStatus.style.color = '#6B7280'; // grey text
                    cacheStatus.style.border = '1px solid #d1d5db';
                } else {
                    cacheStatus.style.background = '';
                    cacheStatus.style.color = '';
                    cacheStatus.style.border = '';
                }
                // Auto-hide only for info/success
                if (type === 'info' || type === 'success') {
                    setTimeout(() => {
                        if (cacheStatus) {
                            cacheStatus.style.display = 'none';
                        }
                    }, 5000);
                }
            }

            function recalculateOverallSEOScore() {
                const seoScore = calculateSEOScore(window.metricsData.summary);
                
                // Calculate and update SEO score change (use backend data if available, otherwise fallback to session-based)
                const seoScoreChange = window.metricsData.summary?.seo_score_change !== undefined ? 
                    window.metricsData.summary.seo_score_change : 
                    calculateChange('seo_score', seoScore);
                
                document.getElementById('seoScore').textContent = seoScore;
                updateSEOScoreChange(seoScoreChange);
            }

            function calculateSEOScore(summary) {
                // Define core metrics, their weights, and normalization functions
                const metrics = [
                    // Visibility Performance (100% weight - only remaining metrics)
                    { key: 'avg_ctr', value: summary.avg_ctr, weight: 25, norm: v => Math.min(v / 0.10, 1) },
                    { key: 'avg_position', value: summary.avg_position, weight: 25, norm: v => Math.max((10 - v) / 10, 0) },
                    { key: 'total_impressions', value: summary.total_impressions, weight: 25, norm: v => Math.min(Math.log10(v + 1) / 6, 1) },
                    { key: 'total_clicks', value: summary.total_clicks, weight: 25, norm: v => Math.min(Math.log10(v + 1) / 5, 1) }
                ];

                // Filter out missing metrics
                const present = metrics.filter(m => m.value !== undefined && m.value !== null && !Number.isNaN(m.value));
                const totalWeight = present.reduce((sum, m) => sum + m.weight, 0);
                if (totalWeight === 0) return 0;

                // Dynamically scale weights so total is 100
                let score = 0;
                present.forEach(m => {
                    const scaledWeight = m.weight * (100 / totalWeight);
                    let normValue = m.norm(m.value);
                    normValue = Math.max(0, Math.min(normValue, 1));
                    score += normValue * scaledWeight;
                });
                return Math.round(score);
            }

            function formatDateString(dateStr) {
                // dateStr is in "YYYY-MM-DD" format
                if (!dateStr || dateStr.split('-').length !== 3) {
                    return '';
                }
                const [year, month, day] = dateStr.split('-');
                const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                const monthName = monthNames[parseInt(month, 10) - 1];
                return `${monthName} ${parseInt(day, 10)}`;
            }

            function showDateRange(metrics) {
                const dateRangeInfo = document.getElementById('dateRangeInfo');
                const dateRangeSpan = document.getElementById('dateRange');

                if (metrics && metrics.start_date && metrics.end_date) {
                    const startStr = formatDateString(metrics.start_date);
                    const endStr = formatDateString(metrics.end_date);
                    
                    dateRangeSpan.textContent = `${startStr} - ${endStr}`;
                    dateRangeInfo.classList.remove('hidden');
                } else {
                    hideDateRange();
                }
            }

            function hideDateRange() {
                document.getElementById('dateRangeInfo').classList.add('hidden');
            }

            function showWebsiteInfo(metrics) {
                const websiteInfo = document.getElementById('websiteInfo');
                const trackedWebsite = document.getElementById('trackedWebsite');
                const mobileMenuWebsite = document.getElementById('mobileMenuWebsite');

                if (metrics && metrics.website_url) {
                    let displayUrl = metrics.website_url;
                    if (displayUrl.startsWith('sc-domain:')) {
                        // Convert sc-domain:example.com to https://example.com
                        const domain = displayUrl.replace('sc-domain:', '');
                        displayUrl = `https://${domain}`;
                    }
                    trackedWebsite.textContent = displayUrl;
                    mobileMenuWebsite.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-icon"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg>${displayUrl}`;
                    websiteInfo.classList.remove('hidden');
                } else {
                    hideWebsiteInfo();
                }
            }

            function hideWebsiteInfo() {
                document.getElementById('websiteInfo').classList.add('hidden');
                document.getElementById('mobileMenuWebsite').textContent = 'No website selected';
            }

            function changeWebsite() {
                // Redirect to setup wizard to select a different website
                window.location.href = '/setup';
            }
            
            function showMetricsLoadingPopup() {
                const popup = document.getElementById('metricsLoadingPopup');
                if (popup) {
                    console.log('[DEBUG] Showing metrics loading popup');
                    popup.style.display = 'flex';
                    popup.classList.remove('metrics-loading-hide');
                    popup.classList.add('metrics-loading-visible');
                    updateMetricsLoadingList();
                }
            }
            function hideMetricsLoadingPopup() {
                const popup = document.getElementById('metricsLoadingPopup');
                if (popup) {
                    console.log('[DEBUG] Hiding metrics loading popup');
                    popup.style.display = 'none';
                    popup.classList.remove('metrics-loading-visible');
                    popup.classList.add('metrics-loading-hide');
                }
            }
            function showMetricsSuccessPopup() {
                const popup = document.getElementById('metricsSuccessPopup');
                if (popup) {
                    console.log('[DEBUG] Showing metrics success popup');
                    popup.style.display = 'flex';
                    popup.classList.remove('metrics-success-hide');
                    popup.classList.add('metrics-success-visible');
                }
            }
            function hideMetricsSuccessPopup() {
                const popup = document.getElementById('metricsSuccessPopup');
                if (popup) {
                    console.log('[DEBUG] Hiding metrics success popup');
                    popup.style.display = 'none';
                    popup.classList.remove('metrics-success-visible');
                    popup.classList.add('metrics-success-hide');
                }
            }
            function updateMetricsLoadingList() {
                const orange = '#F97316';
                const list = document.getElementById('metricsLoadingList');
                list.innerHTML = METRIC_GROUPS.map(m => {
                    const state = metricsLoadingState[m.key];
                    if (state === 'done') {
                        // Orange checkmark and regular font
                        return `<div style="display:flex;align-items:center;gap:0.5rem;font-weight:400;color:${orange};"><span class="metric-success-icon"><svg width='18' height='18'><polyline points='3,10 8,15 15,4' style='fill:none;stroke:${orange};stroke-width:2;stroke-linecap:round;stroke-linejoin:round;'/></svg></span><span style='color:${orange};'>${m.label}</span></div>`;
                    } else if (state === 'loading') {
                        // Orange spinner and regular font
                        return `<div style="display:flex;align-items:center;gap:0.5rem;font-weight:400;color:${orange};"><span class="metric-loading-spinner"><svg width='18' height='18' viewBox='0 0 50 50'><circle cx='25' cy='25' r='20' fill='none' stroke='${orange}' stroke-width='5' stroke-linecap='round' stroke-dasharray='31.4 31.4' stroke-dashoffset='0'><animateTransform attributeName='transform' type='rotate' from='0 25 25' to='360 25 25' dur='0.8s' repeatCount='indefinite'/></circle></svg></span><span style='color:${orange};'>${m.label}</span></div>`;
                    } else {
                        // Pending (orange, no animation)
                        return `<div style="display:flex;align-items:center;gap:0.5rem;font-weight:400;color:${orange};"><span class="metric-pending-icon"><svg width='18' height='18'><circle cx='9' cy='9' r='7' fill='none' stroke='${orange}' stroke-width='2'/></svg></span><span style='color:${orange};'>${m.label}</span></div>`;
                    }
                }).join('');
            }
            function setMetricLoadingState(key, state) {
                metricsLoadingState[key] = state;
                updateMetricsLoadingList();
                
                // Set loading state for growth indicators
                if (state === 'loading') {
                    setGrowthIndicatorsLoading(key);
                }
                
                // If all done, show success popup and hide both after 5s with countdown
                if (METRIC_GROUPS.every(m => metricsLoadingState[m.key] === 'done')) {
                    console.log('[DEBUG] All metrics done, showing success popup');
                    console.log('[DEBUG] Current loading states:', metricsLoadingState);
                    
                    // Show success popup
                    showMetricsSuccessPopup();
                    
                    let secondsLeft = 5;
                    const timerSpan = document.getElementById('metricsSuccessTimer');
                    timerSpan.textContent = `(${secondsLeft}s)`;
                    timerSpan.style.color = '';
                    const interval = setInterval(() => {
                        secondsLeft--;
                        timerSpan.textContent = `(${secondsLeft}s)`;
                        if (secondsLeft <= 0) {
                            clearInterval(interval);
                            console.log('[DEBUG] 5-second countdown finished - hiding all popups');
                            // Hide both popups together
                            hideMetricsSuccessPopup();
                            hideMetricsLoadingPopup();
                        }
                    }, 1000);
                    
                    // Global fallback timer to ensure popups are hidden after 5 seconds
                    setTimeout(() => {
                        console.log('[DEBUG] Global fallback timer - forcing hide all popups');
                        const loadingPopup = document.getElementById('metricsLoadingPopup');
                        const successPopup = document.getElementById('metricsSuccessPopup');
                        if (loadingPopup) loadingPopup.style.display = 'none';
                        if (successPopup) successPopup.style.display = 'none';
                    }, 5000);
                } else {
                    console.log('[DEBUG] Not all metrics done yet. Current states:', metricsLoadingState);
                    console.log('[DEBUG] Expected keys:', METRIC_GROUPS.map(m => m.key));
                }
            }

            function setGrowthIndicatorsLoading(section) {
                const indicatorMap = {
                    'visibility': [
                        'impressionsChange', 'clicksChange', 'ctrChange', 'avgPositionChange'
                    ],
                    'organic': [
                        'impressionsChange', 'clicksChange'
                    ],
                    'impressions': [
                        'impressionsChange'
                    ]
                };

                const indicators = indicatorMap[section] || [];
                indicators.forEach(indicatorId => {
                    const element = document.getElementById(indicatorId);
                    if (element) {
                        updateChangeIndicator(indicatorId, 'loading');
                    } else {
                        console.warn(`[DEBUG] Growth indicator element not found: ${indicatorId}`);
                    }
                });
            }
            function resetMetricsLoadingState() {
                METRIC_GROUPS.forEach((m, i) => {
                    metricsLoadingState[m.key] = (i === 0) ? 'loading' : 'pending';
                });
                updateMetricsLoadingList();
            }
            
            async function loadRealMetrics() {
                resetMetricsLoadingState();
                
                try {
                    // Visibility Performance (GSC metrics)
                    setMetricLoadingState('visibility', 'loading');
                    const response = await apiCall('/auth/gsc/metrics');
                    if (response.ok) {
                        const metrics = await response.json();
                        
                        // Store original API response for caching
                        window.originalApiResponse = metrics;
                        
                        // Validate metrics data structure
                        if (!metrics || !metrics.summary) {
                            console.error('[ERROR] Invalid metrics data structure:', metrics);
                            throw new Error('Invalid metrics data structure received from API');
                        }
                        
                        await updateDashboardMetricsWithRealData(metrics);
                        
                        createMergedTrendsChart(metrics);
                        
                        showWebsiteInfo(metrics);
                        showDateRange(metrics);
                        
                        // Mark core metrics as loaded
                        setMetricLoadingState('visibility', 'done');
                        setMetricLoadingState('organic_impressions', 'done');
                        
                        // Set AI to loading since insights will be generated
                        setMetricLoadingState('ai', 'loading');
                        
                        // All core metrics are now loaded
                        console.log('[DEBUG] Core metrics loaded successfully');
                        
                    } else {
                        const errorText = await response.text();
                        console.error('[ERROR] Failed to load GSC metrics:', response.status, errorText);
                        
                        // Set all states to done since we can't fetch data
                        setMetricLoadingState('visibility', 'done');
                        setMetricLoadingState('organic_impressions', 'done');
                        setMetricLoadingState('ai', 'done');
                        
                        // Show empty state
                        updateDashboardMetrics(false);
                        createMergedTrendsChart({});
                        hideWebsiteInfo();
                        hideDateRange();
                    }
                } catch (error) {
                    console.error('[ERROR] Exception in loadRealMetrics:', error);
                    
                    // Set all states to done
                    setMetricLoadingState('visibility', 'done');
                    setMetricLoadingState('organic_impressions', 'done');
                    setMetricLoadingState('ai', 'done');
                    
                    // Show empty state
                    updateDashboardMetrics(false);
                    createMergedTrendsChart({});
                    hideWebsiteInfo();
                    hideDateRange();
                } finally {
                    // Note: Loading popup will be hidden by setMetricLoadingState when all metrics are done
                    // The 5-second countdown timer handles hiding both loading and success popups
                }
            }
            

            
            document.addEventListener('DOMContentLoaded', initDashboard);

            // Hide error banner on page load
            document.addEventListener('DOMContentLoaded', function() {
                hideErrorMessage();
            });

            // Expose test functions to global scope for console access
            window.testDataLoading = testDataLoading;
            window.runFullDiagnostic = runFullDiagnostic;
            window.testCacheSystem = testCacheSystem;
            window.forceCacheRefresh = forceCacheRefresh;







            // Duplicate fetchMobileData function removed - using the comprehensive version above
            // Duplicate fetchBusinessData function removed - using the enhanced version above with debugging
            // Duplicate loadRealMetrics function removed - using the enhanced version above

            // TEST FUNCTION - Test the dashboard caching system
            async function testCacheSystem() {
                console.log('=== TESTING DASHBOARD CACHE SYSTEM ===');
                
                try {
                    // Test 1: Check for existing cache
                    console.log('1. Checking for existing cached data...');
                    const cacheResponse = await apiCall('/auth/dashboard/cache');
                    
                    if (cacheResponse.ok) {
                        const cacheResult = await cacheResponse.json();
                        console.log('Cache check result:', cacheResult);
                        
                        if (cacheResult.has_cache) {
                            console.log('✅ Found cached data from:', cacheResult.data?.timestamp);
                        } else {
                            console.log('ℹ️  No cached data available for today');
                        }
                    } else {
                        console.error('❌ Failed to check cache:', cacheResponse.status);
                    }
                    
                    // Test 2: Cache current dashboard data
                    console.log('2. Testing cache storage...');
                    const testData = {
                        metrics: window.metricsData || {},
                        timestamp: new Date().toISOString(),
                        cached_from: 'test_function'
                    };
                    
                    const storeResponse = await apiCall('/auth/dashboard/cache', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(testData)
                    });
                    
                    if (storeResponse.ok) {
                        const storeResult = await storeResponse.json();
                        console.log('✅ Cache storage successful:', storeResult);
                    } else {
                        console.error('❌ Failed to store cache:', storeResponse.status);
                    }
                    
                    // Test 3: Verify cached data
                    console.log('3. Verifying cached data...');
                    const verifyResponse = await apiCall('/auth/dashboard/cache');
                    
                    if (verifyResponse.ok) {
                        const verifyResult = await verifyResponse.json();
                        if (verifyResult.has_cache) {
                            console.log('✅ Cache verification successful');
                            console.log('Cached metrics keys:', Object.keys(verifyResult.data?.metrics || {}));
                        } else {
                            console.log('❌ Cache verification failed - no data found');
                        }
                    } else {
                        console.error('❌ Failed to verify cache:', verifyResponse.status);
                    }
                    
                } catch (error) {
                    console.error('❌ Exception during cache testing:', error);
                }
                
                console.log('=== CACHE SYSTEM TEST COMPLETED ===');
            }

            // TEST FUNCTION - Force refresh and cache new data
            async function forceCacheRefresh() {
                console.log('=== FORCING CACHE REFRESH ===');
                
                try {
                    // Step 1: Load fresh data
                    console.log('1. Loading fresh metrics data...');
                    await loadRealMetrics();
                    
                    // Step 2: Cache the fresh data
                    console.log('2. Caching fresh data...');
                    await cacheDashboardData();
                    
                    console.log('✅ Cache refresh completed successfully');
                    showCacheStatus('Fresh data loaded and cached!', 'success');
                    
                } catch (error) {
                    console.error('❌ Error during cache refresh:', error);
                    showCacheStatus('Failed to refresh cache', 'warning');
                }
                
                console.log('=== CACHE REFRESH COMPLETED ===');
            }

            // TEST FUNCTION - Call this from console to debug
            async function testDataLoading() {
                console.log('=== MANUAL DATA LOADING TEST ===');
                
                // Step 1: Check authentication
                console.log('1. Checking authentication...');
                if (!checkAuthStatus()) {
                    console.log('❌ Authentication failed, stopping test');
                    return;
                }
                
                // Step 2: Test API call
                console.log('2. Testing API call...');
                try {
                    const response = await apiCall('/auth/gsc/metrics');
                    console.log('- Response status:', response.status);
                    
                    if (response && response.ok) {
                        const data = await response.json();
                        console.log('- Response data:', JSON.stringify(data, null, 2));
                        
                        // Step 3: Test data processing
                        console.log('3. Testing updateDashboardMetricsWithRealData...');
                        await updateDashboardMetricsWithRealData(data);
                        console.log('✅ Data loading test completed successfully');
                    } else {
                        console.log('❌ API call failed');
                        const errorText = await response.text();
                        console.log('Error details:', errorText);
                    }
                } catch (error) {
                    console.error('❌ Exception during API call:', error);
                }
            }



            // COMPREHENSIVE TEST FUNCTION
            async function runFullDiagnostic() {
                console.log('🔍 === FULL DIAGNOSTIC TEST ===');
                
                // 1. Authentication check
                console.log('\n1️⃣ AUTHENTICATION CHECK:');
                const authOk = checkAuthStatus();
                
                if (!authOk) {
                    console.log('🛑 Stopping diagnostic - authentication failed');
                    return;
                }
                
                // 2. GSC Properties check
                console.log('\n2️⃣ GSC PROPERTIES CHECK:');
                await checkGSCProperties();
                
                // 3. Metrics fetch test
                console.log('\n3️⃣ METRICS FETCH TEST:');
                await testDataLoading();
                

                
                console.log('\n✅ Full diagnostic completed');
            }

            // TEST FUNCTION - Call this from console to debug date ranges
            async function testDifferentDateRanges() {
                console.log('=== TESTING DIFFERENT DATE RANGES ===');
                
                const token = localStorage.getItem('auth_token');
                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };

                // Test with different date ranges by calling GSC API directly
                const testRanges = [
                    { days: 7, name: '7 days' },
                    { days: 30, name: '30 days' },
                    { days: 90, name: '90 days' }
                ];
                
                for (const range of testRanges) {
                    console.log(`\n--- Testing ${range.name} ---`);
                    
                    try {
                        // We'll use the existing endpoint but test if different periods return data
                        const response = await fetch('/auth/gsc/metrics', { headers });
                        
                        if (response.ok) {
                            const data = await response.json();
                            console.log(`Status: ${response.status}`);
                            console.log(`Date range: ${data.start_date} to ${data.end_date}`);
                            
                            const summary = data.summary || {};
                            console.log('Summary data:');
                            console.log(`- total_impressions: ${summary.total_impressions}`);
                            console.log(`- total_clicks: ${summary.total_clicks}`);
                            console.log(`- avg_ctr: ${summary.avg_ctr}`);
                            console.log(`- avg_position: ${summary.avg_position}`);
                            console.log(`- Has time_series: ${Object.keys(data.time_series || {}).length > 0}`);
                            
                            if (data.time_series && data.time_series.dates) {
                                console.log(`- Time series dates: ${data.time_series.dates.length} entries`);
                                console.log(`- Sample dates: ${data.time_series.dates.slice(0, 3).join(', ')}`);
                            }
                        } else {
                            console.log(`Failed: ${response.status}`);
                            const error = await response.text();
                            console.log(`Error: ${error}`);
                        }
                        
                    } catch (error) {
                        console.error(`Exception for ${range.name}:`, error);
                    }
                }
            }

            // TEST FUNCTION - Direct GSC property check
            async function checkGSCProperties() {
                console.log('=== CHECKING GSC PROPERTIES ===');
                
                const token = localStorage.getItem('auth_token');
                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };

                try {
                    const response = await fetch('/auth/gsc/properties', { headers });
                    
                    if (response.ok) {
                        const properties = await response.json();
                        console.log('Available properties:', properties);
                        console.log('Number of properties:', properties.length);
                        
                        // Check which one is selected
                        const selectedResponse = await fetch('/auth/gsc/selected', { headers });
                        if (selectedResponse.ok) {
                            const selected = await selectedResponse.json();
                            console.log('Selected property:', selected);
                        }
                    } else {
                        console.log('Failed to fetch properties:', response.status);
                    }
                } catch (error) {
                    console.error('Error checking properties:', error);
                }
            }

            // TEST FUNCTION - Check authentication status
            function checkAuthStatus() {
                console.log('=== AUTHENTICATION STATUS CHECK ===');
                
                const token = localStorage.getItem('auth_token');
                console.log('1. Token exists:', !!token);
                
                if (!token) {
                    console.log('❌ No authentication token found');
                    console.log('�� Solution: You need to log in first');
                    console.log('   - Go to /ui and log in');
                    console.log('   - Or click "Connect to Google" if available');
                    return false;
                }
                
                try {
                    console.log('2. Token format:', token.substring(0, 50) + '...');
                    
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    const currentTime = Math.floor(Date.now() / 1000);
                    const isExpired = payload.exp && payload.exp < currentTime;
                    
                    console.log('3. Token details:', {
                        userEmail: payload.email || payload.sub || 'user@example.com',
                        issuedAt: new Date(payload.iat * 1000).toLocaleString(),
                        expiresAt: new Date(payload.exp * 1000).toLocaleString(),
                        isExpired: isExpired,
                        timeUntilExpiry: isExpired ? 'EXPIRED' : `${Math.round((payload.exp - currentTime) / 60)} minutes`
                    });
                    
                    if (isExpired) {
                        console.log('❌ Token has expired');
                        console.log('💡 Solution: Refresh the page to get a new token');
                        return false;
                    }
                    
                    console.log('✅ Authentication token is valid');
                    
                    // Test API call
                    console.log('4. Testing API call...');
                    fetch('/auth/me', {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    }).then(response => {
                        console.log('API test result:', response.status);
                        if (response.ok) {
                            console.log('✅ API authentication working');
                        } else {
                            console.log('❌ API authentication failed');
                            console.log('💡 Solution: Clear localStorage and log in again');
                        }
                    }).catch(error => {
                        console.error('API test error:', error);
                    });
                    
                    return true;
                    
                } catch (error) {
                    console.error('❌ Error parsing token:', error);
                    console.log('💡 Solution: Clear localStorage and log in again');
                    console.log('   - Run: localStorage.clear()');
                    console.log('   - Then go to /ui and log in');
                    return false;
                }
            }

            // Add JS functions to show/hide the cache loading popup
            function showCacheLoadingPopup() {
                const popup = document.getElementById('cacheLoadingPopup');
                if (popup) popup.style.display = 'flex';
            }
            function hideCacheLoadingPopup() {
                const popup = document.getElementById('cacheLoadingPopup');
                if (popup) popup.style.display = 'none';
            }

            function renderAIOverallAnalysis(insights) {
                const card = document.getElementById('aiOverallAnalysisCard');
                // Never hide the card, even if insights are missing
                card.style.display = '';
                const summaryElement = document.getElementById('aiOverallSummary');
                const statusElement = document.getElementById('aiOverallStatus');
                if (!insights || !insights.analysis || Object.keys(insights.analysis).length === 0) {
                    summaryElement.innerHTML = '<p>AI insights not available. Please try again later.</p>';
                    statusElement.textContent = 'Unavailable';
                    statusElement.className = 'status-indicator';
                    return;
                }
                // Display summary if available
                if (insights.analysis.summary) {
                    summaryElement.innerHTML = `<p>${insights.analysis.summary}</p>`;
                } else if (insights.analysis.overall_assessment) {
                    summaryElement.innerHTML = `<p><strong>Overall Assessment:</strong> ${insights.analysis.overall_assessment}</p>`;
                } else {
                    summaryElement.innerHTML = '<p>AI analysis completed. Review the individual sections above for detailed insights.</p>';
                }
                // Display status if available
                if (insights.analysis.status) {
                    statusElement.textContent = insights.analysis.status;
                    if (insights.analysis.score) {
                        const score = insights.analysis.score;
                        if (score >= 80) {
                            statusElement.className = 'status-indicator good';
                        } else if (score >= 60) {
                            statusIndicator.className = 'status-indicator warning';
                        } else {
                            statusElement.className = 'status-indicator error';
                        }
                    }
                    statusElement.textContent = 'Analysis Complete';
                    statusElement.className = 'status-indicator good';
                }
            }

            async function generateVisibilityInsights(summary) {
                try {
                    // Use cached insights if available, otherwise fetch
                    const insights = cachedAIInsights || await fetchAIInsights();
                    window.lastInsights = insights;
                    
                    if (insights && insights.visibility_performance && insights.visibility_performance.metrics) {
                        // Update individual metric analyses
                        Object.entries(insights.visibility_performance.metrics).forEach(([metric, data]) => {
                            console.log(`[DEBUG] Metric ${metric}:`, data);
                            console.log(`[DEBUG] Metric ${metric} analysis:`, data.analysis);
                            
                            let analysis = '';
                            // Handle different possible data structures
                            if (typeof data === 'string') {
                                analysis = data;
                            } else if (data && typeof data === 'object') {
                                // Check if analysis is an object with text content
                                if (data.analysis && typeof data.analysis === 'object') {
                                    // Create a meaningful summary from the analysis object
                                    const analysisObj = data.analysis;
                                    const parts = [];
                                    
                                    if (analysisObj.current_performance) {
                                        parts.push(`${analysisObj.current_performance} performance`);
                                    }
                                    if (analysisObj.root_cause) {
                                        parts.push(analysisObj.root_cause);
                                    }
                                    if (analysisObj.industry_context) {
                                        parts.push(analysisObj.industry_context);
                                    }
                                    
                                    // Clean up any double periods and ensure proper formatting
                                    analysis = parts.join('. ').replace(/\.\.+/g, '.').replace(/\.\s*\./g, '. ').trim();
                                } else {
                                    // Try different possible field names
                                    analysis = data.analysis || data.summary || data.assessment || data.description || data.value || JSON.stringify(data);
                                }
                            }
                            
                            // Map metric names to element IDs
                            const metricElementMap = {
                                'impressions': 'impressionsAnalysis',
                                'clicks': 'clicksAnalysis',
                                'ctr': 'ctrAnalysis',
                                'average_position': 'avgPositionAnalysis'
                            };
                            
                            const elementId = metricElementMap[metric];
                            if (elementId && analysis) {
                                const element = document.getElementById(elementId);
                                if (element) {
                                    element.textContent = analysis;
                                    element.style.display = 'block';
                                }
                            }
                        });
                        
                        renderAIOverallAnalysis(insights);
                    } else {
                        console.log('[ERROR] No visibility insights available');
                    }
                } catch (error) {
                    console.error('Error generating visibility insights:', error);
                }
            }

            function updateUserMenuInfo() {
                const token = localStorage.getItem('auth_token');
                if (!token) return;
                try {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    const userEmail = payload.email || payload.sub || 'user@example.com';
                    const userName = userEmail.includes('@') ? userEmail.split('@')[0] : userEmail;
                    document.getElementById('userEmail').textContent = userEmail;
                    document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                    document.getElementById('mobileMenuEmail').textContent = userEmail;
                    document.getElementById('mobileMenuAvatar').textContent = userName.charAt(0).toUpperCase();
                } catch (e) {
                    // fallback
                }
            }

            // Move to the next metric after one is done
            function setNextMetricLoading(currentKey) {
                const idx = METRIC_GROUPS.findIndex(m => m.key === currentKey);
                if (idx !== -1 && idx < METRIC_GROUPS.length - 1) {
                    metricsLoadingState[METRIC_GROUPS[idx + 1].key] = 'loading';
                    updateMetricsLoadingList();
                }
            }

            function showAIAnalysisPopup() {
                const popup = document.getElementById('aiAnalysisLoadingPopup');
                if (popup) {
                    popup.style.display = 'flex';
                    // Add the visible class after a small delay to trigger the animation
                    setTimeout(() => {
                        popup.classList.add('metrics-loading-visible');
                        popup.classList.remove('metrics-loading-hide');
                    }, 10);
                }
            }
            function hideAIAnalysisPopup() {
                const popup = document.getElementById('aiAnalysisLoadingPopup');
                if (popup) {
                    popup.classList.add('metrics-loading-hide');
                    popup.classList.remove('metrics-loading-visible');
                    // Hide after animation completes
                    setTimeout(() => {
                        popup.style.display = 'none';
                        popup.classList.remove('metrics-loading-hide');
                    }, 500);
                }
            }

            document.addEventListener('DOMContentLoaded', function() {
                const regenerateBtn = document.getElementById('regenerateAIButton');
                if (regenerateBtn) {
                    const regenBtnContent = regenerateBtn.querySelector('.regen-btn-content');
                    const regenBtnIcon = regenerateBtn.querySelector('.regen-btn-icon');
                    const regenBtnSpinner = regenerateBtn.querySelector('.regen-btn-spinner');
                    
                    if (!regenBtnContent || !regenBtnIcon || !regenBtnSpinner) {
                        console.error('[ERROR] Regenerate button elements not found');
                        return;
                    }
                    
                    regenerateBtn.addEventListener('click', async function() {
                        if (!confirm('Regenerating AI analysis will overwrite your previous insights and may disrupt your current SEO implementation progress. Are you sure you want to continue?')) {
                            return;
                        }
                        showAIAnalysisPopup();
                        regenerateBtn.disabled = true;
                        regenerateBtn.classList.add('loading');
                        regenBtnIcon.style.display = 'none';
                        regenBtnSpinner.style.display = 'inline-block';
                        try {
                            const aiData = await fetchExplicitAIInsights();
                            if (aiData) {
                                window.cachedAIInsights = aiData;
                                renderAIOverallAnalysis(aiData);
                            } else {
                                alert('Failed to regenerate AI analysis. Please try again later.');
                            }
                        } finally {
                            hideAIAnalysisPopup();
                            regenerateBtn.disabled = false;
                            regenerateBtn.classList.remove('loading');
                            regenBtnIcon.style.display = '';
                            regenBtnSpinner.style.display = 'none';
                        }
                    });
                }
            });
        </script>
    </body>
</html> 