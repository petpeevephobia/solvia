<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solvia Dashboard - SEO on AI Autopilot</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css?v=1.2">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="dashboard-body">
    <nav class="navbar">
        <div class="navbar-brand">Solvia</div>
        <div class="navbar-user">
            <div class="user-avatar" id="userAvatar" onclick="toggleMobileMenu()">S</div>
            <span id="userEmail" class="desktop-only">user@example.com</span>
            <button class="logout-btn desktop-only" onclick="logout()">Logout</button>
        </div>
    </nav>

    <!-- Mobile Side Menu -->
    <div id="mobileMenuOverlay" class="mobile-menu-overlay" onclick="closeMobileMenu()"></div>
    <div id="mobileMenu" class="mobile-menu">
        <div class="mobile-menu-header">
            <div class="mobile-menu-avatar" id="mobileMenuAvatar">S</div>
            <div class="mobile-menu-user-info">
                <div class="mobile-menu-email" id="mobileMenuEmail">user@example.com</div>
                <div class="mobile-menu-website" id="mobileMenuWebsite">No website selected</div>
            </div>
            <button class="mobile-menu-close" onclick="closeMobileMenu()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="mobile-menu-content">
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Website</div>
                <button class="mobile-menu-item" onclick="changeWebsite(); closeMobileMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                    </svg>
                    <span>Change Website</span>
                </button>
            </div>
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Account</div>
                <button class="mobile-menu-item" onclick="logout()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                        <polyline points="16,17 21,12 16,7"></polyline>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                    <span>Logout</span>
                </button>
            </div>
        </div>
    </div>

    <div class="container dashboard-container">
        <!-- GSC Connection Banner -->
        <div id="gscBanner" class="gsc-banner hidden">
            <div class="banner-content">
                <div class="banner-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4.5 16.5c-1.5 1.5-1.5 4.5 0 6s4.5 1.5 6 0l10-10c1-1 1-2.5 0-3.5s-2.5-1-3.5 0l-10 10z"></path>
                        <path d="M13.5 6.5l4 4"></path>
                        <path d="M12 2l2 2-2 2-2-2 2-2z"></path>
                    </svg>
                </div>
                <div class="banner-text">
                    <h3>Connect Google Search Console</h3>
                    <p>Get real SEO data for your dashboard by connecting your Google Search Console account.</p>
                </div>
                <div class="banner-actions">
                    <button onclick="connectGSC()" class="btn-connect">Connect GSC</button>
                </div>
            </div>
        </div>

        <div class="dashboard-header">
            <div>
                <h1>Your Dashboard</h1>
                <div id="dateRangeInfo" class="date-range-info hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                    <span id="dateRange"></span>
                </div>
                <div id="websiteInfo" class="website-info hidden">
                    <span>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-icon">
                            <line x1="18" y1="20" x2="18" y2="10"></line>
                            <line x1="12" y1="20" x2="12" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="14"></line>
                        </svg>
                        Tracking: 
                    </span>
                    <span id="trackedWebsite" class="tracked-website"></span>
                </div>
            </div>
            <button onclick="refreshMetrics()" class="btn-refresh" id="refreshBtn" title="Refresh Data">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rotate-cw"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </button>
        </div>

        <div class="stats-grid">
            <!-- Overall SEO Score Card -->
            <div class="stat-card overall-score">
                <div class="score-header">
                    <h3>Overall SEO Score</h3>
                    <div class="score-badge" id="seoScore">0</div>
            </div>
                <div class="score-change" id="seoScoreChange">+0%</div>
                <div class="score-description">Based on all metrics</div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="charts-section" id="mergedChartsSection">
            <div class="content-card">
                <div class="card-header">
                    <h2>Organic Traffic & Impressions</h2>
                </div>
                <div class="card-body">
                    <canvas id="mergedTrendsChart" height="300"></canvas>
                </div>
            </div>
        </div>

        <div class="analysis-grid">
            <!-- Visibility Performance Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="20" x2="18" y2="10"></line>
                            <line x1="12" y1="20" x2="12" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="14"></line>
                        </svg>
                    </div>
                    <h2>Visibility Performance</h2>
                    <div class="status-indicator" id="visibilityStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Impressions</span>
                            <span class="metric-value" id="impressionsValue">0</span>
                            <span class="metric-change" id="impressionsChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Clicks</span>
                            <span class="metric-value" id="clicksValue">0</span>
                            <span class="metric-change" id="clicksChange">+0</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">CTR</span>
                            <span class="metric-value" id="ctrValue">0%</span>
                            <span class="metric-change" id="ctrChange">+0%</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Avg Position</span>
                            <span class="metric-value" id="avgPositionValue">N/A</span>
                            <span class="metric-change" id="avgPositionChange">+0.0</span>
                        </div>
                    </div>
                    <div class="insights" id="visibilityInsights">
                        <p>Connect Google Search Console to see visibility insights</p>
                    </div>
            </div>
        </div>


            <!-- Engagement & UX Performance Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"></polygon>
                        </svg>
                    </div>
                    <h2>Engagement & UX</h2>
                    <div class="status-indicator" id="uxStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Performance Score</span>
                            <span class="metric-value" id="performanceScore">N/A</span>
                            <span class="metric-change" id="performanceScoreChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">LCP</span>
                            <span class="metric-value" id="lcpValue">N/A</span>
                            <span class="metric-change" id="lcpChange">+0.0s</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">FCP</span>
                            <span class="metric-value" id="fcpValue">N/A</span>
                            <span class="metric-change" id="fcpChange">+0.0s</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">CLS</span>
                            <span class="metric-value" id="clsValue">N/A</span>
                            <span class="metric-change" id="clsChange">+0.00</span>
                        </div>
                    </div>
                    <div class="insights" id="uxInsights">
                        <p>Performance data will appear when connected</p>
                    </div>
                </div>
            </div>

            <!-- Mobile Usability Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
                            <line x1="12" y1="18" x2="12.01" y2="18"></line>
                        </svg>
                    </div>
                    <h2>Mobile Usability</h2>
                    <div class="status-indicator" id="mobileStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Mobile Friendly</span>
                            <span class="metric-value" id="mobileFriendly">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Issues</span>
                            <span class="metric-value" id="mobileIssues">0</span>
                            <span class="metric-change" id="mobileIssuesChange">+0</span>
                        </div>
                    </div>
                    <div class="insights" id="mobileInsights">
                        <p>Mobile test results will appear here</p>
                    </div>
                </div>
            </div>

            <!-- Indexing & Crawlability Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="M21 21l-4.35-4.35"></path>
                        </svg>
                    </div>
                    <h2>Indexing & Crawlability</h2>
                    <div class="status-indicator" id="indexingStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Sitemap Status</span>
                            <span class="metric-value" id="sitemapStatus">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Index Status</span>
                            <span class="metric-value" id="indexStatus">N/A</span>
                        </div>
                    </div>
                    <div class="insights" id="indexingInsights">
                        <p>Indexing health will be analyzed</p>
                    </div>
                </div>
            </div>

            <!-- Business Context Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 21h18"></path>
                            <path d="M5 21V7l8-4v18"></path>
                            <path d="M19 21V11l-6-4"></path>
                            <path d="M9 9v.01"></path>
                            <path d="M9 12v.01"></path>
                            <path d="M9 15v.01"></path>
                            
                            <path d="M9 18v.01"></path>
                        </svg>
                    </div>
                    <h2>Business Context</h2>
                    <div class="status-indicator" id="businessStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Business Type</span>
                            <span class="metric-value" id="businessType">N/A</span>
                            <span class="metric-change" id="businessTypeChange">No Change</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Target Market</span>
                            <span class="metric-value" id="targetMarket">N/A</span>
                            <span class="metric-change" id="targetMarketChange">No Change</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Complexity Score</span>
                            <span class="metric-value" id="businessComplexity">0</span>
                            <span class="metric-change" id="businessComplexityChange">+0.0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Service Count</span>
                            <span class="metric-value" id="serviceCount">0</span>
                            <span class="metric-change" id="serviceCountChange">+0</span>
                        </div>
                    </div>
                    <div class="insights" id="businessInsights">
                        <p>Business analysis will provide context</p>
                    </div>
                </div>
            </div>

            <!-- Keyword Trends Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="22,7 13.5,15.5 8.5,10.5 2,17"></polyline>
                            <polyline points="16,7 22,7 22,13"></polyline>
                        </svg>
                    </div>
                    <h2>Keyword Trends</h2>
                    <div class="status-indicator" id="keywordStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Total Keywords</span>
                            <span class="metric-value" id="totalKeywords">0</span>
                            <span class="metric-change" id="totalKeywordsChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Avg Position</span>
                            <span class="metric-value" id="keywordAvgPosition">N/A</span>
                            <span class="metric-change" id="keywordAvgPositionChange">+0.0</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Opportunities</span>
                            <span class="metric-value" id="keywordOpportunities">0</span>
                            <span class="metric-change" id="keywordOpportunitiesChange">+0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Branded</span>
                            <span class="metric-value" id="brandedKeywords">0</span>
                            <span class="metric-change" id="brandedKeywordsChange">+0</span>
                        </div>
                    </div>
                    <div class="insights" id="keywordInsights">
                        <p>Loading keyword performance insights...</p>
                    </div>
                                    <div class="keywords-list" id="keywordsList">
                    <h4>Keywords Found:</h4>
                    <div id="keywordsContainer" class="keywords-container">
                        <p class="keywords-loading">Loading keywords...</p>
                </div>
            </div>
        </div>
                </div>
            </div>
            
    <div id="metricsPopupContainer">
        <div id="metricsSuccessPopup">
            All metrics loaded successfully! <span id="metricsSuccessTimer" class="timer"></span>
                </div>
        <div id="metricsLoadingPopup">
            <div id="metricsLoadingList"></div>
        </div>
    </div>

    <script>
        // Global chart instances
        let organicTrafficChart = null;
        let impressionsChart = null;
        let isRefreshingToken = false; // Flag to prevent multiple refresh attempts
        
        // Global variables for metric data
        window.metricsData = {
            summary: {},
            ux: {},
            mobile: {},
            indexing: {},
            keywords: {},
            business: {}
        };
        let refreshAttempts = 0; // Track refresh attempts to prevent infinite loops
        const MAX_REFRESH_ATTEMPTS = 3; // Maximum number of refresh attempts
        let lastRefreshTime = 0; // Track when we last attempted a refresh
        let isRedirecting = false; // Flag to prevent multiple redirects
        let consecutiveFailures = 0; // Track consecutive API failures
        
        const METRIC_GROUPS = [
          { key: 'organic', label: 'Organic Traffic Trends' },
          { key: 'impressions', label: 'Impressions Trends' },
          { key: 'visibility', label: 'Visibility Performance' },
          { key: 'ux', label: 'Engagement & UX' },
          { key: 'mobile', label: 'Mobile Usability' },
          { key: 'indexing', label: 'Indexing & Crawlability' },
          { key: 'business', label: 'Business Context' },
          { key: 'keywords', label: 'Keyword Trends' },
        ];
        let metricsLoadingState = {};
        
        // Check if we're in an infinite loop situation
        function checkForInfiniteLoop() {
            if (consecutiveFailures > 5) {
                console.log('[TOKEN DEBUG] Detected potential infinite loop, clearing token immediately');
                clearInvalidToken();
                return true;
            }
            return false;
        }
        
        function isValidTokenFormat(token) {
            if (!token || typeof token !== 'string') {
                console.log('[TOKEN DEBUG] Token is null, undefined, or not a string:', token);
                return false;
            }
            
            // Check if token has the correct JWT format (3 parts separated by dots)
            const parts = token.split('.');
            console.log('[TOKEN DEBUG] Token parts count:', parts.length);
            
            if (parts.length !== 3) {
                console.log('[TOKEN DEBUG] Invalid JWT structure - expected 3 parts, got:', parts.length);
                console.log('[TOKEN DEBUG] Token parts:', parts);
                return false;
            }
            
            // Try to decode the payload to check if it's valid JSON
            try {
                const payload = JSON.parse(atob(parts[1]));
                console.log('[TOKEN DEBUG] Successfully decoded payload:', payload);
                
                // Check for required fields
                if (!payload || typeof payload !== 'object') {
                    console.log('[TOKEN DEBUG] Payload is not a valid object:', payload);
                    return false;
                }
                
                // Check for required JWT fields
                if (!payload.sub) {
                    console.log('[TOKEN DEBUG] Missing "sub" field in payload');
                    return false;
                }
                
                if (!payload.exp) {
                    console.log('[TOKEN DEBUG] Missing "exp" field in payload');
                    return false;
                }
                
                // Check expiration
                const currentTime = Math.floor(Date.now() / 1000);
                const isExpired = payload.exp < currentTime;
                console.log('[TOKEN DEBUG] Token expiration check:', {
                    currentTime,
                    tokenExp: payload.exp,
                    isExpired,
                    timeUntilExpiry: payload.exp - currentTime
                });
                
                return true;
            } catch (error) {
                console.log('[TOKEN DEBUG] Failed to decode payload:', error);
                console.log('[TOKEN DEBUG] Raw payload part:', parts[1]);
                return false;
            }
        }
        
        function clearInvalidToken() {
            console.log('[TOKEN DEBUG] Clearing invalid token from localStorage');
            const oldToken = localStorage.getItem('auth_token');
            console.log('[TOKEN DEBUG] Old token (first 50 chars):', oldToken ? oldToken.substring(0, 50) + '...' : 'null');
            localStorage.removeItem('auth_token');
            if (!isRedirecting) {
                isRedirecting = true;
                window.location.href = '/ui';
            }
        }
        
        function checkAuth() {
            const token = localStorage.getItem('auth_token');
            console.log('[TOKEN DEBUG] checkAuth called');
            console.log('[TOKEN DEBUG] Token exists:', !!token);
            
            if (!token) {
                console.log('[TOKEN DEBUG] No token found, redirecting to login');
                if (!isRedirecting) {
                    isRedirecting = true;
                window.location.href = '/ui';
                }
                return;
            }

            // First, validate token format
            console.log('[TOKEN DEBUG] Validating token format...');
            if (!isValidTokenFormat(token)) {
                console.log('[TOKEN DEBUG] Invalid token format detected, clearing token');
                clearInvalidToken();
                return;
            }

            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                const userEmail = payload.sub || 'user@example.com';
                const userName = userEmail ? userEmail.split('@')[0] : 'User';
                
                // Check if token is expired
                const currentTime = Math.floor(Date.now() / 1000);
                const timeSinceLastRefresh = currentTime - lastRefreshTime;
                
                console.log('[TOKEN DEBUG] Token expiration check:', {
                    currentTime,
                    tokenExp: payload.exp,
                    isExpired: payload.exp && payload.exp < currentTime,
                    isRefreshing: isRefreshingToken,
                    refreshAttempts,
                    timeSinceLastRefresh,
                    userEmail
                });
                
                if (payload.exp && payload.exp < currentTime) {
                    console.log('[TOKEN DEBUG] Token expired, attempting to refresh...');
                    
                    // Prevent rapid refresh attempts - wait at least 5 seconds between attempts
                    if (timeSinceLastRefresh < 5) {
                        console.log('[TOKEN DEBUG] Too soon since last refresh attempt, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    if (!isRefreshingToken && refreshAttempts < MAX_REFRESH_ATTEMPTS) {
                        lastRefreshTime = currentTime;
                        refreshToken();
                    } else {
                        console.log('[TOKEN DEBUG] Refresh already in progress or max attempts reached, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                    }
                    return;
                }
                
                console.log('[TOKEN DEBUG] Token is valid, updating UI');
                document.getElementById('userEmail').textContent = userEmail;
                document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                
                // Update mobile menu user info
                document.getElementById('mobileMenuEmail').textContent = userEmail;
                document.getElementById('mobileMenuAvatar').textContent = userName.charAt(0).toUpperCase();
            } catch (error) {
                console.error('[TOKEN DEBUG] Error decoding token:', error);
                clearInvalidToken();
            }
        }

        async function refreshToken() {
            if (isRefreshingToken) {
                console.log('Token refresh already in progress, skipping...');
                return;
            }
            
            if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
                console.log('Max refresh attempts reached, redirecting to login');
                if (!isRedirecting) {
                    isRedirecting = true;
                window.location.href = '/ui';
                }
                return;
            }
            
            isRefreshingToken = true;
            refreshAttempts++;
            
            try {
                const token = localStorage.getItem('auth_token');
                
                // Validate token format before attempting refresh
                if (!isValidTokenFormat(token)) {
                    console.log('Invalid token format in refreshToken, clearing token');
                    clearInvalidToken();
                    return;
                }
                
                const response = await fetch('/auth/refresh-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    localStorage.setItem('auth_token', data.access_token);
                    console.log('Token refreshed successfully');
                    refreshAttempts = 0; // Reset attempts on success
                    lastRefreshTime = 0; // Reset last refresh time
                    
                    // Verify the new token is not expired
                    try {
                        const newPayload = JSON.parse(atob(data.access_token.split('.')[1]));
                        const currentTime = Math.floor(Date.now() / 1000);
                        
                        if (newPayload.exp && newPayload.exp < currentTime) {
                            console.log('New token is also expired, redirecting to login');
                            if (!isRedirecting) {
                                isRedirecting = true;
                                window.location.href = '/ui';
                            }
                            return;
                        }
                        
                        // Update UI with the user info from the new token
                        const userEmail = newPayload.sub || 'user@example.com';
                        const userName = userEmail ? userEmail.split('@')[0] : 'User';
                        
                        document.getElementById('userEmail').textContent = userEmail;
                        document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                    } catch (error) {
                        console.error('Error updating UI after token refresh:', error);
                    }
                } else {
                    console.error('Failed to refresh token');
                    clearInvalidToken();
                }
            } catch (error) {
                console.error('Error refreshing token:', error);
                clearInvalidToken();
            } finally {
                isRefreshingToken = false;
            }
        }

        async function apiCall(url, options = {}) {
            const token = localStorage.getItem('auth_token');
            if (!token) {
                if (!isRedirecting) {
                    isRedirecting = true;
                    window.location.href = '/ui';
                }
                return;
            }

            // Validate token format before making API calls
            if (!isValidTokenFormat(token)) {
                console.log('[TOKEN DEBUG] Invalid token format in apiCall, clearing token');
                clearInvalidToken();
                return;
            }

            // Check for infinite loop before making the call
            if (checkForInfiniteLoop()) {
                return;
            }

            // Add authorization header
            options.headers = {
                'Authorization': `Bearer ${token}`,
                ...options.headers
            };

            try {
                const response = await fetch(url, options);
                
                // Reset consecutive failures on success
                if (response.ok) {
                    consecutiveFailures = 0;
                }
                
                // If token is expired, try to refresh and retry
                if (response.status === 401) {
                    consecutiveFailures++;
                    console.log('[TOKEN DEBUG] 401 error, consecutive failures:', consecutiveFailures);
                    
                    // Check for infinite loop
                    if (checkForInfiniteLoop()) {
                        return;
                    }
                    
                    console.log('Token expired, refreshing...');
                    
                    // Prevent multiple refresh attempts
                    if (isRefreshingToken) {
                        console.log('Token refresh already in progress, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    // Check if we've exceeded max attempts
                    if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
                        console.log('Max refresh attempts reached in apiCall, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    // Check if we've tried to refresh too recently
                    const currentTime = Math.floor(Date.now() / 1000);
                    if (currentTime - lastRefreshTime < 5) {
                        console.log('Too soon since last refresh attempt, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    isRefreshingToken = true;
                    refreshAttempts++;
                    lastRefreshTime = currentTime;
                    
                    try {
                        const refreshResponse = await fetch('/auth/refresh-token', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (refreshResponse.ok) {
                            const data = await refreshResponse.json();
                            localStorage.setItem('auth_token', data.access_token);
                            refreshAttempts = 0; // Reset on success
                            lastRefreshTime = 0; // Reset last refresh time
                            consecutiveFailures = 0; // Reset failures on successful refresh
                            
                            // Verify the new token is not expired
                            try {
                                const newPayload = JSON.parse(atob(data.access_token.split('.')[1]));
                                const currentTime = Math.floor(Date.now() / 1000);
                                
                                if (newPayload.exp && newPayload.exp < currentTime) {
                                    console.log('New token is also expired, redirecting to login');
                                    if (!isRedirecting) {
                                        isRedirecting = true;
                                        window.location.href = '/ui';
                                    }
                                    return;
                                }
                            } catch (error) {
                                console.error('Error verifying new token:', error);
                                if (!isRedirecting) {
                                    isRedirecting = true;
                                    window.location.href = '/ui';
                                }
                                return;
                            }
                            
                            // Retry the original request with new token
                            options.headers['Authorization'] = `Bearer ${data.access_token}`;
                            return await fetch(url, options);
                        } else {
                            // Refresh failed, clear token and redirect to login
                            console.log('Token refresh failed, clearing token and redirecting to login');
                            clearInvalidToken();
                            return;
                        }
                    } finally {
                        isRefreshingToken = false;
                    }
                }
                
                return response;
            } catch (error) {
                consecutiveFailures++;
                console.error('API call error:', error);
                console.log('[TOKEN DEBUG] API call failed, consecutive failures:', consecutiveFailures);
                
                // Check for infinite loop
                if (checkForInfiniteLoop()) {
                    return;
                }
                
                throw error;
            }
        }

        function logout() {
            localStorage.removeItem('auth_token');
            window.location.href = '/ui';
        }

        function generateLast30DaysData() {
            const dates = [];
            for (let i = 29; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                dates.push(`Day ${30 - i}`);
            }
            return dates;
        }

        function createMergedTrendsChart(metrics) {
            const rootStyles = getComputedStyle(document.documentElement);
            const primaryColor = rootStyles.getPropertyValue('--color-primary').trim();
            const secondaryColor = '#6366F1'; // Indigo for impressions
            const timeSeries = metrics.time_series || {};
            const dates = timeSeries.dates || [];
            const clicksData = timeSeries.clicks || [];
            const impressionsData = timeSeries.impressions || [];

            // Generate complete month dates including future dates with zero values
            let completeDates = [];
            let completeClicksData = [];
            let completeImpressionsData = [];

            if (dates.length > 0) {
                // Get the first date to determine the month and year
                const firstDate = new Date(dates[0]);
                const year = firstDate.getFullYear();
                const month = firstDate.getMonth();
                
                // Get the number of days in this month
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                
                // Create a map of existing data for quick lookup
                const dataMap = {};
                dates.forEach((dateStr, index) => {
                    dataMap[dateStr] = {
                        clicks: clicksData[index] || 0,
                        impressions: impressionsData[index] || 0
                    };
                });
                
                // Generate all dates for the month
                for (let day = 1; day <= daysInMonth; day++) {
                    const currentDate = new Date(year, month, day);
                    const dateStr = currentDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                    const today = new Date();
                    today.setHours(0, 0, 0, 0); // Reset time for accurate comparison
                    
                    completeDates.push(dateStr);
                    
                    if (dataMap[dateStr]) {
                        // Use real data if available
                        completeClicksData.push(dataMap[dateStr].clicks);
                        completeImpressionsData.push(dataMap[dateStr].impressions);
                    } else if (currentDate > today) {
                        // Future dates get zero values
                        completeClicksData.push(0);
                        completeImpressionsData.push(0);
                    } else {
                        // Past dates without data also get zero
                        completeClicksData.push(0);
                        completeImpressionsData.push(0);
                    }
                }
            }

            // Use complete data if available, otherwise fall back to original data
            const finalDates = completeDates.length > 0 ? completeDates : dates;
            const finalClicksData = completeClicksData.length > 0 ? completeClicksData : clicksData;
            const finalImpressionsData = completeImpressionsData.length > 0 ? completeImpressionsData : impressionsData;

            // Format dates to readable format like "1 Jun 2025"
            const formattedDates = finalDates.map(dateStr => {
                const date = new Date(dateStr);
                const day = date.getDate();
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = monthNames[date.getMonth()];
                const year = date.getFullYear();
                return `${day} ${month} ${year}`;
            });

            if (window.mergedTrendsChart && typeof window.mergedTrendsChart.destroy === 'function') {
                window.mergedTrendsChart.destroy();
            }

            const ctx = document.getElementById('mergedTrendsChart').getContext('2d');
            window.mergedTrendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: formattedDates,
                    datasets: [
                        {
                            label: 'Clicks',
                            data: finalClicksData,
                            borderColor: primaryColor,
                            backgroundColor: 'rgba(249, 115, 22, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4
                        },
                        {
                            label: 'Impressions',
                            data: finalImpressionsData,
                            borderColor: secondaryColor,
                            backgroundColor: 'rgba(99, 102, 241, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4
                        }
                    ]
                },
                options: {
                responsive: true,
                maintainAspectRatio: false,
                    plugins: { legend: { display: true } },
                scales: {
                    y: { beginAtZero: true, grid: { color: 'rgba(0, 0, 0, 0.05)' } },
                    x: { grid: { display: false }, ticks: {
                        callback: function(value, index, values) {
                            const label = this.getLabelForValue(value);
                            // Show first, middle, and last dates for better readability
                            if (label === formattedDates[0] || label === formattedDates[Math.floor(formattedDates.length/2)] || label === formattedDates[formattedDates.length-1]) {
                                return label;
                            }
                            return null;
                        }
                    } }
                    }
                }
            });
        }

        function updateDashboardMetrics(hasGSC = false) {
            if (hasGSC) {
                // Update overall score
                document.getElementById('seoScore').textContent = '65';
                document.getElementById('seoScoreChange').textContent = '+5%';
                document.getElementById('seoScoreChange').className = 'score-change positive';

                // Update visibility performance
                document.getElementById('impressionsValue').textContent = '21,450';
                document.getElementById('clicksValue').textContent = '1,234';
                document.getElementById('ctrValue').textContent = '5.8%';
                document.getElementById('ctrChange').textContent = '+0.8%';
                document.getElementById('ctrChange').className = 'metric-change positive';
                document.getElementById('avgPositionValue').textContent = '2.2';
                document.getElementById('avgPositionChange').textContent = '+0.5';
                document.getElementById('avgPositionChange').className = 'metric-change positive';
                document.getElementById('visibilityInsights').innerHTML = '<p>Good visibility with room for CTR improvement. High-opportunity keywords need optimization.</p>';

                // Update engagement & UX
                document.getElementById('performanceScore').textContent = '78';
                document.getElementById('lcpValue').textContent = '2.1s';
                document.getElementById('fcpValue').textContent = '1.2s';
                document.getElementById('clsValue').textContent = '0.08';
                document.getElementById('uxInsights').innerHTML = '<p>Performance is good but LCP could be improved. Consider optimizing images and reducing server response time.</p>';

                // Update mobile usability
                document.getElementById('mobileFriendly').textContent = 'Pass';
                document.getElementById('mobileIssues').textContent = '0';
                document.getElementById('mobileInsights').innerHTML = '<p>Mobile-friendly with no issues detected. Good user experience across devices.</p>';

                // Update indexing & crawlability
                document.getElementById('sitemapStatus').textContent = 'Healthy';
                document.getElementById('indexStatus').textContent = 'Good';
                document.getElementById('indexingInsights').innerHTML = '<p>Sitemap is properly configured and indexed. No crawl issues detected.</p>';

                // Update business context
                document.getElementById('businessType').textContent = 'SaaS';
                document.getElementById('targetMarket').textContent = 'B2B';
                document.getElementById('businessInsights').innerHTML = '<p>B2B SaaS business with technical audience. Focus on educational content and case studies.</p>';

                // Update keyword trends
                document.getElementById('totalKeywords').textContent = '1,247';
                document.getElementById('keywordAvgPosition').textContent = '3.2';
                document.getElementById('keywordOpportunities').textContent = '23';
                document.getElementById('brandedKeywords').textContent = '156';
                document.getElementById('keywordInsights').innerHTML = '<p>Strong keyword portfolio with 23 high-opportunity terms. Branded keywords performing well.</p>';

            } else {
                // Reset all metrics to empty state
                document.getElementById('seoScore').textContent = '0';
                document.getElementById('seoScoreChange').textContent = '+0%';
                
                // Reset visibility performance
                document.getElementById('impressionsValue').textContent = '0';
                document.getElementById('clicksValue').textContent = '0';
                document.getElementById('ctrValue').textContent = '0%';
                document.getElementById('ctrChange').textContent = '+0%';
                document.getElementById('avgPositionValue').textContent = 'N/A';
                document.getElementById('avgPositionChange').textContent = '+0.0';
                document.getElementById('visibilityInsights').innerHTML = '<p>Connect Google Search Console to see visibility insights</p>';

                // Reset engagement & UX
                document.getElementById('performanceScore').textContent = 'N/A';
                document.getElementById('lcpValue').textContent = 'N/A';
                document.getElementById('fcpValue').textContent = 'N/A';
                document.getElementById('clsValue').textContent = 'N/A';
                document.getElementById('uxInsights').innerHTML = '<p>Performance data will appear when connected</p>';

                // Reset mobile usability
                document.getElementById('mobileFriendly').textContent = 'N/A';
                document.getElementById('mobileIssues').textContent = '0';
                document.getElementById('mobileInsights').innerHTML = '<p>Mobile test results will appear here</p>';

                // Reset indexing & crawlability
                document.getElementById('sitemapStatus').textContent = 'N/A';
                document.getElementById('indexStatus').textContent = 'N/A';
                document.getElementById('indexingInsights').innerHTML = '<p>Indexing health will be analyzed</p>';

                // Reset business context
                document.getElementById('businessType').textContent = 'N/A';
                document.getElementById('targetMarket').textContent = 'N/A';
                document.getElementById('businessInsights').innerHTML = '<p>Business analysis will provide context</p>';

                // Reset keyword trends
                document.getElementById('totalKeywords').textContent = '0';
                document.getElementById('keywordAvgPosition').textContent = 'N/A';
                document.getElementById('keywordOpportunities').textContent = '0';
                document.getElementById('brandedKeywords').textContent = '0';
                document.getElementById('keywordInsights').innerHTML = '<p>Loading keyword performance insights...</p>';
            }
        }

        function updateDashboardMetricsWithRealData(metrics) {
            console.log('[DEBUG] Updating dashboard with real data:', metrics);
            
            const summary = metrics.summary || {};
            console.log('[DEBUG] Summary data:', summary);
            
            // Store summary data globally
            window.metricsData.summary = summary;
            
            // Calculate SEO score based on real metrics
            const seoScore = calculateSEOScore(summary);
            
            // Calculate SEO score change (use backend data if available, otherwise fallback to session-based)
            const seoScoreChange = summary.seo_score_change !== undefined ? summary.seo_score_change : calculateChange('seo_score', seoScore);
            
            // Update overall score
            document.getElementById('seoScore').textContent = seoScore;
            updateSEOScoreChange(seoScoreChange);

            // Update visibility performance with real data
            document.getElementById('impressionsValue').textContent = summary.total_impressions?.toLocaleString() || '0';
            document.getElementById('clicksValue').textContent = summary.total_clicks?.toLocaleString() || '0';
            document.getElementById('ctrValue').textContent = summary.avg_ctr ? `${(summary.avg_ctr * 100).toFixed(2)}%` : '0%';
            document.getElementById('avgPositionValue').textContent = summary.avg_position?.toFixed(1) || 'N/A';
            
            // Update change indicators - use backend-provided changes when available
            console.log(`[GROWTH DEBUG] === VISIBILITY PERFORMANCE METRICS ===`);
            const impressionsChange = summary.impressions_change || calculateChange('total_impressions', summary.total_impressions);
            const clicksChange = summary.clicks_change || calculateChange('total_clicks', summary.total_clicks);
            updateChangeIndicator('impressionsChange', impressionsChange, '', true);
            updateChangeIndicator('clicksChange', clicksChange, '', true);
            updateChangeIndicator('ctrChange', summary.ctr_change, '%', true);
            updateChangeIndicator('avgPositionChange', summary.position_change, '', false);
            
            // Generate insights based on real data
            generateVisibilityInsights(summary);
            generateUXInsights(metrics);
            generateMobileInsights(metrics);
            generateIndexingInsights(metrics);
            generateBusinessInsights(metrics);
            generateKeywordInsights(metrics);
        }

        // Store previous values for change calculation
        let previousMetrics = JSON.parse(localStorage.getItem('previousMetrics') || '{}');
        console.log(`[GROWTH DEBUG] Loaded previous metrics from localStorage:`, previousMetrics);

        function calculateChange(metricKey, currentValue) {
            if (currentValue === undefined || currentValue === null) {
                console.log(`[GROWTH DEBUG] ${metricKey}: Current value is undefined/null`);
                return 0;
            }
            
            const previousValue = previousMetrics[metricKey];
            if (previousValue === undefined || previousValue === null) {
                console.log(`[GROWTH DEBUG] ${metricKey}: First data point - Previous: null, Current: ${currentValue}, Change: 0 (first time)`);
                // Store current value for next comparison and return 0 for first time
                previousMetrics[metricKey] = currentValue;
                localStorage.setItem('previousMetrics', JSON.stringify(previousMetrics));
                console.log(`[GROWTH DEBUG] ${metricKey}: Stored to localStorage for next comparison`);
                return 0;
            }
            
            // Handle string values (categorical data)
            if (typeof currentValue === 'string') {
                const hasChanged = currentValue !== previousValue;
                const changeValue = hasChanged ? 1 : 0;
                console.log(`[GROWTH DEBUG] ${metricKey}: String comparison - Previous: "${previousValue}", Current: "${currentValue}", Changed: ${hasChanged}, Change Value: ${changeValue}`);
                // Update stored value
                previousMetrics[metricKey] = currentValue;
                localStorage.setItem('previousMetrics', JSON.stringify(previousMetrics));
                console.log(`[GROWTH DEBUG] ${metricKey}: Updated localStorage with new string value`);
                return changeValue;
            }
            
            // Handle numeric values
            const change = currentValue - previousValue;
            console.log(`[GROWTH DEBUG] ${metricKey}: Numeric calculation - Previous: ${previousValue}, Current: ${currentValue}, Change: ${change}`);
            // Update stored value
            previousMetrics[metricKey] = currentValue;
            localStorage.setItem('previousMetrics', JSON.stringify(previousMetrics));
            console.log(`[GROWTH DEBUG] ${metricKey}: Updated localStorage with new numeric value`);
            
            return change;
        }

        function updateChangeIndicator(elementId, value, unit = '', higherIsBetter = true) {
            const element = document.getElementById(elementId);
            if (value === undefined || value === null) {
                console.log(`[GROWTH DEBUG] ${elementId}: Updating indicator with N/A value`);
                element.textContent = 'N/A';
                element.className = 'metric-change';
                return;
            }

            // Handle categorical changes (business type, target market)
            if (elementId.includes('businessType') || elementId.includes('targetMarket')) {
                let class_name = 'metric-change';
                let displayText = '';
                if (value === 0) {
                    class_name += ' neutral';
                    displayText = 'No Change';
                } else {
                    class_name += ' positive'; // Show changes as positive (informational)
                    displayText = 'Updated';
                }
                console.log(`[GROWTH DEBUG] ${elementId}: Categorical indicator - Value: ${value}, Display: "${displayText}", Class: "${class_name}"`);
                element.className = class_name;
                element.textContent = displayText;
                return;
            }

            const isPositive = higherIsBetter ? value > 0 : value < 0;
            const isNegative = higherIsBetter ? value < 0 : value > 0;
            const isZero = value === 0;
            
            let class_name = 'metric-change';
            if (isZero) {
                class_name += ' neutral';
            } else if (isPositive) {
                class_name += ' positive';
            } else if (isNegative) {
                class_name += ' negative';
            }

            element.className = class_name;
            
            const prefix = value > 0 ? '+' : (value < 0 ? '' : '+');
            const formattedValue = unit === '%' ? (value * 100).toFixed(2) : value.toFixed(1);
            const displayText = `${prefix}${formattedValue}${unit}`;
            
            console.log(`[GROWTH DEBUG] ${elementId}: Numeric indicator - Value: ${value}, Unit: "${unit}", Higher is Better: ${higherIsBetter}, Display: "${displayText}", Class: "${class_name}"`);
            element.textContent = displayText;
        }

        function updateSEOScoreChange(change) {
            const element = document.getElementById('seoScoreChange');
            if (change === undefined || change === null) {
                element.textContent = 'N/A';
                element.className = 'score-change';
                return;
            }

            const isPositive = change > 0;
            const isNegative = change < 0;
            const isZero = change === 0;
            
            let class_name = 'score-change';
            if (isZero) {
                class_name += ' neutral';
                element.style.color = '#6B7280'; // Grey for no change
            } else if (isPositive) {
                class_name += ' positive';
                element.style.color = ''; // Reset to CSS default (green)
            } else if (isNegative) {
                class_name += ' negative';
                element.style.color = ''; // Reset to CSS default (red)
            }

            element.className = class_name;
            
            const prefix = change > 0 ? '+' : (change < 0 ? '' : '+');
            element.textContent = `${prefix}${change}`;
        }

        function generateVisibilityInsights(summary) {
            let insight = '';
            if (summary.total_impressions > 0) {
                if (summary.avg_ctr < 2) {
                    insight = 'CTR is below average. Consider optimizing meta titles and descriptions for better click-through rates.';
                } else if (summary.avg_position > 10) {
                    insight = 'Average position needs improvement. Focus on content optimization and backlink building.';
                } else {
                    insight = 'Good visibility performance. Continue optimizing for high-opportunity keywords.';
                }
            } else {
                insight = 'No search visibility data yet. This is normal for new websites.';
            }
            document.getElementById('visibilityInsights').innerHTML = `<p>${insight}</p>`;
        }

        function generateUXInsights(metrics) {
            // UX insights are now generated when fetchPageSpeedData() is called from loadRealMetrics()
            document.getElementById('uxInsights').innerHTML = '<p>Loading performance insights...</p>';
        }

        async function fetchPageSpeedData() {
            setMetricLoadingState('ux', 'loading');
            try {
                console.log('[DEBUG] Fetching PageSpeed data...');
                const response = await apiCall('/auth/pagespeed/metrics');
                console.log('[DEBUG] PageSpeed response status:', response.status);
                
                if (response.ok) {
                    const psiData = await response.json();
                    console.log('[DEBUG] PageSpeed data received:', psiData);
                    updateUXMetrics(psiData);
                    generateUXInsightsFromData(psiData);
                    setMetricLoadingState('ux', 'done');
                } else {
                    setMetricLoadingState('ux', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load PageSpeed data:', errorText);
                    document.getElementById('uxInsights').innerHTML = '<p>Performance insights will be available when PageSpeed data is connected.</p>';
                }
            } catch (error) {
                setMetricLoadingState('ux', 'done');
                console.error('Error loading PageSpeed data:', error);
                document.getElementById('uxInsights').innerHTML = '<p>Performance insights will be available when PageSpeed data is connected.</p>';
            }
        }

        function updateUXMetrics(psiData) {
            console.log('[DEBUG] Updating UX metrics with data:', psiData);
            
            // Store UX data globally
            window.metricsData.ux = {
                performance_score: psiData.performance_score,
                lcp: psiData.lcp?.value,
                fcp: psiData.fcp?.value,
                cls: psiData.cls?.value
            };
            
            console.log(`[GROWTH DEBUG] === ENGAGEMENT & UX METRICS ===`);
            // Update performance score
            const performanceScore = psiData.performance_score;
            console.log('[DEBUG] Performance score:', performanceScore);
            document.getElementById('performanceScore').textContent = (performanceScore !== undefined && performanceScore !== null) ? performanceScore : 'N/A';
            const performanceScoreChange = psiData.performance_score_change || calculateChange('performance_score', performanceScore);
            updateChangeIndicator('performanceScoreChange', performanceScoreChange, '', true);
            
            // Update LCP
            const lcpValue = psiData.lcp?.value;
            console.log('[DEBUG] LCP value:', lcpValue);
            document.getElementById('lcpValue').textContent = (lcpValue !== undefined && lcpValue !== null) ? `${lcpValue.toFixed(1)}s` : 'N/A';
            const lcpChange = psiData.lcp_change || calculateChange('lcp_value', lcpValue);
            updateChangeIndicator('lcpChange', lcpChange, 's', false);
            
            // Update FCP
            const fcpValue = psiData.fcp?.value;
            console.log('[DEBUG] FCP value:', fcpValue);
            document.getElementById('fcpValue').textContent = (fcpValue !== undefined && fcpValue !== null) ? `${fcpValue.toFixed(1)}s` : 'N/A';
            const fcpChange = psiData.fcp_change || calculateChange('fcp_value', fcpValue);
            updateChangeIndicator('fcpChange', fcpChange, 's', false);
            
            // Update CLS
            const clsValue = psiData.cls?.value;
            console.log('[DEBUG] CLS value:', clsValue);
            document.getElementById('clsValue').textContent = (clsValue !== undefined && clsValue !== null) ? Math.round(clsValue) : 'N/A';
            const clsChange = psiData.cls_change || calculateChange('cls_value', clsValue);
            updateChangeIndicator('clsChange', clsChange, '', false);
            
            // Update status indicator
            const statusIndicator = document.getElementById('uxStatus');
            if (performanceScore >= 90) {
                statusIndicator.textContent = 'Excellent';
                statusIndicator.className = 'status-indicator good';
            } else if (performanceScore >= 70) {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (performanceScore >= 50) {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else {
                statusIndicator.textContent = 'Poor';
                statusIndicator.className = 'status-indicator error';
            }
            
            // Recalculate overall SEO score
            recalculateOverallSEOScore();
        }

        function generateUXInsightsFromData(psiData) {
            let insight = '';
            const performanceScore = psiData.performance_score;
            const lcp = psiData.lcp?.value;
            const fcp = psiData.fcp?.value;
            const cls = psiData.cls?.value;
            
            if (performanceScore >= 90) {
                insight = 'Excellent performance! Your site loads quickly and provides a great user experience.';
            } else if (performanceScore >= 70) {
                insight = 'Good performance with room for improvement. Consider optimizing images and reducing server response time.';
            } else if (performanceScore >= 50) {
                insight = 'Performance needs improvement. Focus on Core Web Vitals optimization for better user experience.';
            } else {
                insight = 'Performance requires immediate attention. Prioritize speed optimizations to improve user experience and SEO.';
            }
            
            // Add specific recommendations based on Core Web Vitals
            if (lcp && lcp > 2.5) {
                insight += ' LCP is slow - optimize images and reduce server response time.';
            }
            if (fcp && fcp > 1.8) {
                insight += ' FCP needs improvement - optimize critical rendering path.';
            }
            if (cls && cls > 0.1) {
                insight += ' CLS issues detected - prevent layout shifts during page load.';
            }
            
            document.getElementById('uxInsights').innerHTML = `<p>${insight}</p>`;
        }

        function generateMobileInsights(metrics) {
            // Mobile insights are now generated when fetchMobileData() is called from loadRealMetrics()
            document.getElementById('mobileInsights').innerHTML = '<p>Loading mobile usability insights...</p>';
        }

        async function fetchMobileData() {
            setMetricLoadingState('mobile', 'loading');
            try {
                const response = await apiCall('/auth/mobile/metrics');
                
                if (response.ok) {
                    const mobileData = await response.json();
                    updateMobileMetrics(mobileData);
                    generateMobileInsightsFromData(mobileData);
                    setMetricLoadingState('mobile', 'done');
                } else {
                    setMetricLoadingState('mobile', 'done');
                    console.log('[DEBUG] Failed to load mobile data, showing placeholder');
                    document.getElementById('mobileInsights').innerHTML = '<p>Mobile test results will appear here</p>';
                }
            } catch (error) {
                setMetricLoadingState('mobile', 'done');
                console.error('Error loading mobile data:', error);
                document.getElementById('mobileInsights').innerHTML = '<p>Mobile test results will appear here</p>';
            }
        }

        function updateMobileMetrics(mobileData) {
            // Store mobile data globally
            window.metricsData.mobile = {
                mobile_friendly: mobileData.mobile_friendly,
                issues_count: mobileData.issues_count || 0,
                performance_score: mobileData.performance_score
            };
            
            // Update mobile friendly status
            const mobileFriendly = mobileData.mobile_friendly;
            document.getElementById('mobileFriendly').textContent = mobileFriendly || 'N/A';
            
            // Update status indicator color
            const statusIndicator = document.getElementById('mobileStatus');
            if (mobileFriendly === 'Pass' || mobileFriendly === 'Yes') {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (mobileFriendly === 'Fail' || mobileFriendly === 'No') {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else {
                statusIndicator.textContent = 'Unknown';
                statusIndicator.className = 'status-indicator';
            }
            
            // Update issues count
            const issuesCount = mobileData.issues_count || 0;
            document.getElementById('mobileIssues').textContent = issuesCount;
            console.log(`[GROWTH DEBUG] === MOBILE USABILITY METRICS ===`);
            const mobileIssuesChange = calculateChange('mobile_issues_count', issuesCount);
            updateChangeIndicator('mobileIssuesChange', mobileIssuesChange, '', false);
            
            // Recalculate overall SEO score
            recalculateOverallSEOScore();
        }

        function generateMobileInsightsFromData(mobileData) {
            const issues = mobileData.issues || [];
            let html = '';

            if (issues.length > 0) {
                // Display each issue in its own div container
                issues.forEach(issue => {
                    // Handle both old string format and new detailed object format
                    if (typeof issue === 'string') {
                        html += `<div class="mobile-issue-box"><p>${issue}</p></div>`;
                    } else if (typeof issue === 'object' && issue.title) {
                        // New detailed format - merge description and impact, hide solution
                        html += `
                            <div class="mobile-issue-box">
                                <h4>${issue.title}</h4>
                                <p>${issue.description} ${issue.impact}</p>
                            </div>
                        `;
                    }
                });
            } else {
                // Show the positive insight if no issues
                html += `<p>${mobileData.insights || 'No mobile usability issues detected.'}</p>`;
            }

            document.getElementById('mobileInsights').innerHTML = html;
        }

        function generateIndexingInsights(metrics) {
            // Indexing insights are now generated when fetchIndexingData() is called from loadRealMetrics()
            document.getElementById('indexingInsights').innerHTML = '<p>Loading indexing insights...</p>';
        }

        async function fetchIndexingData() {
            setMetricLoadingState('indexing', 'loading');
            try {
                console.log('[DEBUG] Fetching indexing data...');
                const response = await apiCall('/auth/indexing/metrics');
                console.log('[DEBUG] Indexing response status:', response.status);
                
                if (response.ok) {
                    const indexingData = await response.json();
                    console.log('[DEBUG] Indexing data received:', indexingData);
                    updateIndexingMetrics(indexingData);
                    generateIndexingInsightsFromData(indexingData);
                    setMetricLoadingState('indexing', 'done');
                } else {
                    setMetricLoadingState('indexing', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load indexing data:', errorText);
                    document.getElementById('indexingInsights').innerHTML = '<p>Indexing health will be analyzed when connected to Google Search Console.</p>';
                }
            } catch (error) {
                setMetricLoadingState('indexing', 'done');
                console.error('Error loading indexing data:', error);
                document.getElementById('indexingInsights').innerHTML = '<p>Indexing health will be analyzed when connected to Google Search Console.</p>';
            }
        }

        function updateIndexingMetrics(indexingData) {
            // Store indexing data globally
            window.metricsData.indexing = {
                sitemap_status: indexingData.sitemap_status,
                index_status: indexingData.index_status
            };
            
            // Update sitemap status
            const sitemapStatus = indexingData.sitemap_status;
            document.getElementById('sitemapStatus').textContent = sitemapStatus || 'N/A';
            
            // Update index status
            const indexStatus = indexingData.index_status;
            document.getElementById('indexStatus').textContent = indexStatus || 'N/A';
            
            // Update status indicator color
            const statusIndicator = document.getElementById('indexingStatus');
            if ((sitemapStatus === 'Active' && (indexStatus === 'PASS' || indexStatus === 'NEUTRAL')) ||
                (sitemapStatus === 'Active' && !indexStatus)) {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (sitemapStatus === 'Pending' || indexStatus === 'Unknown') {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else if (sitemapStatus === 'Error' || indexStatus === 'FAIL') {
                statusIndicator.textContent = 'Poor';
                statusIndicator.className = 'status-indicator error';
            } else {
                statusIndicator.textContent = 'Unknown';
                statusIndicator.className = 'status-indicator';
            }
            
            // Recalculate overall SEO score
            recalculateOverallSEOScore();
        }

        function generateIndexingInsightsFromData(indexingData) {
            const insights = indexingData.insights || [];
            if (insights.length > 0) {
                const insightsHtml = insights.map(insight => `<p>${insight}</p>`).join('');
                document.getElementById('indexingInsights').innerHTML = insightsHtml;
            } else {
                document.getElementById('indexingInsights').innerHTML = '<p>Indexing health analysis completed. No major issues detected.</p>';
            }
        }

        function generateBusinessInsights(metrics) {
            // Business insights are now generated when fetchBusinessData() is called from loadRealMetrics()
            document.getElementById('businessInsights').innerHTML = '<p>Loading business context insights...</p>';
        }

        async function fetchBusinessData() {
            setMetricLoadingState('business', 'loading');
            try {
                console.log('[DEBUG] Fetching business context data...');
                const response = await apiCall('/auth/business/metrics');
                console.log('[DEBUG] Business context response status:', response.status);
                
                if (response.ok) {
                    const businessData = await response.json();
                    console.log('[DEBUG] Business context data received:', businessData);
                    updateBusinessMetrics(businessData);
                    generateBusinessInsightsFromData(businessData);
                    setMetricLoadingState('business', 'done');
                } else {
                    setMetricLoadingState('business', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load business context data:', errorText);
                    document.getElementById('businessInsights').innerHTML = '<p>Business context analysis will be available when connected to Google Search Console.</p>';
                }
            } catch (error) {
                setMetricLoadingState('business', 'done');
                console.error('Error loading business context data:', error);
                document.getElementById('businessInsights').innerHTML = '<p>Business context analysis will be available when connected to Google Search Console.</p>';
            }
        }

        function updateBusinessMetrics(businessData) {
            // Store business data globally
            window.metricsData.business = {
                business_type: businessData.business_type,
                target_market: businessData.target_market,
                business_complexity_score: businessData.business_complexity_score || 0,
                service_count: businessData.service_count || 0
            };
            
            // Update business type
            const businessType = businessData.business_type;
            document.getElementById('businessType').textContent = businessType || 'N/A';
            
            // Update target market
            const targetMarket = businessData.target_market;
            document.getElementById('targetMarket').textContent = targetMarket || 'N/A';
            
            // Update complexity score and service count
            const complexityScore = businessData.business_complexity_score || 0;
            const serviceCount = businessData.service_count || 0;
            document.getElementById('businessComplexity').textContent = complexityScore.toFixed(1);
            document.getElementById('serviceCount').textContent = serviceCount.toString();
            
            // Update change indicators using the same calculation logic as primary indicators
            console.log(`[GROWTH DEBUG] === BUSINESS CONTEXT METRICS ===`);
            const businessTypeChange = calculateChange('business_type', businessType);
            const targetMarketChange = calculateChange('target_market', targetMarket);
            const businessComplexityChange = calculateChange('business_complexity_score', complexityScore);
            const serviceCountChange = calculateChange('service_count', serviceCount);
            updateChangeIndicator('businessTypeChange', businessTypeChange, '', true);
            updateChangeIndicator('targetMarketChange', targetMarketChange, '', true);
            updateChangeIndicator('businessComplexityChange', businessComplexityChange, '', true);
            updateChangeIndicator('serviceCountChange', serviceCountChange, '', true);
            
            // Update status indicator color based on complexity score
            const statusIndicator = document.getElementById('businessStatus');
            if (complexityScore >= 7) {
                statusIndicator.textContent = 'Advanced';
                statusIndicator.className = 'status-indicator good';
            } else if (complexityScore >= 5) {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (complexityScore >= 3) {
                statusIndicator.textContent = 'Basic';
                statusIndicator.className = 'status-indicator warning';
            } else {
                statusIndicator.textContent = 'Limited';
                statusIndicator.className = 'status-indicator error';
            }
        }

        function generateBusinessInsightsFromData(businessData) {
            // Handle both string and array formats for insights and recommendations
            let insights = businessData.insights || [];
            let recommendations = businessData.seo_recommendations || [];
            
            // Convert strings to arrays if needed
            if (typeof insights === 'string') {
                insights = insights ? [insights] : [];
            }
            if (typeof recommendations === 'string') {
                recommendations = recommendations ? [recommendations] : [];
            }
            
            // Ensure they are arrays
            if (!Array.isArray(insights)) insights = [];
            if (!Array.isArray(recommendations)) recommendations = [];
            
            let insightsHtml = '';
            
            // Add business insights without heading
            if (insights.length > 0) {
                insights.forEach(insight => {
                    insightsHtml += `<p>${insight}</p>`;
                });
            }
            
            // Hide SEO recommendations - save for later use
            // if (recommendations.length > 0) {
            //     recommendations.forEach(rec => {
            //         insightsHtml += `<p>• ${rec}</p>`;
            //     });
            // }
            
            if (insightsHtml) {
                document.getElementById('businessInsights').innerHTML = insightsHtml;
            } else {
                document.getElementById('businessInsights').innerHTML = '<p>Business context analysis completed. No specific insights available.</p>';
            }
        }

        function generateKeywordInsights(metrics) {
            // This function is now handled by updateKeywordMetrics when real data is loaded
            // The insights are generated on the backend and displayed via loadKeywordData()
            document.getElementById('keywordInsights').innerHTML = '<p>Loading keyword performance insights...</p>';
        }

        // Mobile Menu Functions
        function toggleMobileMenu() {
            const menu = document.getElementById('mobileMenu');
            const overlay = document.getElementById('mobileMenuOverlay');
            
            if (menu.classList.contains('active')) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        }

        function openMobileMenu() {
            const menu = document.getElementById('mobileMenu');
            const overlay = document.getElementById('mobileMenuOverlay');
            
            menu.classList.add('active');
            overlay.classList.add('active');
            
            // Prevent body scroll when menu is open
            document.body.style.overflow = 'hidden';
        }

        function closeMobileMenu() {
            const menu = document.getElementById('mobileMenu');
            const overlay = document.getElementById('mobileMenuOverlay');
            
            menu.classList.remove('active');
            overlay.classList.remove('active');
            
            // Restore body scroll
            document.body.style.overflow = '';
        }

        // Close menu on escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeMobileMenu();
            }
        });

        async function initDashboard() {
            checkAuth();
            const hasGSC = await checkGSCConnection();
            console.log('[DEBUG] Dashboard init - hasGSC:', hasGSC);
            
            if (hasGSC) {
                // Fetch real metrics from GSC
                await loadRealMetrics();
            } else {
                // Show empty state
                updateDashboardMetrics(false);
                createMergedTrendsChart({});
            }
        }

        async function checkGSCConnection() {
            try {
                console.log('[DEBUG] Checking GSC connection...');
                const response = await apiCall('/auth/gsc/properties');

                console.log('[DEBUG] GSC response status:', response.status);

                if (response.status === 401 || response.status === 404) {
                    console.log('[DEBUG] Auth error (401/404), showing banner');
                    showGSCBanner();
                    return false;
                }
                if (!response.ok) {
                    const errorText = await response.text();
                    console.log('[DEBUG] GSC connection error:', errorText);
                    
                    // Check if it's a credentials issue
                    if (response.status === 500 && errorText.includes('credentials')) {
                        console.log('[DEBUG] Credentials issue, showing reauth banner');
                        showGSCBannerWithReauth();
                    } else {
                        console.log('[DEBUG] Other error, showing regular banner');
                        showGSCBanner();
                    }
                    return false;
                }

                const properties = await response.json();
                console.log('[DEBUG] GSC properties received:', properties);
                
                if (!properties || properties.length === 0) {
                    console.log('[DEBUG] No properties found, showing banner');
                    showGSCBanner();
                    return false;
                }

                const isDemoMode = properties.some(p => p.siteUrl.includes('example.com') || p.siteUrl.includes('demo-site.com'));
                console.log('[DEBUG] Is demo mode:', isDemoMode);
                
                if (isDemoMode) {
                    console.log('[DEBUG] Demo mode detected, showing banner');
                    showGSCBanner();
                    return false;
                }

                console.log('[DEBUG] Valid GSC connection found, hiding banner');
                hideGSCBanner();
                return true;
            } catch (error) {
                console.log('[DEBUG] Exception in checkGSCConnection:', error);
                showGSCBanner();
                return false;
            }
        }

        function showGSCBanner() {
            document.getElementById('gscBanner').classList.remove('hidden');
        }

        function hideGSCBanner() {
            document.getElementById('gscBanner').classList.add('hidden');
        }

        function showGSCBannerWithReauth() {
            const banner = document.getElementById('gscBanner');
            banner.classList.remove('hidden');
            
            // Update banner content to show re-authentication option
            const bannerText = banner.querySelector('.banner-text p');
            if (bannerText) {
                bannerText.innerHTML = 'Your Google Search Console connection has an issue. <button onclick="clearCredentials()" class="btn-link">Click here to re-authenticate</button> or connect a new account.';
            }
        }

        async function clearCredentials() {
            try {
                const response = await apiCall('/auth/gsc/clear-credentials', {
                    method: 'POST'
                });

                if (response.ok) {
                    // Redirect to setup wizard
                    window.location.href = '/setup';
                } else {
                    alert('Failed to clear credentials. Please try again.');
                }
            } catch (error) {
                console.error('Error clearing credentials:', error);
                alert('Failed to clear credentials. Please try again.');
            }
        }

        function connectGSC() {
            window.location.href = '/setup';
        }

        async function refreshMetrics() {
            const refreshBtn = document.getElementById('refreshBtn');
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.classList.add('loading');
            
            try {
                const response = await apiCall('/auth/gsc/refresh', {
                    method: 'POST'
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Metrics refreshed successfully:', data);
                    
                    // Reload the dashboard with fresh data
                    await loadRealMetrics();
                } else {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to refresh data');
                }
            } catch (error) {
                console.error('Error refreshing metrics:', error);
                showErrorMessage('Could not refresh data. Your connection to Google may have been lost.');
                
                // Force the banner to show with a helpful message
                const banner = document.getElementById('gscBanner');
                const bannerText = banner.querySelector('.banner-text p');
                
                if (bannerText) {
                    bannerText.textContent = 'We couldn\'t refresh your data because the connection to Google Search Console was lost. Please reconnect to continue.';
                }
                banner.classList.remove('hidden');

            } finally {
                // Reset button state after a short delay to allow animation to be seen
                setTimeout(() => {
                    refreshBtn.disabled = false;
                    refreshBtn.classList.remove('loading');
                }, 500);
            }
        }

        function showErrorMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'error-message';
            messageDiv.textContent = message;
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.padding = '1rem';
            messageDiv.style.borderRadius = '8px';
            messageDiv.style.backgroundColor = '#ef4444';
            messageDiv.style.color = 'white';
            messageDiv.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
            messageDiv.style.fontWeight = '400';
            document.body.appendChild(messageDiv);
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 3000);
        }

        async function loadRealMetrics() {
            showMetricsLoadingPopup();
            resetMetricsLoadingState();
            try {
                setMetricLoadingState('visibility', 'loading');
                const response = await apiCall('/auth/gsc/metrics');
                if (response.ok) {
                    const metrics = await response.json();
                    updateDashboardMetricsWithRealData(metrics);
                    createMergedTrendsChart(metrics);
                    showWebsiteInfo(metrics);
                    showDateRange(metrics);
                    setMetricLoadingState('visibility', 'done');
                    setMetricLoadingState('organic', 'done');
                    setMetricLoadingState('impressions', 'done');
                    
                    // Fetch all other data types in parallel
                    await Promise.all([
                        loadKeywordData(),
                        fetchPageSpeedData(),
                        fetchMobileData(),
                        fetchIndexingData(),
                        fetchBusinessData()
                    ]);
                } else {
                    setMetricLoadingState('visibility', 'done');
                    setMetricLoadingState('organic', 'done');
                    setMetricLoadingState('impressions', 'done');
                    setMetricLoadingState('keywords', 'done');
                    setMetricLoadingState('ux', 'done');
                    setMetricLoadingState('mobile', 'done');
                    setMetricLoadingState('indexing', 'done');
                    setMetricLoadingState('business', 'done');
                    updateDashboardMetrics(false);
                    createMergedTrendsChart({});
                    hideWebsiteInfo();
                    hideDateRange();
                }
            } catch (error) {
                setMetricLoadingState('visibility', 'done');
                setMetricLoadingState('organic', 'done');
                setMetricLoadingState('impressions', 'done');
                setMetricLoadingState('keywords', 'done');
                setMetricLoadingState('ux', 'done');
                setMetricLoadingState('mobile', 'done');
                setMetricLoadingState('indexing', 'done');
                setMetricLoadingState('business', 'done');
                updateDashboardMetrics(false);
                createMergedTrendsChart({});
                hideWebsiteInfo();
                hideDateRange();
            }
        }

        async function loadKeywordData() {
            setMetricLoadingState('keywords', 'loading');
            try {
                const response = await apiCall('/auth/keyword/metrics');
                if (response.ok) {
                    const keywordData = await response.json();
                    updateKeywordMetrics(keywordData);
                    setMetricLoadingState('keywords', 'done');
                } else {
                    setMetricLoadingState('keywords', 'done');
                }
            } catch (error) {
                setMetricLoadingState('keywords', 'done');
            }
        }

        function updateKeywordMetrics(keywordData) {
            // Store keyword data globally
            window.metricsData.keywords = {
                total_keywords: keywordData.total_keywords || 0,
                avg_position: keywordData.avg_position,
                opportunities: keywordData.opportunities || 0,
                branded_keywords: keywordData.branded_keywords || 0
            };
            
            // Update keyword metrics in the dashboard
            const totalKeywords = keywordData.total_keywords || 0;
            const avgPosition = keywordData.avg_position;
            const opportunities = keywordData.opportunities || 0;
            const brandedKeywords = keywordData.branded_keywords || 0;
            
            document.getElementById('totalKeywords').textContent = totalKeywords.toLocaleString();
            document.getElementById('keywordAvgPosition').textContent = avgPosition?.toFixed(1) || 'N/A';
            document.getElementById('keywordOpportunities').textContent = opportunities.toLocaleString();
            document.getElementById('brandedKeywords').textContent = brandedKeywords.toLocaleString();
            
            // Update change indicators
            console.log(`[GROWTH DEBUG] === KEYWORD TRENDS METRICS ===`);
            const totalKeywordsChange = calculateChange('total_keywords', totalKeywords);
            const keywordAvgPositionChange = calculateChange('keyword_avg_position', avgPosition);
            const keywordOpportunitiesChange = calculateChange('keyword_opportunities', opportunities);
            const brandedKeywordsChange = calculateChange('branded_keywords', brandedKeywords);
            updateChangeIndicator('totalKeywordsChange', totalKeywordsChange, '', true);
            updateChangeIndicator('keywordAvgPositionChange', keywordAvgPositionChange, '', false);
            updateChangeIndicator('keywordOpportunitiesChange', keywordOpportunitiesChange, '', true);
            updateChangeIndicator('brandedKeywordsChange', brandedKeywordsChange, '', true);
            
            // Update keyword insights
            if (keywordData.keyword_insights) {
                document.getElementById('keywordInsights').innerHTML = `<p>${keywordData.keyword_insights}</p>`;
            }
            
            // Update keywords list
            updateKeywordsList(keywordData.keywords_list || []);
            
            // Update status indicator based on keyword performance
            const statusIndicator = document.getElementById('keywordStatus');
            if (keywordData.total_keywords > 0) {
                if (keywordData.avg_position <= 3) {
                    statusIndicator.textContent = 'Excellent';
                    statusIndicator.className = 'status-indicator good';
                } else if (keywordData.avg_position <= 10) {
                    statusIndicator.textContent = 'Good';
                    statusIndicator.className = 'status-indicator good';
                } else if (keywordData.avg_position <= 20) {
                    statusIndicator.textContent = 'Needs Work';
                    statusIndicator.className = 'status-indicator warning';
                } else {
                    statusIndicator.textContent = 'Poor';
                    statusIndicator.className = 'status-indicator error';
                }
            } else {
                statusIndicator.textContent = 'No Data';
                statusIndicator.className = 'status-indicator warning';
            }
            
            // Recalculate overall SEO score
            recalculateOverallSEOScore();
        }

        function updateKeywordsList(keywordsList) {
            const container = document.getElementById('keywordsContainer');
            
            if (!keywordsList || keywordsList.length === 0) {
                container.innerHTML = '<p class="keywords-empty">No keywords found yet.</p>';
                return;
            }
            
            // Sort keywords by clicks (descending) to show best performing first
            const sortedKeywords = keywordsList.sort((a, b) => b.clicks - a.clicks);
            
            let html = '<div class="keywords-list-container">';
            
            sortedKeywords.forEach((keyword, index) => {
                // Color coding based on position
                let positionColor = '#ef4444'; // red for poor positions
                if (keyword.position <= 3) {
                    positionColor = '#10b981'; // green for excellent positions
                } else if (keyword.position <= 10) {
                    positionColor = '#f59e0b'; // yellow for good positions
                }
                
                html += `
                    <div class="keyword-item">
                        <div class="keyword-name">
                            <span>${keyword.keyword}</span>
                        </div>
                        <div class="keyword-metrics">
                            <span class="keyword-position" style="color: ${positionColor};">
                                #${keyword.position.toFixed(1)}
                            </span>
                            <span class="keyword-clicks">
                                ${keyword.clicks} clicks
                            </span>
                            <span class="keyword-impressions">
                                ${keyword.impressions.toLocaleString()} imp
                            </span>
                            <span class="keyword-ctr">
                                ${(keyword.ctr * 100).toFixed(1)}% CTR
                            </span>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        function recalculateOverallSEOScore() {
            const seoScore = calculateSEOScore(
                window.metricsData.summary,
                window.metricsData.ux,
                window.metricsData.mobile,
                window.metricsData.indexing,
                window.metricsData.keywords,
                window.metricsData.business
            );
            
            // Calculate and update SEO score change (use backend data if available, otherwise fallback to session-based)
            const seoScoreChange = window.metricsData.summary?.seo_score_change !== undefined ? 
                window.metricsData.summary.seo_score_change : 
                calculateChange('seo_score', seoScore);
            
            document.getElementById('seoScore').textContent = seoScore;
            updateSEOScoreChange(seoScoreChange);
            console.log('[DEBUG] Recalculated SEO score:', seoScore, 'change:', seoScoreChange, 'using data:', window.metricsData);
        }

        function calculateSEOScore(summary, ux = {}, mobile = {}, indexing = {}, keywords = {}, business = {}) {
            // Define all metrics, their weights, and normalization functions
            const metrics = [
                // Visibility
                { key: 'avg_ctr', value: summary.avg_ctr, weight: 10, norm: v => Math.min(v / 0.10, 1) },
                { key: 'avg_position', value: summary.avg_position, weight: 10, norm: v => Math.max((10 - v) / 10, 0) },
                { key: 'total_impressions', value: summary.total_impressions, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 6, 1) },
                { key: 'total_clicks', value: summary.total_clicks, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 5, 1) },
                // UX
                { key: 'performance_score', value: ux.performance_score, weight: 10, norm: v => (v / 100) },
                { key: 'lcp', value: ux.lcp, weight: 5, norm: v => 1 - Math.min(v, 4) / 4 },
                { key: 'fcp', value: ux.fcp, weight: 5, norm: v => 1 - Math.min(v, 3) / 3 },
                { key: 'cls', value: ux.cls, weight: 5, norm: v => 1 - Math.min(v, 0.25) / 0.25 },
                // Mobile
                { key: 'mobile_friendly', value: mobile.mobile_friendly, weight: 10, norm: v => (v === 'Yes' || v === 'Pass') ? 1 : 0 },
                { key: 'issues_count', value: mobile.issues_count, weight: 5, norm: v => 1 - Math.min(v, 5) / 5 },
                // Indexing
                { key: 'sitemap_status', value: indexing.sitemap_status, weight: 5, norm: v => v === 'Active' ? 1 : 0 },
                { key: 'index_status', value: indexing.index_status, weight: 5, norm: v => ['PASS', 'NEUTRAL'].includes(v) ? 1 : 0 },
                // Keywords
                { key: 'total_keywords', value: keywords.total_keywords, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 4, 1) },
                { key: 'opportunities', value: keywords.opportunities, weight: 5, norm: v => Math.min(v / 10, 1) },
                { key: 'branded_keywords', value: (keywords.branded_keywords !== undefined && keywords.total_keywords) ? 1 - Math.min(keywords.branded_keywords / (keywords.total_keywords || 1), 1) : undefined, weight: 5, norm: v => v },
                // Business Context
                { key: 'business_complexity_score', value: business.business_complexity_score, weight: 3, norm: v => Math.min(v / 10, 1) },
                { key: 'service_count', value: business.service_count, weight: 2, norm: v => Math.min(Math.log10(v + 1) / 2, 1) },
            ];

            // Filter out missing metrics
            const present = metrics.filter(m => m.value !== undefined && m.value !== null && !Number.isNaN(m.value));
            const totalWeight = present.reduce((sum, m) => sum + m.weight, 0);
            if (totalWeight === 0) return 0;

            // Dynamically scale weights so total is 100
            let score = 0;
            present.forEach(m => {
                const scaledWeight = m.weight * (100 / totalWeight);
                let normValue = m.key === 'branded_keywords' ? m.value : m.norm(m.value);
                normValue = Math.max(0, Math.min(normValue, 1));
                score += normValue * scaledWeight;
            });
            return Math.round(score);
        }

        function formatDateString(dateStr) {
            // dateStr is in "YYYY-MM-DD" format
            if (!dateStr || dateStr.split('-').length !== 3) {
                return '';
            }
            const [year, month, day] = dateStr.split('-');
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const monthName = monthNames[parseInt(month, 10) - 1];
            return `${monthName} ${parseInt(day, 10)}`;
        }

        function showDateRange(metrics) {
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            const dateRangeSpan = document.getElementById('dateRange');

            if (metrics && metrics.start_date && metrics.end_date) {
                const startStr = formatDateString(metrics.start_date);
                const endStr = formatDateString(metrics.end_date);
                
                dateRangeSpan.textContent = `${startStr} - ${endStr}`;
                dateRangeInfo.classList.remove('hidden');
            } else {
                hideDateRange();
            }
        }

        function hideDateRange() {
            document.getElementById('dateRangeInfo').classList.add('hidden');
        }

        function showWebsiteInfo(metrics) {
            const websiteInfo = document.getElementById('websiteInfo');
            const trackedWebsite = document.getElementById('trackedWebsite');
            const mobileMenuWebsite = document.getElementById('mobileMenuWebsite');

            if (metrics && metrics.website_url) {
                let displayUrl = metrics.website_url;
                if (displayUrl.startsWith('sc-domain:')) {
                    displayUrl = displayUrl.replace('sc-domain:', '');
                }
                trackedWebsite.textContent = displayUrl;
                mobileMenuWebsite.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-icon"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg>${displayUrl}`;
                websiteInfo.classList.remove('hidden');
            } else {
                hideWebsiteInfo();
            }
        }

        function hideWebsiteInfo() {
            document.getElementById('websiteInfo').classList.add('hidden');
            document.getElementById('mobileMenuWebsite').textContent = 'No website selected';
        }

        function changeWebsite() {
            // Redirect to setup wizard to select a different website
            window.location.href = '/setup';
        }
        
        function showMetricsLoadingPopup() {
            const popup = document.getElementById('metricsLoadingPopup');
            popup.style.display = 'flex';
            // Force reflow for transition
            void popup.offsetWidth;
            popup.classList.remove('metrics-loading-hide');
            popup.classList.add('metrics-loading-visible');
            updateMetricsLoadingList();
        }
        function hideMetricsLoadingPopup() {
            const popup = document.getElementById('metricsLoadingPopup');
            popup.classList.remove('metrics-loading-visible');
            popup.classList.add('metrics-loading-hide');
            function onTransitionEnd(e) {
                if (e.propertyName === 'transform') {
                    popup.style.display = 'none';
                    popup.removeEventListener('transitionend', onTransitionEnd);
                }
            }
            popup.addEventListener('transitionend', onTransitionEnd);
        }
        function showMetricsSuccessPopup() {
            const popup = document.getElementById('metricsSuccessPopup');
            popup.style.display = 'flex';
            // Force reflow for transition
            void popup.offsetWidth;
            popup.classList.remove('metrics-success-hide');
            popup.classList.add('metrics-success-visible');
        }
        function hideMetricsSuccessPopup() {
            const popup = document.getElementById('metricsSuccessPopup');
            popup.classList.remove('metrics-success-visible');
            popup.classList.add('metrics-success-hide');
            function onTransitionEnd(e) {
                if (e.propertyName === 'transform') {
                    popup.style.display = 'none';
                    popup.removeEventListener('transitionend', onTransitionEnd);
                }
            }
            popup.addEventListener('transitionend', onTransitionEnd);
        }
        function updateMetricsLoadingList() {
            const list = document.getElementById('metricsLoadingList');
            list.innerHTML = METRIC_GROUPS.map(m => {
                const state = metricsLoadingState[m.key];
                if (state === 'done') {
                    return `<div style="display:flex;align-items:center;gap:0.5rem;color:#16a34a;font-weight:400;"><span class="metric-success-icon"><svg width='18' height='18'><polyline points='3,10 8,15 15,4' style='fill:none;stroke:#16a34a;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;'/></svg></span>${m.label}</div>`;
                } else {
                    return `<div style="display:flex;align-items:center;gap:0.5rem;color:#D97706;"><span class="metric-loading-spinner"><svg width='18' height='18' viewBox='0 0 50 50'><circle cx='25' cy='25' r='20' fill='none' stroke='#D97706' stroke-width='5' stroke-linecap='round' stroke-dasharray='31.4 31.4' stroke-dashoffset='0'><animateTransform attributeName='transform' type='rotate' from='0 25 25' to='360 25 25' dur='0.8s' repeatCount='indefinite'/></circle></svg></span>${m.label}</div>`;
                }
            }).join('');
        }
        function setMetricLoadingState(key, state) {
            metricsLoadingState[key] = state;
            updateMetricsLoadingList();
            // If all done, show success popup and hide both after 5s with countdown
            if (METRIC_GROUPS.every(m => metricsLoadingState[m.key] === 'done')) {
                const loadingPopup = document.getElementById('metricsLoadingPopup');
                const successPopup = document.getElementById('metricsSuccessPopup');
                loadingPopup.style.display = 'flex';
                successPopup.style.display = 'flex';
                showMetricsSuccessPopup();
                let secondsLeft = 5;
                const timerSpan = document.getElementById('metricsSuccessTimer');
                timerSpan.textContent = `(${secondsLeft}s)`;
                timerSpan.style.color = '';
                const interval = setInterval(() => {
                    secondsLeft--;
                    timerSpan.textContent = `(${secondsLeft}s)`;
                    if (secondsLeft <= 0) {
                        clearInterval(interval);
                        hideMetricsSuccessPopup();
                        hideMetricsLoadingPopup();
                    }
                }, 1000);
            }
        }
        function resetMetricsLoadingState() {
            METRIC_GROUPS.forEach(m => metricsLoadingState[m.key] = 'loading');
            updateMetricsLoadingList();
        }
        
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html> 