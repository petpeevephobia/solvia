<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solvia Dashboard - SEO on AI Autopilot</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css?v=1.2">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        #metricsPopupContainer {
            position: fixed;
            right: 24px;
            bottom: 24px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 12px;
        }
        #metricsLoadingPopup, #metricsSuccessPopup {
            transition: transform 0.5s cubic-bezier(0.4,0,0.2,1), opacity 0.5s cubic-bezier(0.4,0,0.2,1);
            transform: translateX(120%);
            opacity: 0;
            min-width: 260px;
            max-width: 320px;
            background: #FFF7ED; /* Updated to very light orange */
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            padding: 1.25rem 1.5rem;
            display: none;
            flex-direction: column;
            gap: 0.75rem;
            margin: 0;
            position: static;
            border: 1px solid #FED7AA; /* Discreet border matching light orange */
        }
        #metricsSuccessPopup {
            color: #D97706;
            font-weight: 600;
            text-align: left;
        }
        #metricsSuccessPopup .timer {
            font-weight: 400;
            color: #16a34a;
        }
        #metricsLoadingPopup.metrics-loading-visible,
        #metricsSuccessPopup.metrics-success-visible {
            transform: translateX(0);
            opacity: 1;
            display: flex;
        }
        #metricsLoadingPopup.metrics-loading-hide,
        #metricsSuccessPopup.metrics-success-hide {
            transform: translateX(120%);
            opacity: 0;
        }
        @media (max-width: 600px) {
            #metricsPopupContainer {
                left: 16px !important;
                right: 16px !important;
                width: auto !important;
                max-width: calc(100vw - 32px) !important;
                min-width: 0 !important;
                box-sizing: border-box;
                align-items: stretch;
            }
            #metricsLoadingPopup, #metricsSuccessPopup {
                width: 100% !important;
                max-width: 100% !important;
            }
        }
        #metricsLoadingList div {
            color: #D97706 !important;
        }
    </style>
</head>
<body class="dashboard-body">
    <nav class="navbar">
        <div class="navbar-brand">Solvia</div>
        <div class="navbar-user">
            <div class="user-avatar" id="userAvatar">S</div>
            <span id="userEmail">user@example.com</span>
            <button class="logout-btn" onclick="logout()">Logout</button>
        </div>
    </nav>

    <div class="container dashboard-container">
        <!-- GSC Connection Banner -->
        <div id="gscBanner" class="gsc-banner hidden">
            <div class="banner-content">
                <div class="banner-icon">🚀</div>
                <div class="banner-text">
                    <h3>Connect Google Search Console</h3>
                    <p>Get real SEO data for your dashboard by connecting your Google Search Console account.</p>
                </div>
                <div class="banner-actions">
                    <button onclick="connectGSC()" class="btn-connect">Connect GSC</button>
                </div>
            </div>
        </div>

        <div class="dashboard-header">
            <div>
                <h1>Your Dashboard</h1>
                <div id="dateRangeInfo" class="date-range-info hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                    <span id="dateRange"></span>
                </div>
                <div id="websiteInfo" class="website-info hidden">
                    <span>📊 Tracking: </span>
                    <span id="trackedWebsite" class="tracked-website"></span>
                    <button onclick="changeWebsite()" class="btn-link">Change</button>
                </div>
            </div>
            <button onclick="refreshMetrics()" class="btn-refresh" id="refreshBtn" title="Refresh Data">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rotate-cw"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </button>
        </div>

        <div class="stats-grid">
            <!-- Overall SEO Score Card -->
            <div class="stat-card overall-score">
                <div class="score-header">
                    <h3>Overall SEO Score</h3>
                    <div class="score-badge" id="seoScore">0</div>
                </div>
                <div class="score-change" id="seoScoreChange">+0%</div>
                <div class="score-description">Based on all metrics</div>
            </div>
        </div>

        <div class="analysis-grid">
            <!-- Visibility Performance Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">📊</div>
                    <h2>Visibility Performance</h2>
                    <div class="status-indicator" id="visibilityStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Impressions</span>
                            <span class="metric-value" id="impressionsValue">0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Clicks</span>
                            <span class="metric-value" id="clicksValue">0</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">CTR</span>
                            <span class="metric-value" id="ctrValue">0%</span>
                            <span class="metric-change" id="ctrChange">+0%</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Avg Position</span>
                            <span class="metric-value" id="avgPositionValue">N/A</span>
                            <span class="metric-change" id="avgPositionChange">+0.0</span>
                        </div>
                    </div>
                    <div class="insights" id="visibilityInsights">
                        <p>Connect Google Search Console to see visibility insights</p>
                    </div>
                </div>
            </div>

            <!-- Engagement & UX Performance Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">⚡</div>
                    <h2>Engagement & UX</h2>
                    <div class="status-indicator" id="uxStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Performance Score</span>
                            <span class="metric-value" id="performanceScore">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">LCP</span>
                            <span class="metric-value" id="lcpValue">N/A</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">FCP</span>
                            <span class="metric-value" id="fcpValue">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">CLS</span>
                            <span class="metric-value" id="clsValue">N/A</span>
                        </div>
                    </div>
                    <div class="insights" id="uxInsights">
                        <p>Performance data will appear when connected</p>
                    </div>
                </div>
            </div>

            <!-- Mobile Usability Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">📱</div>
                    <h2>Mobile Usability</h2>
                    <div class="status-indicator" id="mobileStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Mobile Friendly</span>
                            <span class="metric-value" id="mobileFriendly">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Issues</span>
                            <span class="metric-value" id="mobileIssues">0</span>
                        </div>
                    </div>
                    <div class="insights" id="mobileInsights">
                        <p>Mobile test results will appear here</p>
                    </div>
                </div>
            </div>

            <!-- Indexing & Crawlability Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">🔍</div>
                    <h2>Indexing & Crawlability</h2>
                    <div class="status-indicator" id="indexingStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Sitemap Status</span>
                            <span class="metric-value" id="sitemapStatus">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Index Status</span>
                            <span class="metric-value" id="indexStatus">N/A</span>
                        </div>
                    </div>
                    <div class="insights" id="indexingInsights">
                        <p>Indexing health will be analyzed</p>
                    </div>
                </div>
            </div>

            <!-- Business Context Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">🏢</div>
                    <h2>Business Context</h2>
                    <div class="status-indicator" id="businessStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Business Type</span>
                            <span class="metric-value" id="businessType">N/A</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Target Market</span>
                            <span class="metric-value" id="targetMarket">N/A</span>
                        </div>
                    </div>
                    <div class="insights" id="businessInsights">
                        <p>Business analysis will provide context</p>
                    </div>
                </div>
            </div>

            <!-- Keyword Trends Section -->
            <div class="analysis-card">
                <div class="card-header">
                    <div class="header-icon">📈</div>
                    <h2>Keyword Trends</h2>
                    <div class="status-indicator" id="keywordStatus">Good</div>
                </div>
                <div class="card-body">
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Total Keywords</span>
                            <span class="metric-value" id="totalKeywords">0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Avg Position</span>
                            <span class="metric-value" id="keywordAvgPosition">N/A</span>
                        </div>
                    </div>
                    <div class="metrics-row">
                        <div class="metric">
                            <span class="metric-label">Opportunities</span>
                            <span class="metric-value" id="keywordOpportunities">0</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Branded</span>
                            <span class="metric-value" id="brandedKeywords">0</span>
                        </div>
                    </div>
                    <div class="insights" id="keywordInsights">
                        <p>Loading keyword performance insights...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="charts-section">
            <div class="content-card">
                <div class="card-header">
                    <h2>Organic Traffic Trends</h2>
                </div>
                <div class="card-body">
                    <canvas id="organicTrafficChart" height="300"></canvas>
                </div>
            </div>
            
            <div class="content-card">
                <div class="card-header">
                    <h2>Impressions Trends</h2>
                </div>
                <div class="card-body">
                    <canvas id="impressionsChart" height="300"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div id="metricsPopupContainer">
        <div id="metricsSuccessPopup">
            All metrics loaded successfully! <span id="metricsSuccessTimer" class="timer"></span>
        </div>
        <div id="metricsLoadingPopup">
            <div id="metricsLoadingList"></div>
        </div>
    </div>

    <script>
        // Global chart instances
        let organicTrafficChart = null;
        let impressionsChart = null;
        let isRefreshingToken = false; // Flag to prevent multiple refresh attempts
        let refreshAttempts = 0; // Track refresh attempts to prevent infinite loops
        const MAX_REFRESH_ATTEMPTS = 3; // Maximum number of refresh attempts
        let lastRefreshTime = 0; // Track when we last attempted a refresh
        let isRedirecting = false; // Flag to prevent multiple redirects
        let consecutiveFailures = 0; // Track consecutive API failures
        
        const METRIC_GROUPS = [
          { key: 'visibility', label: 'Visibility Performance' },
          { key: 'ux', label: 'Engagement & UX' },
          { key: 'mobile', label: 'Mobile Usability' },
          { key: 'indexing', label: 'Indexing & Crawlability' },
          { key: 'keywords', label: 'Keyword Trends' },
          { key: 'organic', label: 'Organic Traffic Trends' },
          { key: 'impressions', label: 'Impressions Trends' },
        ];
        let metricsLoadingState = {};
        
        // Check if we're in an infinite loop situation
        function checkForInfiniteLoop() {
            if (consecutiveFailures > 5) {
                console.log('[TOKEN DEBUG] Detected potential infinite loop, clearing token immediately');
                clearInvalidToken();
                return true;
            }
            return false;
        }
        
        function isValidTokenFormat(token) {
            if (!token || typeof token !== 'string') {
                console.log('[TOKEN DEBUG] Token is null, undefined, or not a string:', token);
                return false;
            }
            
            // Check if token has the correct JWT format (3 parts separated by dots)
            const parts = token.split('.');
            console.log('[TOKEN DEBUG] Token parts count:', parts.length);
            
            if (parts.length !== 3) {
                console.log('[TOKEN DEBUG] Invalid JWT structure - expected 3 parts, got:', parts.length);
                console.log('[TOKEN DEBUG] Token parts:', parts);
                return false;
            }
            
            // Try to decode the payload to check if it's valid JSON
            try {
                const payload = JSON.parse(atob(parts[1]));
                console.log('[TOKEN DEBUG] Successfully decoded payload:', payload);
                
                // Check for required fields
                if (!payload || typeof payload !== 'object') {
                    console.log('[TOKEN DEBUG] Payload is not a valid object:', payload);
                    return false;
                }
                
                // Check for required JWT fields
                if (!payload.sub) {
                    console.log('[TOKEN DEBUG] Missing "sub" field in payload');
                    return false;
                }
                
                if (!payload.exp) {
                    console.log('[TOKEN DEBUG] Missing "exp" field in payload');
                    return false;
                }
                
                // Check expiration
                const currentTime = Math.floor(Date.now() / 1000);
                const isExpired = payload.exp < currentTime;
                console.log('[TOKEN DEBUG] Token expiration check:', {
                    currentTime,
                    tokenExp: payload.exp,
                    isExpired,
                    timeUntilExpiry: payload.exp - currentTime
                });
                
                return true;
            } catch (error) {
                console.log('[TOKEN DEBUG] Failed to decode payload:', error);
                console.log('[TOKEN DEBUG] Raw payload part:', parts[1]);
                return false;
            }
        }
        
        function clearInvalidToken() {
            console.log('[TOKEN DEBUG] Clearing invalid token from localStorage');
            const oldToken = localStorage.getItem('auth_token');
            console.log('[TOKEN DEBUG] Old token (first 50 chars):', oldToken ? oldToken.substring(0, 50) + '...' : 'null');
            localStorage.removeItem('auth_token');
            if (!isRedirecting) {
                isRedirecting = true;
                window.location.href = '/ui';
            }
        }
        
        function checkAuth() {
            const token = localStorage.getItem('auth_token');
            console.log('[TOKEN DEBUG] checkAuth called');
            console.log('[TOKEN DEBUG] Token exists:', !!token);
            
            if (!token) {
                console.log('[TOKEN DEBUG] No token found, redirecting to login');
                if (!isRedirecting) {
                    isRedirecting = true;
                window.location.href = '/ui';
                }
                return;
            }

            // First, validate token format
            console.log('[TOKEN DEBUG] Validating token format...');
            if (!isValidTokenFormat(token)) {
                console.log('[TOKEN DEBUG] Invalid token format detected, clearing token');
                clearInvalidToken();
                return;
            }

            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                const userEmail = payload.sub || 'user@example.com';
                const userName = userEmail ? userEmail.split('@')[0] : 'User';
                
                // Check if token is expired
                const currentTime = Math.floor(Date.now() / 1000);
                const timeSinceLastRefresh = currentTime - lastRefreshTime;
                
                console.log('[TOKEN DEBUG] Token expiration check:', {
                    currentTime,
                    tokenExp: payload.exp,
                    isExpired: payload.exp && payload.exp < currentTime,
                    isRefreshing: isRefreshingToken,
                    refreshAttempts,
                    timeSinceLastRefresh,
                    userEmail
                });
                
                if (payload.exp && payload.exp < currentTime) {
                    console.log('[TOKEN DEBUG] Token expired, attempting to refresh...');
                    
                    // Prevent rapid refresh attempts - wait at least 5 seconds between attempts
                    if (timeSinceLastRefresh < 5) {
                        console.log('[TOKEN DEBUG] Too soon since last refresh attempt, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    if (!isRefreshingToken && refreshAttempts < MAX_REFRESH_ATTEMPTS) {
                        lastRefreshTime = currentTime;
                        refreshToken();
                    } else {
                        console.log('[TOKEN DEBUG] Refresh already in progress or max attempts reached, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                    }
                    return;
                }
                
                console.log('[TOKEN DEBUG] Token is valid, updating UI');
                document.getElementById('userEmail').textContent = userEmail;
                document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
            } catch (error) {
                console.error('[TOKEN DEBUG] Error decoding token:', error);
                clearInvalidToken();
            }
        }

        async function refreshToken() {
            if (isRefreshingToken) {
                console.log('Token refresh already in progress, skipping...');
                return;
            }
            
            if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
                console.log('Max refresh attempts reached, redirecting to login');
                if (!isRedirecting) {
                    isRedirecting = true;
                window.location.href = '/ui';
                }
                return;
            }
            
            isRefreshingToken = true;
            refreshAttempts++;
            
            try {
                const token = localStorage.getItem('auth_token');
                
                // Validate token format before attempting refresh
                if (!isValidTokenFormat(token)) {
                    console.log('Invalid token format in refreshToken, clearing token');
                    clearInvalidToken();
                    return;
                }
                
                const response = await fetch('/auth/refresh-token', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    localStorage.setItem('auth_token', data.access_token);
                    console.log('Token refreshed successfully');
                    refreshAttempts = 0; // Reset attempts on success
                    lastRefreshTime = 0; // Reset last refresh time
                    
                    // Verify the new token is not expired
                    try {
                        const newPayload = JSON.parse(atob(data.access_token.split('.')[1]));
                        const currentTime = Math.floor(Date.now() / 1000);
                        
                        if (newPayload.exp && newPayload.exp < currentTime) {
                            console.log('New token is also expired, redirecting to login');
                            if (!isRedirecting) {
                                isRedirecting = true;
                                window.location.href = '/ui';
                            }
                            return;
                        }
                        
                        // Update UI with the user info from the new token
                        const userEmail = newPayload.sub || 'user@example.com';
                        const userName = userEmail ? userEmail.split('@')[0] : 'User';
                        
                        document.getElementById('userEmail').textContent = userEmail;
                        document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                    } catch (error) {
                        console.error('Error updating UI after token refresh:', error);
                    }
                } else {
                    console.error('Failed to refresh token');
                    clearInvalidToken();
                }
            } catch (error) {
                console.error('Error refreshing token:', error);
                clearInvalidToken();
            } finally {
                isRefreshingToken = false;
            }
        }

        async function apiCall(url, options = {}) {
            const token = localStorage.getItem('auth_token');
            if (!token) {
                if (!isRedirecting) {
                    isRedirecting = true;
                    window.location.href = '/ui';
                }
                return;
            }

            // Validate token format before making API calls
            if (!isValidTokenFormat(token)) {
                console.log('[TOKEN DEBUG] Invalid token format in apiCall, clearing token');
                clearInvalidToken();
                return;
            }

            // Check for infinite loop before making the call
            if (checkForInfiniteLoop()) {
                return;
            }

            // Add authorization header
            options.headers = {
                'Authorization': `Bearer ${token}`,
                ...options.headers
            };

            try {
                const response = await fetch(url, options);
                
                // Reset consecutive failures on success
                if (response.ok) {
                    consecutiveFailures = 0;
                }
                
                // If token is expired, try to refresh and retry
                if (response.status === 401) {
                    consecutiveFailures++;
                    console.log('[TOKEN DEBUG] 401 error, consecutive failures:', consecutiveFailures);
                    
                    // Check for infinite loop
                    if (checkForInfiniteLoop()) {
                        return;
                    }
                    
                    console.log('Token expired, refreshing...');
                    
                    // Prevent multiple refresh attempts
                    if (isRefreshingToken) {
                        console.log('Token refresh already in progress, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    // Check if we've exceeded max attempts
                    if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
                        console.log('Max refresh attempts reached in apiCall, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    // Check if we've tried to refresh too recently
                    const currentTime = Math.floor(Date.now() / 1000);
                    if (currentTime - lastRefreshTime < 5) {
                        console.log('Too soon since last refresh attempt, redirecting to login');
                        if (!isRedirecting) {
                            isRedirecting = true;
                            window.location.href = '/ui';
                        }
                        return;
                    }
                    
                    isRefreshingToken = true;
                    refreshAttempts++;
                    lastRefreshTime = currentTime;
                    
                    try {
                        const refreshResponse = await fetch('/auth/refresh-token', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (refreshResponse.ok) {
                            const data = await refreshResponse.json();
                            localStorage.setItem('auth_token', data.access_token);
                            refreshAttempts = 0; // Reset on success
                            lastRefreshTime = 0; // Reset last refresh time
                            consecutiveFailures = 0; // Reset failures on successful refresh
                            
                            // Verify the new token is not expired
                            try {
                                const newPayload = JSON.parse(atob(data.access_token.split('.')[1]));
                                const currentTime = Math.floor(Date.now() / 1000);
                                
                                if (newPayload.exp && newPayload.exp < currentTime) {
                                    console.log('New token is also expired, redirecting to login');
                                    if (!isRedirecting) {
                                        isRedirecting = true;
                                        window.location.href = '/ui';
                                    }
                                    return;
                                }
                            } catch (error) {
                                console.error('Error verifying new token:', error);
                                if (!isRedirecting) {
                                    isRedirecting = true;
                                    window.location.href = '/ui';
                                }
                                return;
                            }
                            
                            // Retry the original request with new token
                            options.headers['Authorization'] = `Bearer ${data.access_token}`;
                            return await fetch(url, options);
                        } else {
                            // Refresh failed, clear token and redirect to login
                            console.log('Token refresh failed, clearing token and redirecting to login');
                            clearInvalidToken();
                            return;
                        }
                    } finally {
                        isRefreshingToken = false;
                    }
                }
                
                return response;
            } catch (error) {
                consecutiveFailures++;
                console.error('API call error:', error);
                console.log('[TOKEN DEBUG] API call failed, consecutive failures:', consecutiveFailures);
                
                // Check for infinite loop
                if (checkForInfiniteLoop()) {
                    return;
                }
                
                throw error;
            }
        }

        function logout() {
            localStorage.removeItem('auth_token');
            window.location.href = '/ui';
        }

        function generateLast30DaysData() {
            const dates = [];
            for (let i = 29; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                dates.push(`Day ${30 - i}`);
            }
            return dates;
        }

        function createCharts(hasGSC = false) {
            const rootStyles = getComputedStyle(document.documentElement);
            const primaryColor = rootStyles.getPropertyValue('--color-primary').trim();
            
            const dates = generateLast30DaysData();
            const organicTrafficData = hasGSC ? [10, 15, 12, 18, 22, 25, 20, 23, 28, 33, 30, 35, 38, 40, 37, 42, 45, 48, 50, 47, 52, 55, 58, 60, 57, 62, 65, 68, 70, 72] : new Array(30).fill(0);
            const impressionsData = hasGSC ? [100, 120, 110, 130, 150, 160, 140, 155, 170, 202, 190, 210, 220, 230, 215, 240, 250, 260, 270, 255, 280, 290, 300, 310, 295, 320, 330, 340, 350, 360] : new Array(30).fill(0);
            
            if (organicTrafficChart) organicTrafficChart.destroy();
            if (impressionsChart) impressionsChart.destroy();

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: { beginAtZero: true, grid: { color: 'rgba(0, 0, 0, 0.05)' } },
                    x: { grid: { display: false }, ticks: {
                        callback: function(value, index, values) {
                            const label = this.getLabelForValue(value);
                            if (label === 'Day 1' || label === 'Day 10' || label === 'Day 20' || label === 'Day 30') {
                                return label;
                            }
                            return null;
                        }
                    } }
                },
                elements: {
                    line: {
                        borderColor: primaryColor,
                        backgroundColor: 'rgba(249, 115, 22, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }
                }
            };
            
            const organicTrafficCtx = document.getElementById('organicTrafficChart').getContext('2d');
            organicTrafficChart = new Chart(organicTrafficCtx, {
                type: 'line',
                data: { labels: dates, datasets: [{ data: organicTrafficData }] },
                options: chartOptions
            });

            const impressionsCtx = document.getElementById('impressionsChart').getContext('2d');
            impressionsChart = new Chart(impressionsCtx, {
                type: 'line',

                data: { labels: dates, datasets: [{ data: impressionsData }] },
                options: chartOptions
            });
        }

        function updateDashboardMetrics(hasGSC = false) {
            if (hasGSC) {
                // Update overall score
                document.getElementById('seoScore').textContent = '65';
                document.getElementById('seoScoreChange').textContent = '+5%';
                document.getElementById('seoScoreChange').className = 'score-change positive';

                // Update visibility performance
                document.getElementById('impressionsValue').textContent = '21,450';
                document.getElementById('clicksValue').textContent = '1,234';
                document.getElementById('ctrValue').textContent = '5.8%';
                document.getElementById('ctrChange').textContent = '+0.8%';
                document.getElementById('ctrChange').className = 'metric-change positive';
                document.getElementById('avgPositionValue').textContent = '2.2';
                document.getElementById('avgPositionChange').textContent = '+0.5';
                document.getElementById('avgPositionChange').className = 'metric-change positive';
                document.getElementById('visibilityInsights').innerHTML = '<p>Good visibility with room for CTR improvement. High-opportunity keywords need optimization.</p>';

                // Update engagement & UX
                document.getElementById('performanceScore').textContent = '78';
                document.getElementById('lcpValue').textContent = '2.1s';
                document.getElementById('fcpValue').textContent = '1.2s';
                document.getElementById('clsValue').textContent = '0.08';
                document.getElementById('uxInsights').innerHTML = '<p>Performance is good but LCP could be improved. Consider optimizing images and reducing server response time.</p>';

                // Update mobile usability
                document.getElementById('mobileFriendly').textContent = 'Pass';
                document.getElementById('mobileIssues').textContent = '0';
                document.getElementById('mobileInsights').innerHTML = '<p>Mobile-friendly with no issues detected. Good user experience across devices.</p>';

                // Update indexing & crawlability
                document.getElementById('sitemapStatus').textContent = 'Healthy';
                document.getElementById('indexStatus').textContent = 'Good';
                document.getElementById('indexingInsights').innerHTML = '<p>Sitemap is properly configured and indexed. No crawl issues detected.</p>';

                // Update business context
                document.getElementById('businessType').textContent = 'SaaS';
                document.getElementById('targetMarket').textContent = 'B2B';
                document.getElementById('businessInsights').innerHTML = '<p>B2B SaaS business with technical audience. Focus on educational content and case studies.</p>';

                // Update keyword trends
                document.getElementById('totalKeywords').textContent = '1,247';
                document.getElementById('keywordAvgPosition').textContent = '3.2';
                document.getElementById('keywordOpportunities').textContent = '23';
                document.getElementById('brandedKeywords').textContent = '156';
                document.getElementById('keywordInsights').innerHTML = '<p>Strong keyword portfolio with 23 high-opportunity terms. Branded keywords performing well.</p>';

            } else {
                // Reset all metrics to empty state
                document.getElementById('seoScore').textContent = '0';
                document.getElementById('seoScoreChange').textContent = '+0%';
                
                // Reset visibility performance
                document.getElementById('impressionsValue').textContent = '0';
                document.getElementById('clicksValue').textContent = '0';
                document.getElementById('ctrValue').textContent = '0%';
                document.getElementById('ctrChange').textContent = '+0%';
                document.getElementById('avgPositionValue').textContent = 'N/A';
                document.getElementById('avgPositionChange').textContent = '+0.0';
                document.getElementById('visibilityInsights').innerHTML = '<p>Connect Google Search Console to see visibility insights</p>';

                // Reset engagement & UX
                document.getElementById('performanceScore').textContent = 'N/A';
                document.getElementById('lcpValue').textContent = 'N/A';
                document.getElementById('fcpValue').textContent = 'N/A';
                document.getElementById('clsValue').textContent = 'N/A';
                document.getElementById('uxInsights').innerHTML = '<p>Performance data will appear when connected</p>';

                // Reset mobile usability
                document.getElementById('mobileFriendly').textContent = 'N/A';
                document.getElementById('mobileIssues').textContent = '0';
                document.getElementById('mobileInsights').innerHTML = '<p>Mobile test results will appear here</p>';

                // Reset indexing & crawlability
                document.getElementById('sitemapStatus').textContent = 'N/A';
                document.getElementById('indexStatus').textContent = 'N/A';
                document.getElementById('indexingInsights').innerHTML = '<p>Indexing health will be analyzed</p>';

                // Reset business context
                document.getElementById('businessType').textContent = 'N/A';
                document.getElementById('targetMarket').textContent = 'N/A';
                document.getElementById('businessInsights').innerHTML = '<p>Business analysis will provide context</p>';

                // Reset keyword trends
                document.getElementById('totalKeywords').textContent = '0';
                document.getElementById('keywordAvgPosition').textContent = 'N/A';
                document.getElementById('keywordOpportunities').textContent = '0';
                document.getElementById('brandedKeywords').textContent = '0';
                document.getElementById('keywordInsights').innerHTML = '<p>Loading keyword performance insights...</p>';
            }
        }

        function updateDashboardMetricsWithRealData(metrics) {
            console.log('[DEBUG] Updating dashboard with real data:', metrics);
            
            const summary = metrics.summary || {};
            console.log('[DEBUG] Summary data:', summary);
            
            // Calculate SEO score based on real metrics
            const seoScore = calculateSEOScore(summary);
            const seoScoreChange = '+5%'; // This would need to be calculated from historical data
            
            // Update overall score
            document.getElementById('seoScore').textContent = seoScore;
            document.getElementById('seoScoreChange').textContent = seoScoreChange;
            document.getElementById('seoScoreChange').className = 'score-change positive';

            // Update visibility performance with real data
            document.getElementById('impressionsValue').textContent = summary.total_impressions?.toLocaleString() || '0';
            document.getElementById('clicksValue').textContent = summary.total_clicks?.toLocaleString() || '0';
            document.getElementById('ctrValue').textContent = summary.avg_ctr ? `${(summary.avg_ctr * 100).toFixed(2)}%` : '0%';
            document.getElementById('avgPositionValue').textContent = summary.avg_position?.toFixed(1) || 'N/A';
            
            // Update change indicators
            updateChangeIndicator('ctrChange', summary.ctr_change, '%', true);
            updateChangeIndicator('avgPositionChange', summary.position_change, '', false);
            
            // Generate insights based on real data
            generateVisibilityInsights(summary);
            generateUXInsights(metrics);
            generateMobileInsights(metrics);
            generateIndexingInsights(metrics);
            generateBusinessInsights(metrics);
            generateKeywordInsights(metrics);
        }

        function updateChangeIndicator(elementId, value, unit = '', higherIsBetter = true) {
            const element = document.getElementById(elementId);
            if (value === undefined || value === null) {
                element.textContent = 'N/A';
                element.className = 'metric-change';
                return;
            }

            const isPositive = higherIsBetter ? value > 0 : value < 0;
            const isNegative = higherIsBetter ? value < 0 : value > 0;
            
            let class_name = 'metric-change';
            if (isPositive) {
                class_name += ' positive';
            } else if (isNegative) {
                class_name += ' negative';
            }

            element.className = class_name;
            
            const prefix = value > 0 ? '+' : '';
            const formattedValue = unit === '%' ? (value * 100).toFixed(2) : value.toFixed(1);
            
            element.textContent = `${prefix}${formattedValue}${unit}`;
        }

        function generateVisibilityInsights(summary) {
            let insight = '';
            if (summary.total_impressions > 0) {
                if (summary.avg_ctr < 2) {
                    insight = 'CTR is below average. Consider optimizing meta titles and descriptions for better click-through rates.';
                } else if (summary.avg_position > 10) {
                    insight = 'Average position needs improvement. Focus on content optimization and backlink building.';
                } else {
                    insight = 'Good visibility performance. Continue optimizing for high-opportunity keywords.';
                }
            } else {
                insight = 'No search visibility data yet. This is normal for new websites.';
            }
            document.getElementById('visibilityInsights').innerHTML = `<p>${insight}</p>`;
        }

        function generateUXInsights(metrics) {
            // Fetch real PageSpeed data
            fetchPageSpeedData();
        }

        async function fetchPageSpeedData() {
            setMetricLoadingState('ux', 'loading');
            try {
                console.log('[DEBUG] Fetching PageSpeed data...');
                const response = await apiCall('/auth/pagespeed/metrics');
                console.log('[DEBUG] PageSpeed response status:', response.status);
                
                if (response.ok) {
                    const psiData = await response.json();
                    console.log('[DEBUG] PageSpeed data received:', psiData);
                    updateUXMetrics(psiData);
                    generateUXInsightsFromData(psiData);
                    setMetricLoadingState('ux', 'done');
                } else {
                    setMetricLoadingState('ux', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load PageSpeed data:', errorText);
                    document.getElementById('uxInsights').innerHTML = '<p>Performance insights will be available when PageSpeed data is connected.</p>';
                }
            } catch (error) {
                setMetricLoadingState('ux', 'done');
                console.error('Error loading PageSpeed data:', error);
                document.getElementById('uxInsights').innerHTML = '<p>Performance insights will be available when PageSpeed data is connected.</p>';
            }
        }

        function updateUXMetrics(psiData) {
            console.log('[DEBUG] Updating UX metrics with data:', psiData);
            
            // Update performance score
            const performanceScore = psiData.performance_score;
            console.log('[DEBUG] Performance score:', performanceScore);
            document.getElementById('performanceScore').textContent = performanceScore || 'N/A';
            
            // Update LCP
            const lcpValue = psiData.lcp?.value;
            console.log('[DEBUG] LCP value:', lcpValue);
            document.getElementById('lcpValue').textContent = lcpValue ? `${lcpValue.toFixed(1)}s` : 'N/A';
            
            // Update FCP
            const fcpValue = psiData.fcp?.value;
            console.log('[DEBUG] FCP value:', fcpValue);
            document.getElementById('fcpValue').textContent = fcpValue ? `${fcpValue.toFixed(1)}s` : 'N/A';
            
            // Update CLS
            const clsValue = psiData.cls?.value;
            console.log('[DEBUG] CLS value:', clsValue);
            document.getElementById('clsValue').textContent = clsValue ? clsValue.toFixed(3) : 'N/A';
            
            // Update status indicator
            const statusIndicator = document.getElementById('uxStatus');
            if (performanceScore >= 90) {
                statusIndicator.textContent = 'Excellent';
                statusIndicator.className = 'status-indicator good';
            } else if (performanceScore >= 70) {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (performanceScore >= 50) {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else {
                statusIndicator.textContent = 'Poor';
                statusIndicator.className = 'status-indicator error';
            }
        }

        function generateUXInsightsFromData(psiData) {
            let insight = '';
            const performanceScore = psiData.performance_score;
            const lcp = psiData.lcp?.value;
            const fcp = psiData.fcp?.value;
            const cls = psiData.cls?.value;
            
            if (performanceScore >= 90) {
                insight = 'Excellent performance! Your site loads quickly and provides a great user experience.';
            } else if (performanceScore >= 70) {
                insight = 'Good performance with room for improvement. Consider optimizing images and reducing server response time.';
            } else if (performanceScore >= 50) {
                insight = 'Performance needs improvement. Focus on Core Web Vitals optimization for better user experience.';
            } else {
                insight = 'Performance requires immediate attention. Prioritize speed optimizations to improve user experience and SEO.';
            }
            
            // Add specific recommendations based on Core Web Vitals
            if (lcp && lcp > 2.5) {
                insight += ' LCP is slow - optimize images and reduce server response time.';
            }
            if (fcp && fcp > 1.8) {
                insight += ' FCP needs improvement - optimize critical rendering path.';
            }
            if (cls && cls > 0.1) {
                insight += ' CLS issues detected - prevent layout shifts during page load.';
            }
            
            document.getElementById('uxInsights').innerHTML = `<p>${insight}</p>`;
        }

        function generateMobileInsights(metrics) {
            // Fetch real mobile data
            fetchMobileData();
        }

        async function fetchMobileData() {
            setMetricLoadingState('mobile', 'loading');
            try {
                const response = await apiCall('/auth/mobile/metrics');
                
                if (response.ok) {
                    const mobileData = await response.json();
                    updateMobileMetrics(mobileData);
                    generateMobileInsightsFromData(mobileData);
                    setMetricLoadingState('mobile', 'done');
                } else {
                    setMetricLoadingState('mobile', 'done');
                    console.log('[DEBUG] Failed to load mobile data, showing placeholder');
                    document.getElementById('mobileInsights').innerHTML = '<p>Mobile test results will appear here</p>';
                }
            } catch (error) {
                setMetricLoadingState('mobile', 'done');
                console.error('Error loading mobile data:', error);
                document.getElementById('mobileInsights').innerHTML = '<p>Mobile test results will appear here</p>';
            }
        }

        function updateMobileMetrics(mobileData) {
            // Update mobile friendly status
            const mobileFriendly = mobileData.mobile_friendly;
            document.getElementById('mobileFriendly').textContent = mobileFriendly || 'N/A';
            
            // Update status indicator color
            const statusIndicator = document.getElementById('mobileStatus');
            if (mobileFriendly === 'Pass' || mobileFriendly === 'Yes') {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (mobileFriendly === 'Fail' || mobileFriendly === 'No') {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else {
                statusIndicator.textContent = 'Unknown';
                statusIndicator.className = 'status-indicator';
            }
            
            // Update issues count
            document.getElementById('mobileIssues').textContent = mobileData.issues_count || '0';
        }

        function generateMobileInsightsFromData(mobileData) {
            const insights = mobileData.insights || 'Mobile usability data unavailable.';
            document.getElementById('mobileInsights').innerHTML = `<p>${insights}</p>`;
        }

        function generateIndexingInsights(metrics) {
            // Fetch real indexing data
            fetchIndexingData();
        }

        async function fetchIndexingData() {
            setMetricLoadingState('indexing', 'loading');
            try {
                console.log('[DEBUG] Fetching indexing data...');
                const response = await apiCall('/auth/indexing/metrics');
                console.log('[DEBUG] Indexing response status:', response.status);
                
                if (response.ok) {
                    const indexingData = await response.json();
                    console.log('[DEBUG] Indexing data received:', indexingData);
                    updateIndexingMetrics(indexingData);
                    generateIndexingInsightsFromData(indexingData);
                    setMetricLoadingState('indexing', 'done');
                } else {
                    setMetricLoadingState('indexing', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load indexing data:', errorText);
                    document.getElementById('indexingInsights').innerHTML = '<p>Indexing health will be analyzed when connected to Google Search Console.</p>';
                }
            } catch (error) {
                setMetricLoadingState('indexing', 'done');
                console.error('Error loading indexing data:', error);
                document.getElementById('indexingInsights').innerHTML = '<p>Indexing health will be analyzed when connected to Google Search Console.</p>';
            }
        }

        function updateIndexingMetrics(indexingData) {
            // Update sitemap status
            const sitemapStatus = indexingData.sitemap_status;
            document.getElementById('sitemapStatus').textContent = sitemapStatus || 'N/A';
            
            // Update index status
            const indexStatus = indexingData.index_status;
            document.getElementById('indexStatus').textContent = indexStatus || 'N/A';
            
            // Update status indicator color
            const statusIndicator = document.getElementById('indexingStatus');
            if ((sitemapStatus === 'Active' && (indexStatus === 'PASS' || indexStatus === 'NEUTRAL')) ||
                (sitemapStatus === 'Active' && !indexStatus)) {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else if (sitemapStatus === 'Pending' || indexStatus === 'Unknown') {
                statusIndicator.textContent = 'Needs Work';
                statusIndicator.className = 'status-indicator warning';
            } else if (sitemapStatus === 'Error' || indexStatus === 'FAIL') {
                statusIndicator.textContent = 'Poor';
                statusIndicator.className = 'status-indicator error';
            } else {
                statusIndicator.textContent = 'Unknown';
                statusIndicator.className = 'status-indicator';
            }
        }

        function generateIndexingInsightsFromData(indexingData) {
            const insights = indexingData.insights || [];
            if (insights.length > 0) {
                const insightsHtml = insights.map(insight => `<p>${insight}</p>`).join('');
                document.getElementById('indexingInsights').innerHTML = insightsHtml;
            } else {
                document.getElementById('indexingInsights').innerHTML = '<p>Indexing health analysis completed. No major issues detected.</p>';
            }
        }

        function generateBusinessInsights(metrics) {
            // Fetch real business context data
            fetchBusinessData();
        }

        async function fetchBusinessData() {
            setMetricLoadingState('business', 'loading');
            try {
                console.log('[DEBUG] Fetching business context data...');
                const response = await apiCall('/auth/business/metrics');
                console.log('[DEBUG] Business context response status:', response.status);
                
                if (response.ok) {
                    const businessData = await response.json();
                    console.log('[DEBUG] Business context data received:', businessData);
                    updateBusinessMetrics(businessData);
                    generateBusinessInsightsFromData(businessData);
                    setMetricLoadingState('business', 'done');
                } else {
                    setMetricLoadingState('business', 'done');
                    const errorText = await response.text();
                    console.log('[DEBUG] Failed to load business context data:', errorText);
                    document.getElementById('businessInsights').innerHTML = '<p>Business context analysis will be available when connected to Google Search Console.</p>';
                }
            } catch (error) {
                setMetricLoadingState('business', 'done');
                console.error('Error loading business context data:', error);
                document.getElementById('businessInsights').innerHTML = '<p>Business context analysis will be available when connected to Google Search Console.</p>';
            }
        }

        function updateBusinessMetrics(businessData) {
            // Update business type
            const businessType = businessData.business_type;
            document.getElementById('businessType').textContent = businessType || 'N/A';
            
            // Update target market
            const targetMarket = businessData.target_market;
            document.getElementById('targetMarket').textContent = targetMarket || 'N/A';
            
            // Update status indicator color
            const statusIndicator = document.getElementById('businessStatus');
            if (businessType && businessType !== 'Unknown') {
                statusIndicator.textContent = 'Good';
                statusIndicator.className = 'status-indicator good';
            } else {
                statusIndicator.textContent = 'Unknown';
                statusIndicator.className = 'status-indicator';
            }
        }

        function generateBusinessInsightsFromData(businessData) {
            // Handle both string and array formats for insights and recommendations
            let insights = businessData.insights || [];
            let recommendations = businessData.seo_recommendations || [];
            
            // Convert strings to arrays if needed
            if (typeof insights === 'string') {
                insights = insights ? [insights] : [];
            }
            if (typeof recommendations === 'string') {
                recommendations = recommendations ? [recommendations] : [];
            }
            
            // Ensure they are arrays
            if (!Array.isArray(insights)) insights = [];
            if (!Array.isArray(recommendations)) recommendations = [];
            
            let insightsHtml = '';
            
            // Add business insights
            if (insights.length > 0) {
                insightsHtml += '<div class="insight-section"><h4>Business Analysis:</h4>';
                insights.forEach(insight => {
                    insightsHtml += `<p>${insight}</p>`;
                });
                insightsHtml += '</div>';
            }
            
            // Add SEO recommendations
            if (recommendations.length > 0) {
                insightsHtml += '<div class="insight-section"><h4>SEO Recommendations:</h4>';
                recommendations.forEach(rec => {
                    insightsHtml += `<p>• ${rec}</p>`;
                });
                insightsHtml += '</div>';
            }
            
            if (insightsHtml) {
                document.getElementById('businessInsights').innerHTML = insightsHtml;
            } else {
                document.getElementById('businessInsights').innerHTML = '<p>Business context analysis completed. No specific insights available.</p>';
            }
        }

        function generateKeywordInsights(metrics) {
            // This function is now handled by updateKeywordMetrics when real data is loaded
            // The insights are generated on the backend and displayed via loadKeywordData()
            document.getElementById('keywordInsights').innerHTML = '<p>Loading keyword performance insights...</p>';
        }

        async function initDashboard() {
            checkAuth();
            const hasGSC = await checkGSCConnection();
            console.log('[DEBUG] Dashboard init - hasGSC:', hasGSC);
            
            if (hasGSC) {
                // Fetch real metrics from GSC
                await loadRealMetrics();
            } else {
                // Show empty state
                updateDashboardMetrics(false);
                createCharts(false);
            }
        }

        async function checkGSCConnection() {
            try {
                console.log('[DEBUG] Checking GSC connection...');
                const response = await apiCall('/auth/gsc/properties');

                console.log('[DEBUG] GSC response status:', response.status);

                if (response.status === 401 || response.status === 404) {
                    console.log('[DEBUG] Auth error (401/404), showing banner');
                    showGSCBanner();
                    return false;
                }
                if (!response.ok) {
                    const errorText = await response.text();
                    console.log('[DEBUG] GSC connection error:', errorText);
                    
                    // Check if it's a credentials issue
                    if (response.status === 500 && errorText.includes('credentials')) {
                        console.log('[DEBUG] Credentials issue, showing reauth banner');
                        showGSCBannerWithReauth();
                    } else {
                        console.log('[DEBUG] Other error, showing regular banner');
                        showGSCBanner();
                    }
                    return false;
                }

                const properties = await response.json();
                console.log('[DEBUG] GSC properties received:', properties);
                
                if (!properties || properties.length === 0) {
                    console.log('[DEBUG] No properties found, showing banner');
                    showGSCBanner();
                    return false;
                }

                const isDemoMode = properties.some(p => p.siteUrl.includes('example.com') || p.siteUrl.includes('demo-site.com'));
                console.log('[DEBUG] Is demo mode:', isDemoMode);
                
                if (isDemoMode) {
                    console.log('[DEBUG] Demo mode detected, showing banner');
                    showGSCBanner();
                    return false;
                }

                console.log('[DEBUG] Valid GSC connection found, hiding banner');
                hideGSCBanner();
                return true;
            } catch (error) {
                console.log('[DEBUG] Exception in checkGSCConnection:', error);
                showGSCBanner();
                return false;
            }
        }

        function showGSCBanner() {
            document.getElementById('gscBanner').classList.remove('hidden');
        }

        function hideGSCBanner() {
            document.getElementById('gscBanner').classList.add('hidden');
        }

        function showGSCBannerWithReauth() {
            const banner = document.getElementById('gscBanner');
            banner.classList.remove('hidden');
            
            // Update banner content to show re-authentication option
            const bannerText = banner.querySelector('.banner-text p');
            if (bannerText) {
                bannerText.innerHTML = 'Your Google Search Console connection has an issue. <button onclick="clearCredentials()" class="btn-link">Click here to re-authenticate</button> or connect a new account.';
            }
        }

        async function clearCredentials() {
            try {
                const response = await apiCall('/auth/gsc/clear-credentials', {
                    method: 'POST'
                });

                if (response.ok) {
                    // Redirect to setup wizard
                    window.location.href = '/setup';
                } else {
                    alert('Failed to clear credentials. Please try again.');
                }
            } catch (error) {
                console.error('Error clearing credentials:', error);
                alert('Failed to clear credentials. Please try again.');
            }
        }

        function connectGSC() {
            window.location.href = '/setup';
        }

        async function refreshMetrics() {
            const refreshBtn = document.getElementById('refreshBtn');
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.classList.add('loading');
            
            try {
                const response = await apiCall('/auth/gsc/refresh', {
                    method: 'POST'
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Metrics refreshed successfully:', data);
                    
                    // Reload the dashboard with fresh data
                    await loadRealMetrics();
                } else {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to refresh data');
                }
            } catch (error) {
                console.error('Error refreshing metrics:', error);
                showErrorMessage('Could not refresh data. Your connection to Google may have been lost.');
                
                // Force the banner to show with a helpful message
                const banner = document.getElementById('gscBanner');
                const bannerText = banner.querySelector('.banner-text p');
                
                if (bannerText) {
                    bannerText.textContent = 'We couldn\'t refresh your data because the connection to Google Search Console was lost. Please reconnect to continue.';
                }
                banner.classList.remove('hidden');

            } finally {
                // Reset button state after a short delay to allow animation to be seen
                setTimeout(() => {
                    refreshBtn.disabled = false;
                    refreshBtn.classList.remove('loading');
                }, 500);
            }
        }

        function showErrorMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'error-message';
            messageDiv.innerHTML = `<strong>❌ ${message}</strong>`;
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '20px';
            messageDiv.style.right = '20px';
            messageDiv.style.zIndex = '1000';
            messageDiv.style.padding = '1rem';
            messageDiv.style.borderRadius = '8px';
            messageDiv.style.backgroundColor = '#ef4444';
            messageDiv.style.color = 'white';
            messageDiv.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
            
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 3000);
        }

        async function loadRealMetrics() {
            showMetricsLoadingPopup();
            resetMetricsLoadingState();
            try {
                setMetricLoadingState('visibility', 'loading');
                const response = await apiCall('/auth/gsc/metrics');
                if (response.ok) {
                    const metrics = await response.json();
                    updateDashboardMetricsWithRealData(metrics);
                    createChartsWithRealData(metrics);
                    showWebsiteInfo(metrics);
                    showDateRange(metrics);
                    setMetricLoadingState('visibility', 'done');
                    setMetricLoadingState('organic', 'done');
                    setMetricLoadingState('impressions', 'done');
                    // Fetch keyword data
                    await loadKeywordData();
                } else {
                    setMetricLoadingState('visibility', 'done');
                    setMetricLoadingState('organic', 'done');
                    setMetricLoadingState('impressions', 'done');
                    updateDashboardMetrics(false);
                    createCharts(false);
                    hideWebsiteInfo();
                    hideDateRange();
                }
            } catch (error) {
                setMetricLoadingState('visibility', 'done');
                setMetricLoadingState('organic', 'done');
                setMetricLoadingState('impressions', 'done');
                updateDashboardMetrics(false);
                createCharts(false);
                hideWebsiteInfo();
                hideDateRange();
            }
        }

        async function loadKeywordData() {
            setMetricLoadingState('keywords', 'loading');
            try {
                const response = await apiCall('/auth/keyword/metrics');
                if (response.ok) {
                    const keywordData = await response.json();
                    updateKeywordMetrics(keywordData);
                    setMetricLoadingState('keywords', 'done');
                } else {
                    setMetricLoadingState('keywords', 'done');
                }
            } catch (error) {
                setMetricLoadingState('keywords', 'done');
            }
        }

        function updateKeywordMetrics(keywordData) {
            // Update keyword metrics in the dashboard
            document.getElementById('totalKeywords').textContent = keywordData.total_keywords?.toLocaleString() || '0';
            document.getElementById('keywordAvgPosition').textContent = keywordData.avg_position?.toFixed(1) || 'N/A';
            document.getElementById('keywordOpportunities').textContent = keywordData.opportunities?.toLocaleString() || '0';
            document.getElementById('brandedKeywords').textContent = keywordData.branded_keywords?.toLocaleString() || '0';
            
            // Update keyword insights
            if (keywordData.keyword_insights) {
                document.getElementById('keywordInsights').innerHTML = `<p>${keywordData.keyword_insights}</p>`;
            }
            
            // Update status indicator based on keyword performance
            const statusIndicator = document.getElementById('keywordStatus');
            if (keywordData.total_keywords > 0) {
                if (keywordData.avg_position <= 3) {
                    statusIndicator.textContent = 'Excellent';
                    statusIndicator.className = 'status-indicator good';
                } else if (keywordData.avg_position <= 10) {
                    statusIndicator.textContent = 'Good';
                    statusIndicator.className = 'status-indicator good';
                } else if (keywordData.avg_position <= 20) {
                    statusIndicator.textContent = 'Needs Work';
                    statusIndicator.className = 'status-indicator warning';
                } else {
                    statusIndicator.textContent = 'Poor';
                    statusIndicator.className = 'status-indicator error';
                }
            } else {
                statusIndicator.textContent = 'No Data';
                statusIndicator.className = 'status-indicator warning';
            }
        }

        function createChartsWithRealData(metrics) {
            const rootStyles = getComputedStyle(document.documentElement);
            const primaryColor = rootStyles.getPropertyValue('--color-primary').trim();
            
            const timeSeries = metrics.time_series;
            const dates = timeSeries.dates || [];
            const clicksData = timeSeries.clicks || [];
            const impressionsData = timeSeries.impressions || [];
            
            if (organicTrafficChart) organicTrafficChart.destroy();
            if (impressionsChart) impressionsChart.destroy();

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: { beginAtZero: true, grid: { color: 'rgba(0, 0, 0, 0.05)' } },
                    x: { grid: { display: false }, ticks: {
                        callback: function(value, index, values) {
                            const label = this.getLabelForValue(value);
                            if (label === dates[0] || label === dates[Math.floor(dates.length/2)] || label === dates[dates.length-1]) {
                                return label;
                            }
                            return null;
                        }
                    } }
                },
                elements: {
                    line: {
                        borderColor: primaryColor,
                        backgroundColor: 'rgba(249, 115, 22, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }
                }
            };
            
            const organicTrafficCtx = document.getElementById('organicTrafficChart').getContext('2d');
            organicTrafficChart = new Chart(organicTrafficCtx, {
                type: 'line',
                data: { labels: dates, datasets: [{ data: clicksData }] },
                options: chartOptions
            });

            const impressionsCtx = document.getElementById('impressionsChart').getContext('2d');
            impressionsChart = new Chart(impressionsCtx, {
                type: 'line',
                data: { labels: dates, datasets: [{ data: impressionsData }] },
                options: chartOptions
            });
        }

        function calculateSEOScore(summary, ux = {}, mobile = {}, indexing = {}, keywords = {}) {
            // Define all metrics, their weights, and normalization functions
            const metrics = [
                // Visibility
                { key: 'avg_ctr', value: summary.avg_ctr, weight: 10, norm: v => Math.min(v / 0.10, 1) },
                { key: 'avg_position', value: summary.avg_position, weight: 10, norm: v => Math.max((10 - v) / 10, 0) },
                { key: 'total_impressions', value: summary.total_impressions, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 6, 1) },
                { key: 'total_clicks', value: summary.total_clicks, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 5, 1) },
                // UX
                { key: 'performance_score', value: ux.performance_score, weight: 10, norm: v => (v / 100) },
                { key: 'lcp', value: ux.lcp, weight: 5, norm: v => 1 - Math.min(v, 4) / 4 },
                { key: 'fcp', value: ux.fcp, weight: 5, norm: v => 1 - Math.min(v, 3) / 3 },
                { key: 'cls', value: ux.cls, weight: 5, norm: v => 1 - Math.min(v, 0.25) / 0.25 },
                // Mobile
                { key: 'mobile_friendly', value: mobile.mobile_friendly, weight: 10, norm: v => (v === 'Yes' || v === 'Pass') ? 1 : 0 },
                { key: 'issues_count', value: mobile.issues_count, weight: 5, norm: v => 1 - Math.min(v, 5) / 5 },
                // Indexing
                { key: 'sitemap_status', value: indexing.sitemap_status, weight: 5, norm: v => v === 'Active' ? 1 : 0 },
                { key: 'index_status', value: indexing.index_status, weight: 5, norm: v => ['PASS', 'NEUTRAL'].includes(v) ? 1 : 0 },
                // Keywords
                { key: 'total_keywords', value: keywords.total_keywords, weight: 5, norm: v => Math.min(Math.log10(v + 1) / 4, 1) },
                { key: 'opportunities', value: keywords.opportunities, weight: 5, norm: v => Math.min(v / 10, 1) },
                { key: 'branded_keywords', value: (keywords.branded_keywords !== undefined && keywords.total_keywords) ? 1 - Math.min(keywords.branded_keywords / (keywords.total_keywords || 1), 1) : undefined, weight: 5, norm: v => v },
            ];

            // Filter out missing metrics
            const present = metrics.filter(m => m.value !== undefined && m.value !== null && !Number.isNaN(m.value));
            const totalWeight = present.reduce((sum, m) => sum + m.weight, 0);
            if (totalWeight === 0) return 0;

            // Dynamically scale weights so total is 100
            let score = 0;
            present.forEach(m => {
                const scaledWeight = m.weight * (100 / totalWeight);
                let normValue = m.key === 'branded_keywords' ? m.value : m.norm(m.value);
                normValue = Math.max(0, Math.min(normValue, 1));
                score += normValue * scaledWeight;
            });
            return Math.round(score);
        }

        function formatDateString(dateStr) {
            // dateStr is in "YYYY-MM-DD" format
            if (!dateStr || dateStr.split('-').length !== 3) {
                return '';
            }
            const [year, month, day] = dateStr.split('-');
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const monthName = monthNames[parseInt(month, 10) - 1];
            return `${monthName} ${parseInt(day, 10)}`;
        }

        function showDateRange(metrics) {
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            const dateRangeSpan = document.getElementById('dateRange');

            if (metrics && metrics.start_date && metrics.end_date) {
                const startStr = formatDateString(metrics.start_date);
                const endStr = formatDateString(metrics.end_date);
                
                dateRangeSpan.textContent = `${startStr} - ${endStr}`;
                dateRangeInfo.classList.remove('hidden');
            } else {
                hideDateRange();
            }
        }

        function hideDateRange() {
            document.getElementById('dateRangeInfo').classList.add('hidden');
        }

        function showWebsiteInfo(metrics) {
            const websiteInfo = document.getElementById('websiteInfo');
            const trackedWebsite = document.getElementById('trackedWebsite');

            if (metrics && metrics.website_url) {
                let displayUrl = metrics.website_url;
                if (displayUrl.startsWith('sc-domain:')) {
                    displayUrl = displayUrl.replace('sc-domain:', '');
                }
                trackedWebsite.textContent = displayUrl;
                websiteInfo.classList.remove('hidden');
            } else {
                hideWebsiteInfo();
            }
        }

        function hideWebsiteInfo() {
            document.getElementById('websiteInfo').classList.add('hidden');
        }

        function changeWebsite() {
            // Redirect to setup wizard to select a different website
            window.location.href = '/setup';
        }
        
        function showMetricsLoadingPopup() {
            const popup = document.getElementById('metricsLoadingPopup');
            popup.style.display = 'flex';
            // Force reflow for transition
            void popup.offsetWidth;
            popup.classList.remove('metrics-loading-hide');
            popup.classList.add('metrics-loading-visible');
            updateMetricsLoadingList();
        }
        function hideMetricsLoadingPopup() {
            const popup = document.getElementById('metricsLoadingPopup');
            popup.classList.remove('metrics-loading-visible');
            popup.classList.add('metrics-loading-hide');
            function onTransitionEnd(e) {
                if (e.propertyName === 'transform') {
                    popup.style.display = 'none';
                    popup.removeEventListener('transitionend', onTransitionEnd);
                }
            }
            popup.addEventListener('transitionend', onTransitionEnd);
        }
        function showMetricsSuccessPopup() {
            const popup = document.getElementById('metricsSuccessPopup');
            popup.style.display = 'flex';
            // Force reflow for transition
            void popup.offsetWidth;
            popup.classList.remove('metrics-success-hide');
            popup.classList.add('metrics-success-visible');
        }
        function hideMetricsSuccessPopup() {
            const popup = document.getElementById('metricsSuccessPopup');
            popup.classList.remove('metrics-success-visible');
            popup.classList.add('metrics-success-hide');
            function onTransitionEnd(e) {
                if (e.propertyName === 'transform') {
                    popup.style.display = 'none';
                    popup.removeEventListener('transitionend', onTransitionEnd);
                }
            }
            popup.addEventListener('transitionend', onTransitionEnd);
        }
        function updateMetricsLoadingList() {
            const list = document.getElementById('metricsLoadingList');
            list.innerHTML = METRIC_GROUPS.map(m => {
                const state = metricsLoadingState[m.key];
                if (state === 'done') {
                    return `<div style="display:flex;align-items:center;gap:0.5rem;color:#16a34a;font-weight:400;"><span style='display:inline-block;width:18px;height:18px;'><svg width='18' height='18'><polyline points='3,10 8,15 15,4' style='fill:none;stroke:#16a34a;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;'/></svg></span>${m.label}</div>`;
                } else {
                    return `<div style="display:flex;align-items:center;gap:0.5rem;color:#D97706;"><span class="metric-loading-spinner" style='display:inline-block;width:18px;height:18px;'><svg width='18' height='18' viewBox='0 0 50 50'><circle cx='25' cy='25' r='20' fill='none' stroke='#D97706' stroke-width='5' stroke-linecap='round' stroke-dasharray='31.4 31.4' stroke-dashoffset='0'><animateTransform attributeName='transform' type='rotate' from='0 25 25' to='360 25 25' dur='0.8s' repeatCount='indefinite'/></circle></svg></span>${m.label}</div>`;
                }
            }).join('');
        }
        function setMetricLoadingState(key, state) {
            metricsLoadingState[key] = state;
            updateMetricsLoadingList();
            // If all done, show success popup and hide both after 5s with countdown
            if (METRIC_GROUPS.every(m => metricsLoadingState[m.key] === 'done')) {
                const loadingPopup = document.getElementById('metricsLoadingPopup');
                const successPopup = document.getElementById('metricsSuccessPopup');
                loadingPopup.style.display = 'flex';
                successPopup.style.display = 'flex';
                showMetricsSuccessPopup();
                let secondsLeft = 5;
                const timerSpan = document.getElementById('metricsSuccessTimer');
                timerSpan.textContent = `(${secondsLeft}s)`;
                const interval = setInterval(() => {
                    secondsLeft--;
                    timerSpan.textContent = `(${secondsLeft}s)`;
                    if (secondsLeft <= 0) {
                        clearInterval(interval);
                        hideMetricsSuccessPopup();
                        hideMetricsLoadingPopup();
                    }
                }, 1000);
            }
        }
        function resetMetricsLoadingState() {
            METRIC_GROUPS.forEach(m => metricsLoadingState[m.key] = 'loading');
            updateMetricsLoadingList();
        }
        
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html> 